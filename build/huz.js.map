{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///huz.js","webpack:///webpack/bootstrap 7759b43e79111b918236","webpack:///./src/index.js","webpack:///./src/extension.js","webpack:///./src/helpers.js","webpack:///./src/token.js","webpack:///./src/node.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js","webpack:///./src/extensions/inheritance.js","webpack:///./src/renderer.js","webpack:///./~/escape-html/index.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","parse","src","opts","parser","_parser","Parser","compile","_renderer","Renderer","render","context","r","defineProperty","value","_token","TokenType","_node","NodeType","_helpers","Helpers","_extension","_extensionsInheritance","_tokenizer","enumerable","get","Tokenizer","register","Inheritance","_classCallCheck","instance","Constructor","TypeError","instantiateAll","registry","map","ctor","constructor","push","_createClass","defineProperties","target","props","length","descriptor","configurable","writable","protoProps","staticProps","Extension","token","parserContext","node","renderContext","walk","modifier","stack","children","slice","reverse","pop","undefined","concat","visit","visitor","_parent","child","modified","trimStandaloneToken","tokens","count","open","inline","standalone","indentTokens","type","VARIABLE","UNESCAPED_VARIABLE","TEXT","isStringWhitespace","text","DELIMITER_CHANGE","COMMENT","SECTION_CLOSE","name","tailWSNodeCount","indent","forEach","t","str","test","EOF","PARTIAL","INVERTED_SECTION_OPEN","SECTION_OPEN","ROOT","SECTION","ParserContext","_appendNode","_pushParent","_popParent","message","_throw","_filename","_stack","arguments","_delimiters","delimiters","_extensions","extensions","filename","_parserContext","_lastToken","_src","rootNode","_parseNodes","_addNodeToken","location","JSON","stringify","beginLocation","endLocation","_clone","endIndex","endLine","initialStackSize","z","getNextToken","error","handled","ext","handleToken","_makeLocation","unescaped","_handleSectionOpen","_handleSectionClose","_handleComment","n","join","e","Error","inverted","section","raw","index","content","extractNewDelimiters","tagContent","matches","match","R_DELIMITER_CHANGE","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","Array","isArray","STATE_NONE","STATE_EOF","STATE_TEXT","STATE_TEXT_BREAK","STATE_TAG","DELIMITER_LEFT","DELIMITER_RIGHT","_index","_char","_tokens","_line","_column","_state","_error","_location","line","column","shift","matched","_markTokenStartLocation","_read","_handleEOF","_handleText","_handleTextBreak","_handleTag","_markTokenEndLocation","_isDelimiter","_handleStandaloneTag","_makeToken","left","right","_skip","_skipAllWhitespaces","_setError","_handleEmptyTag","tagTypeChar","_handleVariableCurly","tagContentStart","_handleSimpleTag","substr","_handleDelimiterChange","_handleVariable","newDelimiters","_newDelimiters","trim","begin","d","_distance","console","log","_isWhitespace","endColumn","offset","delimiter","pos","transformToken","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","isInheritanceTagType","PARENT","BLOCK","_get","_x","_x2","_x3","_again","object","property","receiver","desc","parent","getter","Function","getOwnPropertyDescriptor","getPrototypeOf","_token2","LEAVE_SCOPE","_Extension","_blocks","pushParent","tagNode","tailNode","popParent","appendNode","firstLine","firstBlock","find","blockNode","top","f","rendererContext","_handleParent","_handleBlock","_this","pushNodes","blockName","pushNode","_interopRequireDefault","default","isFunction","x","toString","nodeTypes","_escapeHtml","_escapeHtml2","REPEATER_NODE_TYPE","MAX_PARTIAL_STACK","MAX_LAMBDA_STACK","RenderContext","renderer","_evaluate","nodes","_pushNodes","_pushNode","ctx","_pushContext","_parse","_getParsedPartial","_parsed","parsed","_partials","partials","_renderContext","_partialCached","keys","k","_contextStack","_partialStack","_lambdaStack","_this2","out","newline","_loop","handleNode","splice","partial","_popNode","_expandLambda","isList","testResult","_pushRepeaterNode","_expandPartial","repeat","repeatIndex","contextIndex","contexts","_replaceContextAt","_checkStacks","list","sp","RangeError","_ref","_ref2","path","split","current","resolved","pi","ast","_pushPartial","lambda","_pushLambda","skipped","code","escapeHtml","string","matchHtmlRegExp","exec","escape","html","lastIndex","charCodeAt","substring"],"mappings":"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","file":"huz.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.parse = parse;\n\texports.compile = compile;\n\texports.render = render;\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tvar _parser = __webpack_require__(5);\n\t\n\tvar _renderer = __webpack_require__(8);\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar Helpers = _interopRequireWildcard(_helpers);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _extensionsInheritance = __webpack_require__(7);\n\t\n\tvar _tokenizer = __webpack_require__(6);\n\t\n\tObject.defineProperty(exports, 'Tokenizer', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _tokenizer.Tokenizer;\n\t  }\n\t});\n\texports.Parser = _parser.Parser;\n\texports.Renderer = _renderer.Renderer;\n\texports.TokenType = TokenType;\n\texports.NodeType = NodeType;\n\t\n\t(0, _extension.register)(_extensionsInheritance.Inheritance);\n\t\n\tfunction parse(src, opts) {\n\t  var parser = new _parser.Parser(opts);\n\t  return parser.parse(src);\n\t}\n\t\n\tfunction compile(src, opts) {\n\t  return new _renderer.Renderer(src, opts);\n\t}\n\t\n\tfunction render(src, context, opts) {\n\t  var r = compile(src, opts);\n\t  return r.render(context);\n\t}\n\t\n\texports.register = _extension.register;\n\texports.Helpers = Helpers;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\texports.instantiateAll = instantiateAll;\n\texports.register = register;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar registry = [];\n\t\n\tvar Extension = (function () {\n\t  function Extension() {\n\t    _classCallCheck(this, Extension);\n\t  }\n\t\n\t  _createClass(Extension, [{\n\t    key: \"transformToken\",\n\t\n\t    //called by tokenizer\n\t    value: function transformToken(token) {\n\t      return token;\n\t    }\n\t\n\t    //called by parser\n\t  }, {\n\t    key: \"handleToken\",\n\t    value: function handleToken(token, parserContext) {}\n\t  }, {\n\t    key: \"visit\",\n\t    value: function visit(root) {\n\t      return root;\n\t    }\n\t\n\t    //called by renderer\n\t  }, {\n\t    key: \"handleNode\",\n\t    value: function handleNode(node, renderContext) {}\n\t  }]);\n\t\n\t  return Extension;\n\t})();\n\t\n\texports.Extension = Extension;\n\t\n\tfunction instantiateAll(opts) {\n\t  return registry.map(function (ctor) {\n\t    return new ctor(opts);\n\t  });\n\t}\n\t\n\tfunction register(constructor) {\n\t  return registry.push(constructor);\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.walk = walk;\n\texports.visit = visit;\n\texports.trimStandaloneToken = trimStandaloneToken;\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tfunction walk(root, modifier) {\n\t  var stack = root.children.slice(0).reverse();\n\t  while (stack.length) {\n\t    var node = stack.pop();\n\t    modifier(node);\n\t    if (node.children !== undefined) {\n\t      stack = stack.concat(node.children.slice(0).reverse());\n\t    }\n\t  }\n\t}\n\t\n\tfunction visit(root, visitor) {\n\t  var stack = [root];\n\t  while (stack.length) {\n\t    var _parent = stack.pop();\n\t    for (var i = 0; i < _parent.children.length; i++) {\n\t      var child = _parent.children[i];\n\t      var modified = visitor.visit(child) || child;\n\t      if (modified !== child) {\n\t        _parent.children[i] = modified;\n\t      }\n\t      if (child.children && child.children.length) {\n\t        stack.push(child);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction trimStandaloneToken(tokens) {\n\t  var count = tokens.length;\n\t\n\t  if (count === 0) {\n\t    return tokens;\n\t  }\n\t\n\t  var open = null;\n\t  var inline = 0;\n\t  var standalone = true;\n\t  var indentTokens = [];\n\t  for (var i = 0; standalone && i < count; i++) {\n\t    var token = tokens[i];\n\t    switch (token.type) {\n\t      case TokenType.VARIABLE:\n\t      case TokenType.UNESCAPED_VARIABLE:\n\t        standalone = false;\n\t        break;\n\t      case TokenType.TEXT:\n\t        if (isStringWhitespace(token.text)) {\n\t          if (inline === 0) {\n\t            indentTokens.push(token);\n\t          }\n\t        } else {\n\t          standalone = false;\n\t        }\n\t        break;\n\t      case TokenType.DELIMITER_CHANGE:\n\t      case TokenType.COMMENT:\n\t        if (open !== null) {\n\t          open.push(token);\n\t        } else {\n\t          inline++;\n\t        }\n\t        break;\n\t      case TokenType.SECTION_CLOSE:\n\t        if (open) {\n\t          if (open[0].name === token.name) {\n\t            open = null;\n\t          } else {\n\t            standalone = false;\n\t          }\n\t        } else {\n\t          inline++;\n\t        }\n\t        break;\n\t      default:\n\t        //section-like tags\n\t        if (open === null) {\n\t          open = [token];\n\t          inline++;\n\t        } else {\n\t          standalone = false;\n\t        }\n\t        break;\n\t    }\n\t\n\t    if (inline > 1) {\n\t      standalone = false;\n\t    }\n\t  }\n\t\n\t  if (open && open.length > 1) {\n\t    standalone = false;\n\t  }\n\t\n\t  if (standalone) {\n\t    //all whitespace\n\t    if (indentTokens.length === count) {\n\t      return tokens;\n\t    }\n\t\n\t    var tailWSNodeCount = 0;\n\t    for (var i = count - 1; i >= 0; i--) {\n\t      var token = tokens[i];\n\t      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n\t        tailWSNodeCount++;\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n\t      //trim\n\t      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n\t      if (indentTokens.length) {\n\t        var indent = '';\n\t        indentTokens.forEach(function (t) {\n\t          indent += t.text;\n\t        });\n\t        tokens[0].indent = indent;\n\t      }\n\t    }\n\t  }\n\t  return tokens;\n\t}\n\t\n\tfunction isStringWhitespace(str) {\n\t  return (/^\\s*$/.test(str)\n\t  );\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar EOF = 'EOF';\n\texports.EOF = EOF;\n\tvar TEXT = 'TEXT';\n\texports.TEXT = TEXT;\n\tvar PARTIAL = 'PARTIAL';\n\texports.PARTIAL = PARTIAL;\n\tvar INVERTED_SECTION_OPEN = 'INVERTED_SECTION_OPEN';\n\texports.INVERTED_SECTION_OPEN = INVERTED_SECTION_OPEN;\n\tvar SECTION_OPEN = 'SECTION_OPEN';\n\texports.SECTION_OPEN = SECTION_OPEN;\n\tvar SECTION_CLOSE = 'SECTION_CLOSE';\n\texports.SECTION_CLOSE = SECTION_CLOSE;\n\tvar UNESCAPED_VARIABLE = 'UNESCAPED_VARIABLE';\n\texports.UNESCAPED_VARIABLE = UNESCAPED_VARIABLE;\n\tvar COMMENT = 'COMMENT';\n\texports.COMMENT = COMMENT;\n\tvar VARIABLE = 'VARIABLE';\n\texports.VARIABLE = VARIABLE;\n\tvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\texports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar ROOT = 'ROOT';\n\texports.ROOT = ROOT;\n\tvar VARIABLE = 'VARIABLE';\n\texports.VARIABLE = VARIABLE;\n\tvar SECTION = 'SECTION';\n\texports.SECTION = SECTION;\n\tvar TEXT = 'TEXT';\n\texports.TEXT = TEXT;\n\tvar COMMENT = 'COMMENT';\n\texports.COMMENT = COMMENT;\n\tvar PARTIAL = 'PARTIAL';\n\texports.PARTIAL = PARTIAL;\n\tvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\texports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _tokenizer = __webpack_require__(6);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar ParserContext = (function () {\n\t  function ParserContext(parser) {\n\t    _classCallCheck(this, ParserContext);\n\t\n\t    this._parser = parser;\n\t  }\n\t\n\t  _createClass(ParserContext, [{\n\t    key: 'appendNode',\n\t    value: function appendNode(node) {\n\t      this._parser._appendNode(node);\n\t    }\n\t  }, {\n\t    key: 'pushParent',\n\t    value: function pushParent(node) {\n\t      this._parser._pushParent(node);\n\t    }\n\t  }, {\n\t    key: 'popParent',\n\t    value: function popParent() {\n\t      return this._parser._popParent();\n\t    }\n\t  }, {\n\t    key: 'throw',\n\t    value: function _throw(message) {\n\t      return this._parser._throw(message);\n\t    }\n\t  }, {\n\t    key: 'filename',\n\t    get: function get() {\n\t      return this._parser._filename;\n\t    }\n\t  }, {\n\t    key: 'top',\n\t    get: function get() {\n\t      return this._parser._stack.length;\n\t    }\n\t  }, {\n\t    key: 'tailNode',\n\t    get: function get() {\n\t      return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n\t    }\n\t  }]);\n\t\n\t  return ParserContext;\n\t})();\n\t\n\tvar Parser = (function () {\n\t  function Parser() {\n\t    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t    _classCallCheck(this, Parser);\n\t\n\t    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n\t    this._filename = opts.filename || '';\n\t\n\t    if (this._extensions.length > 0) {\n\t      this._parserContext = new ParserContext(this);\n\t    }\n\t\n\t    this._stack = null;\n\t    this._lastToken = null;\n\t    this._src = null;\n\t  }\n\t\n\t  _createClass(Parser, [{\n\t    key: 'parse',\n\t    value: function parse(src) {\n\t      var rootNode = {\n\t        type: NodeType.ROOT,\n\t        children: []\n\t      };\n\t      this._src = src;\n\t      this._stack = [rootNode];\n\t      this._lastToken = null;\n\t      this._parseNodes(src);\n\t\n\t      if (this._extensions.length > 0) {\n\t        for (var i = 0; i < this._extensions.length; i++) {\n\t          this._extensions[i].visit(rootNode);\n\t        }\n\t      }\n\t\n\t      return rootNode;\n\t    }\n\t  }, {\n\t    key: '_addNodeToken',\n\t    value: function _addNodeToken(node) {\n\t      var token = this._lastToken;\n\t      if (node.tokens) {\n\t        node.tokens.push(token);\n\t      } else {\n\t        node.tokens = [token];\n\t      }\n\t    }\n\t  }, {\n\t    key: '_appendNode',\n\t    value: function _appendNode(node) {\n\t      this._addNodeToken(node);\n\t      node.location.filename = this._filename;\n\t      this._stack[this._stack.length - 1].children.push(node);\n\t      return node;\n\t    }\n\t  }, {\n\t    key: '_getTop',\n\t    value: function _getTop() {\n\t      return this._stack[this._stack.length - 1];\n\t    }\n\t  }, {\n\t    key: '_clone',\n\t    value: function _clone(obj) {\n\t      return JSON.parse(JSON.stringify(obj));\n\t    }\n\t  }, {\n\t    key: '_makeLocation',\n\t    value: function _makeLocation(beginLocation, endLocation) {\n\t      var location = this._clone(beginLocation);\n\t      if (endLocation) {\n\t        location.endIndex = endLocation.endIndex;\n\t        location.endLine = endLocation.endLine;\n\t      }\n\t      return location;\n\t    }\n\t  }, {\n\t    key: '_parseNodes',\n\t    value: function _parseNodes(src) {\n\t      var initialStackSize = this._stack.length;\n\t      var token = undefined;\n\t      var z = new _tokenizer.Tokenizer(src, {\n\t        delimiters: this._delimiters.slice(0),\n\t        extensions: this._extensions\n\t      });\n\t\n\t      do {\n\t        token = z.getNextToken();\n\t\n\t        if (z.error !== null) {\n\t          throw z.error;\n\t        }\n\t\n\t        this._lastToken = token;\n\t\n\t        var handled = false;\n\t        if (this._extensions) {\n\t          for (var i = 0; i < this._extensions.length; i++) {\n\t            var ext = this._extensions[i];\n\t            if (ext.handleToken(token, this._parserContext) === true) {\n\t              handled = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (!handled) {\n\t          switch (token.type) {\n\t            case TokenType.TEXT:\n\t              this._appendNode({\n\t                type: NodeType.TEXT,\n\t                text: token.text,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.VARIABLE:\n\t            case TokenType.UNESCAPED_VARIABLE:\n\t              this._appendNode({\n\t                type: NodeType.VARIABLE,\n\t                name: token.name,\n\t                unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.SECTION_OPEN:\n\t              this._handleSectionOpen(token);\n\t              break;\n\t\n\t            case TokenType.INVERTED_SECTION_OPEN:\n\t              this._handleSectionOpen(token, true);\n\t              break;\n\t\n\t            case TokenType.SECTION_CLOSE:\n\t              this._handleSectionClose(token);\n\t              break;\n\t\n\t            case TokenType.PARTIAL:\n\t              this._appendNode({\n\t                type: NodeType.PARTIAL,\n\t                name: token.name,\n\t                indent: token.indent,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.COMMENT:\n\t              this._handleComment(token);\n\t              break;\n\t\n\t            case TokenType.DELIMITER_CHANGE:\n\t              this._appendNode({\n\t                type: NodeType.DELIMITER_CHANGE,\n\t                delimiters: token.delimiters,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t          }\n\t        }\n\t      } while (token.type !== TokenType.EOF);\n\t\n\t      if (this._stack.length > initialStackSize) {\n\t        this._throw('Unexpected EOF: sections not closed: ' + this._stack.slice(initialStackSize).map(function (n) {\n\t          return '\\'' + n.name + '\\'';\n\t        }).join(', '));\n\t      } else if (this._stack.length < initialStackSize) {\n\t        this._throw('Internal error.');\n\t      }\n\t    }\n\t  }, {\n\t    key: '_throw',\n\t    value: function _throw(message) {\n\t      var e = new Error(message);\n\t      e.location = this._lastToken.location;\n\t      throw e;\n\t    }\n\t  }, {\n\t    key: '_pushParent',\n\t    value: function _pushParent(node) {\n\t      this._addNodeToken(node);\n\t      node.children = [];\n\t      this._stack.push(node);\n\t    }\n\t  }, {\n\t    key: '_popParent',\n\t    value: function _popParent() {\n\t      return this._stack.pop();\n\t    }\n\t  }, {\n\t    key: '_handleSectionOpen',\n\t    value: function _handleSectionOpen(token) {\n\t      var inverted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t      var name = token.name;\n\t      var location = token.location;\n\t\n\t      this._pushParent({\n\t        type: NodeType.SECTION,\n\t        name: name,\n\t        inverted: inverted,\n\t        location: location\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleSectionClose',\n\t    value: function _handleSectionClose(token) {\n\t      var name = token.name;\n\t      var location = token.location;\n\t\n\t      var section = this._popParent();\n\t      if (section.type !== NodeType.SECTION) {\n\t        this._throw('Unexpected SECTION_CLOSE: \\'' + name + '\\'');\n\t      }\n\t\n\t      if (section.name !== name) {\n\t        this._throw('Unexpected SECTION_CLOSE: \\'' + name + '\\', current section: \\'' + section.name + '\\'');\n\t      }\n\t\n\t      section.raw = this._src.slice(section.location.endIndex, location.index);\n\t      section.location = this._makeLocation(section.location, token.location);\n\t\n\t      this._appendNode(section);\n\t    }\n\t  }, {\n\t    key: '_handleComment',\n\t    value: function _handleComment(token) {\n\t      var content = token.content;\n\t      var location = token.location;\n\t\n\t      this._appendNode({\n\t        type: NodeType.COMMENT,\n\t        content: content,\n\t        location: this._makeLocation(location)\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Parser;\n\t})();\n\n\texports.Parser = Parser;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar STATE_NONE = 'STATE_NONE';\n\tvar STATE_EOF = 'STATE_EOF';\n\tvar STATE_TEXT = 'STATE_TEXT';\n\tvar STATE_TEXT_BREAK = 'STATE_TEXT_BREAK';\n\tvar STATE_TAG = 'STATE_TAG';\n\t\n\tvar DELIMITER_LEFT = 0;\n\tvar DELIMITER_RIGHT = 1;\n\t\n\tvar Tokenizer = (function () {\n\t  function Tokenizer(src) {\n\t    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Tokenizer);\n\t\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n\t    this._src = src;\n\t    this._index = 0;\n\t    this._char = null;\n\t    this._tokens = [];\n\t    this._line = 0;\n\t    this._column = 0;\n\t    this._state = STATE_NONE;\n\t    this._error = null;\n\t    this._location = {\n\t      index: 0,\n\t      line: 0,\n\t      column: 0\n\t    };\n\t    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n\t  }\n\t\n\t  _createClass(Tokenizer, [{\n\t    key: 'getNextToken',\n\t    value: function getNextToken() {\n\t      if (this._tokens.length > 0) {\n\t        return this._tokens.shift();\n\t      }\n\t\n\t      var done = false;\n\t      var matched = false;\n\t      do {\n\t        //console.log(this._state, this._tokens);\n\t        if (this._error !== null) {\n\t          return null;\n\t        }\n\t\n\t        if (this._state !== STATE_NONE) {\n\t          matched = true;\n\t          this._markTokenStartLocation();\n\t        }\n\t\n\t        switch (this._state) {\n\t          case STATE_NONE:\n\t            this._read();\n\t            break;\n\t\n\t          case STATE_EOF:\n\t            this._handleEOF();\n\t            done = true;\n\t            break;\n\t\n\t          case STATE_TEXT:\n\t            this._handleText();\n\t            break;\n\t\n\t          case STATE_TEXT_BREAK:\n\t            this._handleTextBreak();\n\t            done = true;\n\t            break;\n\t\n\t          case STATE_TAG:\n\t            this._handleTag();\n\t            break;\n\t        }\n\t\n\t        if (matched && !this._error) {\n\t          this._markTokenEndLocation();\n\t          matched = false;\n\t        }\n\t\n\t        if (this._state === STATE_NONE) {\n\t          if (this._char === null) {\n\t            this._state = STATE_EOF;\n\t          } else if (this._char === '\\n') {\n\t            this._state = STATE_TEXT_BREAK;\n\t          } else if (this._isDelimiter(DELIMITER_LEFT)) {\n\t            this._state = STATE_TAG;\n\t          } else {\n\t            this._state = STATE_TEXT;\n\t          }\n\t        }\n\t      } while (!done);\n\t\n\t      return this._error === null ? this._tokens.shift() : null;\n\t    }\n\t\n\t    // Handlers\n\t\n\t  }, {\n\t    key: '_handleEOF',\n\t    value: function _handleEOF() {\n\t      this._handleStandaloneTag();\n\t      this._makeToken({\n\t        type: TokenType.EOF\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleTag',\n\t    value: function _handleTag() {\n\t      var _delimiters = _slicedToArray(this._delimiters, 2);\n\t\n\t      var left = _delimiters[0];\n\t      var right = _delimiters[1];\n\t\n\t      this._skip(left.length);\n\t      this._skipAllWhitespaces();\n\t\n\t      if (this._char === null) {\n\t        this._setError('Unclosed tag.');\n\t      } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n\t        this._handleEmptyTag();\n\t      } else {\n\t        var tagTypeChar = this._char;\n\t        if (tagTypeChar === '{') {\n\t          this._handleVariableCurly();\n\t        } else {\n\t          var tagContentStart = this._index - 1;\n\t          //read content\n\t          while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n\t            this._read();\n\t          }\n\t\n\t          if (this._char === null) {\n\t            this._setError('Unclosed tag.');\n\t          } else {\n\t            var content = this._src.slice(tagContentStart, this._index - 1);\n\t            switch (tagTypeChar) {\n\t              case '>':\n\t                this._handleSimpleTag(TokenType.PARTIAL, content);break;\n\t              case '^':\n\t                this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);break;\n\t              case '#':\n\t                this._handleSimpleTag(TokenType.SECTION_OPEN, content);break;\n\t              case '/':\n\t                this._handleSimpleTag(TokenType.SECTION_CLOSE, content);break;\n\t\n\t              case '!':\n\t                this._handleComment(content.substr(1));\n\t                break;\n\t\n\t              case '=':\n\t                this._handleDelimiterChange(content);\n\t                break;\n\t              case '&':\n\t                this._handleVariable(content.substr(1), true);\n\t                break;\n\t              default:\n\t                this._handleVariable(content);\n\t                break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      if (this._error === null) {\n\t        //eat right\n\t        for (var i = 0; i < right.length; i++) {\n\t          this._read();\n\t        }\n\t      }\n\t\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleDelimiterChange',\n\t    value: function _handleDelimiterChange(content) {\n\t      var newDelimiters = extractNewDelimiters(content);\n\t      if (newDelimiters === null) {\n\t        this._setError('Invalid change delimiter syntax.');\n\t      } else {\n\t        var _newDelimiters = _slicedToArray(newDelimiters, 2);\n\t\n\t        var left = _newDelimiters[0];\n\t        var right = _newDelimiters[1];\n\t\n\t        this._delimiters = newDelimiters;\n\t        this._makeToken({\n\t          type: TokenType.DELIMITER_CHANGE,\n\t          delimiters: [left, right]\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleSimpleTag',\n\t    value: function _handleSimpleTag(type, content) {\n\t      this._makeToken({ type: type, name: content.substr(1).trim() });\n\t    }\n\t  }, {\n\t    key: '_handleComment',\n\t    value: function _handleComment(content) {\n\t      this._makeToken({\n\t        type: TokenType.COMMENT,\n\t        content: content\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleVariableCurly',\n\t    value: function _handleVariableCurly() {\n\t      this._read(); //eat '{'\n\t      var begin = this._index - 1;\n\t      var d = this._distance('}');\n\t      if (d === -1) {\n\t        this._setError('Unclosed variable tag: missingright curly.');\n\t      } else {\n\t        var content = this._src.slice(begin, begin + d);\n\t        this._skip(d + 1); //skip '}'\n\t        this._skipAllWhitespaces();\n\t        if (!this._isDelimiter(DELIMITER_RIGHT)) {\n\t          this._setError('Unclosed variable: missing right delimiter.');\n\t        } else {\n\t          this._makeToken({\n\t            type: TokenType.UNESCAPED_VARIABLE,\n\t            name: content.trim()\n\t          });\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleEmptyTag',\n\t    value: function _handleEmptyTag() {\n\t      this._makeToken({\n\t        type: TokenType.VARIABLE,\n\t        name: ''\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleVariable',\n\t    value: function _handleVariable(content, unescaped) {\n\t      this._makeToken({\n\t        type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n\t        name: content.trim()\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleText',\n\t    value: function _handleText() {\n\t      var done = false;\n\t      var index = this._index - 1;\n\t      var length = 0;\n\t      do {\n\t        var c = this._char;\n\t\n\t        if (c === null || c === '\\n' || this._isDelimiter(DELIMITER_LEFT)) {\n\t          done = true;\n\t        } else {\n\t          length++;\n\t        }\n\t\n\t        if (!done) {\n\t          this._read();\n\t        }\n\t      } while (!done);\n\t\n\t      this._makeToken({\n\t        type: TokenType.TEXT,\n\t        text: this._src.slice(index, index + length)\n\t      });\n\t\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleTextBreak',\n\t    value: function _handleTextBreak() {\n\t      this._makeToken({\n\t        type: TokenType.TEXT,\n\t        text: '\\n'\n\t      });\n\t      this._read();\n\t      this._handleStandaloneTag();\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleStandaloneTag',\n\t    value: function _handleStandaloneTag() {\n\t      this._tokens = (0, _helpers.trimStandaloneToken)(this._tokens);\n\t    }\n\t\n\t    // Helpers\n\t  }, {\n\t    key: '_dump',\n\t    value: function _dump() {\n\t      var t = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\t\n\t      console.log(t + '>' + this._src.slice(this._index - 1));\n\t    }\n\t  }, {\n\t    key: '_read',\n\t    value: function _read() {\n\t      if (this._index < this._src.length) {\n\t        if (this._char === '\\n') {\n\t          this._line++;\n\t          this._column = 0;\n\t        } else {\n\t          this._column++;\n\t        }\n\t\n\t        this._char = this._src[this._index];\n\t        this._index++;\n\t      } else {\n\t        this._char = null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_peek',\n\t    value: function _peek() {\n\t      if (this._index < this._src.length - 1) {\n\t        return this._src[this._index];\n\t      } else {\n\t        return null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_skip',\n\t    value: function _skip(n) {\n\t      for (var i = 0; i < n; i++) {\n\t        this._read();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_distance',\n\t    value: function _distance(c) {\n\t      for (var i = this._index; i < this._src.length; i++) {\n\t        if (this._src[i] === c) {\n\t          return i - this._index + 1;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t  }, {\n\t    key: '_skipAllWhitespaces',\n\t    value: function _skipAllWhitespaces() {\n\t      while (this._isWhitespace()) {\n\t        this._read();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_markTokenStartLocation',\n\t    value: function _markTokenStartLocation() {\n\t      this._location.index = this._index - 1;\n\t      this._location.line = this._line;\n\t      this._location.column = this._column;\n\t    }\n\t  }, {\n\t    key: '_markTokenEndLocation',\n\t    value: function _markTokenEndLocation() {\n\t      var token = this._tokens[this._tokens.length - 1];\n\t      var _location = this._location;\n\t      var index = _location.index;\n\t      var line = _location.line;\n\t      var column = _location.column;\n\t\n\t      token.location = {\n\t        index: index, line: line, column: column,\n\t        endIndex: this._index - 1,\n\t        endLine: this._line,\n\t        endColumn: this._column\n\t      };\n\t    }\n\t  }, {\n\t    key: '_isWhitespace',\n\t    value: function _isWhitespace() {\n\t      return (/\\s/.test(this._char)\n\t      );\n\t    }\n\t  }, {\n\t    key: '_isDelimiter',\n\t    value: function _isDelimiter(d) {\n\t      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\t\n\t      var delimiter = this._delimiters[d];\n\t      var pos = this._index - 1 + offset;\n\t      return this._src.slice(pos, pos + delimiter.length) === delimiter;\n\t    }\n\t  }, {\n\t    key: '_makeToken',\n\t    value: function _makeToken(token) {\n\t      if (this._extensions.length) {\n\t        try {\n\t          this._extensions.forEach(function (ext) {\n\t            token = ext.transformToken(token);\n\t          });\n\t        } catch (e) {\n\t          this._setError(e.message);\n\t          return;\n\t        }\n\t      }\n\t      this._tokens.push(token);\n\t    }\n\t  }, {\n\t    key: '_setError',\n\t    value: function _setError(message) {\n\t      var error = new Error(message);\n\t      error.index = this._index - 1;\n\t      error.line = this._line;\n\t      error.column = this._column;\n\t      this._error = error;\n\t    }\n\t  }, {\n\t    key: 'error',\n\t    get: function get() {\n\t      return this._error;\n\t    }\n\t  }]);\n\t\n\t  return Tokenizer;\n\t})();\n\t\n\texports.Tokenizer = Tokenizer;\n\t\n\tvar R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\n\tfunction extractNewDelimiters(tagContent) {\n\t  var matches = tagContent.match(R_DELIMITER_CHANGE);\n\t  if (matches) {\n\t    return matches.slice(1);\n\t  } else {\n\t    return null;\n\t  }\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://github.com/mustache/spec/pull/75\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _token2 = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token2);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar PARENT = 'Inheritance.PARENT';\n\tvar BLOCK = 'Inheritance.BLOCK';\n\tvar LEAVE_SCOPE = 'Inheritance.LEAVE_SCOPE';\n\t\n\tfunction isInheritanceTagType(type) {\n\t  return type === PARENT || type === BLOCK;\n\t}\n\t\n\tvar Inheritance = (function (_Extension) {\n\t  _inherits(Inheritance, _Extension);\n\t\n\t  function Inheritance() {\n\t    _classCallCheck(this, Inheritance);\n\t\n\t    _get(Object.getPrototypeOf(Inheritance.prototype), 'constructor', this).call(this);\n\t\n\t    this._blocks = null;\n\t  }\n\t\n\t  _createClass(Inheritance, [{\n\t    key: 'transformToken',\n\t    value: function transformToken(token) {\n\t      var _token = token;\n\t      var type = _token.type;\n\t      var name = _token.name;\n\t      var location = _token.location;\n\t\n\t      switch (type) {\n\t        case TokenType.VARIABLE:\n\t          if (name) {\n\t            if (name[0] === '<') {\n\t              if (name.length === 1) {\n\t                throw new Error('Parent partial name expected');\n\t              }\n\t              token = {\n\t                type: PARENT,\n\t                name: name.slice(1),\n\t                location: location\n\t              };\n\t            } else if (name[0] === '$') {\n\t              if (name.length === 1) {\n\t                throw new Error('Block name expected');\n\t              }\n\t              token = {\n\t                type: BLOCK,\n\t                name: name.slice(1),\n\t                location: location\n\t              };\n\t            }\n\t          }\n\t          break;\n\t      }\n\t      return token;\n\t    }\n\t  }, {\n\t    key: 'handleToken',\n\t    value: function handleToken(token, parserContext) {\n\t      var handled = false;\n\t      var name = token.name;\n\t      var location = token.location;\n\t      var type = token.type;\n\t\n\t      switch (type) {\n\t        case PARENT:\n\t          parserContext.pushParent({\n\t            type: PARENT,\n\t            name: name,\n\t            location: location\n\t          });\n\t          handled = true;\n\t          break;\n\t\n\t        case BLOCK:\n\t          parserContext.pushParent({\n\t            type: BLOCK,\n\t            name: name,\n\t            location: location\n\t          });\n\t          break;\n\t\n\t        case TokenType.SECTION_CLOSE:\n\t          var tagNode = parserContext.tailNode;\n\t          if (tagNode === null) {\n\t            if (isInheritanceTagType(tagNode.type)) {\n\t              parserContext['throw']('Unexpected tag close');\n\t            }\n\t          } else {\n\t            if (tagNode.name !== name) {\n\t              parserContext['throw']('Unexpected tag close, current tag: ' + tagNode.name);\n\t            }\n\t            if (isInheritanceTagType(tagNode.type)) {\n\t              parserContext.popParent();\n\t              tagNode.location.endIndex = location.endIndex;\n\t              tagNode.location.endLine = location.endLine;\n\t              parserContext.appendNode(tagNode);\n\t\n\t              //TODO move this to visit, handle whitespaces after Parent close tag.\n\t              var firstLine = tagNode.location.line;\n\t              var firstBlock = tagNode.children.find(function (c) {\n\t                return c.type === BLOCK;\n\t              });\n\t              if (firstBlock && firstBlock.location.line === firstLine) {\n\t                for (var i = 0; i < firstBlock.children.length; i++) {\n\t                  var blockNode = firstBlock.children[i];\n\t                  if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n\t                    blockNode.text = '';\n\t                  } else {\n\t                    break;\n\t                  }\n\t                }\n\t              }\n\t\n\t              handled = true;\n\t            }\n\t          }\n\t          break;\n\t\n\t        case TokenType.EOF:\n\t          if (this.top > 0) {\n\t            parserContext['throw']('Unexpected EOF: tags not closed: ' + this.stack.map(function (f) {\n\t              return f.name;\n\t            }).join(', '));\n\t          }\n\t          break;\n\t      }\n\t      return handled;\n\t    }\n\t  }, {\n\t    key: 'handleNode',\n\t    value: function handleNode(node, rendererContext) {\n\t      switch (node.type) {\n\t        case PARENT:\n\t          this._handleParent(node, rendererContext);\n\t          return true;\n\t\n\t        case BLOCK:\n\t          this._handleBlock(node, rendererContext);\n\t          return true;\n\t\n\t        case LEAVE_SCOPE:\n\t          this._blocks = null;\n\t          return true;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleParent',\n\t    value: function _handleParent(node, rendererContext) {\n\t      var _this = this;\n\t\n\t      var name = node.name;\n\t      var location = node.location;\n\t\n\t      if (this._blocks === null) {\n\t        rendererContext.pushNodes([{\n\t          type: LEAVE_SCOPE\n\t        }]);\n\t        this._blocks = {};\n\t      }\n\t\n\t      //find all blocks defined in parent\n\t      node.children.forEach(function (child) {\n\t        if (child.type === BLOCK) {\n\t          var blockName = child.name;\n\t          if (!_this._blocks.hasOwnProperty(blockName)) {\n\t            _this._blocks[blockName] = child;\n\t          }\n\t        }\n\t      });\n\t\n\t      rendererContext.pushNode({\n\t        type: TokenType.PARTIAL,\n\t        name: name, location: location,\n\t        indent: node.indent\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleBlock',\n\t    value: function _handleBlock(node, rendererContext) {\n\t      var name = node.name;\n\t\n\t      if (this._blocks !== null && this._blocks.hasOwnProperty(name)) {\n\t        rendererContext.pushNodes(this._blocks[name].children);\n\t      } else {\n\t        rendererContext.pushNodes(node.children);\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return Inheritance;\n\t})(_extension.Extension);\n\n\texports.Inheritance = Inheritance;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar nodeTypes = _interopRequireWildcard(_node);\n\t\n\tvar _escapeHtml = __webpack_require__(9);\n\t\n\tvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\t\n\tvar _parser = __webpack_require__(5);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar REPEATER_NODE_TYPE = '_REPEATER';\n\tvar MAX_PARTIAL_STACK = 10;\n\tvar MAX_LAMBDA_STACK = 255;\n\t\n\tvar RenderContext = (function () {\n\t  function RenderContext(renderer) {\n\t    _classCallCheck(this, RenderContext);\n\t\n\t    this._renderer = renderer;\n\t  }\n\t\n\t  _createClass(RenderContext, [{\n\t    key: 'evaluate',\n\t    value: function evaluate(name) {\n\t      return this._renderer._evaluate(name);\n\t    }\n\t  }, {\n\t    key: 'pushNodes',\n\t    value: function pushNodes(nodes) {\n\t      this._renderer._pushNodes(nodes);\n\t    }\n\t  }, {\n\t    key: 'pushNode',\n\t    value: function pushNode(node) {\n\t      this._renderer._pushNode(node);\n\t    }\n\t  }, {\n\t    key: 'pushContext',\n\t    value: function pushContext(ctx) {\n\t      this._renderer._pushContext(ctx);\n\t    }\n\t  }, {\n\t    key: 'parse',\n\t    value: function parse(src, opts) {\n\t      return this._renderer._parse(src, opts);\n\t    }\n\t  }, {\n\t    key: 'getParsedPartial',\n\t    value: function getParsedPartial(name) {\n\t      return this._renderer._getParsedPartial(name);\n\t    }\n\t  }, {\n\t    key: 'throw',\n\t    value: function _throw(message, location) {\n\t      return this._renderer._throw(message, location);\n\t    }\n\t  }, {\n\t    key: 'top',\n\t    get: function get() {\n\t      return this._renderer._stack.length;\n\t    }\n\t  }]);\n\t\n\t  return RenderContext;\n\t})();\n\t\n\tvar Renderer = (function () {\n\t  function Renderer(src) {\n\t    var _this = this;\n\t\n\t    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Renderer);\n\t\n\t    //if this is true, src and values in partials are parsed tree, not string\n\t    this._parsed = opts.parsed || false;\n\t\n\t    this._partials = opts.partials || {};\n\t    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n\t    if (this._extensions.length > 0) {\n\t      this._renderContext = new RenderContext(this);\n\t    }\n\t\n\t    this._partialCached = {};\n\t    if (this._parsed) {\n\t      Object.keys(this._partials).forEach(function (k) {\n\t        _this._partialCached[k] = _this._partials[k].children;\n\t      });\n\t    }\n\t\n\t    this._stack = null;\n\t    this._contextStack = null;\n\t    this._partialStack = null;\n\t    this._lambdaStack = null;\n\t    this._src = src;\n\t  }\n\t\n\t  _createClass(Renderer, [{\n\t    key: 'render',\n\t    value: function render(context) {\n\t      var _this2 = this;\n\t\n\t      this._stack = [];\n\t      this._contextStack = [];\n\t      this._partialStack = [];\n\t      this._lambdaStack = [];\n\t\n\t      this._pushContext(context);\n\t\n\t      //push root nodes\n\t      var rootNode = this._parsed ? this._src : this._parse(this._src);\n\t      this._stack = rootNode.children.slice(0).reverse();\n\t\n\t      var out = '';\n\t      var newline = true;\n\t\n\t      var _loop = function () {\n\t        var top = _this2._stack.length - 1;\n\t        var node = _this2._stack[top];\n\t\n\t        var handled = false;\n\t        if (_this2._extensions) {\n\t          _this2._extensions.forEach(function (ext) {\n\t            if (ext.handleNode(node, _this2._renderContext)) {\n\t              handled = true;\n\t            }\n\t          });\n\t        }\n\t\n\t        if (handled) {\n\t          _this2._stack.splice(top, 1);\n\t        } else {\n\t          var partial = _this2._partialStack.length ? _this2._partialStack[_this2._partialStack.length - 1] : null;\n\t\n\t          //insert indent\n\t          if (node.type in nodeTypes) {\n\t            if (newline && partial !== null && partial.indent.length > 0) {\n\t              out += partial.indent;\n\t            }\n\t          }\n\t\n\t          var value = undefined;\n\t          switch (node.type) {\n\t            case nodeTypes.VARIABLE:\n\t              value = _this2._evaluate(node.name);\n\t              if (isFunction(value)) {\n\t                _this2._popNode();\n\t                _this2._expandLambda(node, value);\n\t              } else {\n\t                if (!!value) {\n\t                  out += node.unescaped ? value : (0, _escapeHtml2['default'])(value);\n\t                }\n\t                _this2._popNode();\n\t              }\n\t              break;\n\t\n\t            case nodeTypes.SECTION:\n\t              value = _this2._evaluate(node.name);\n\t              if (isFunction(value)) {\n\t                _this2._popNode();\n\t                _this2._expandLambda(node, value);\n\t              } else {\n\t                var isList = Array.isArray(value);\n\t\n\t                if (isList && value.length === 0) {\n\t                  //Empty lists should behave like falsey values.\n\t                  value = false;\n\t                  isList = false;\n\t                }\n\t\n\t                var testResult = !!value;\n\t                if (node.inverted) {\n\t                  testResult = !testResult;\n\t                }\n\t\n\t                if (testResult) {\n\t                  if (isList) {\n\t                    _this2._popNode();\n\t                    _this2._pushRepeaterNode(value.length, node.children, value);\n\t                  } else {\n\t                    _this2._popNode();\n\t                    _this2._pushContext(value);\n\t                    _this2._pushNodes(node.children);\n\t                  }\n\t                } else {\n\t                  _this2._popNode();\n\t                }\n\t              }\n\t              break;\n\t\n\t            case nodeTypes.TEXT:\n\t              out += node.text;\n\t              _this2._popNode();\n\t              break;\n\t\n\t            case nodeTypes.COMMENT:\n\t              _this2._popNode();\n\t              break;\n\t\n\t            case nodeTypes.PARTIAL:\n\t              _this2._popNode();\n\t              _this2._expandPartial(node);\n\t              break;\n\t\n\t            case nodeTypes.DELIMITER_CHANGE:\n\t              _this2._popNode();\n\t              _this2._delimiters = node.delimiters.slice(0);\n\t              break;\n\t\n\t            case REPEATER_NODE_TYPE:\n\t              if (node.count < node.repeat) {\n\t                var repeatIndex = node.count;\n\t                if (repeatIndex === 0) {\n\t                  node.contextIndex = _this2._pushContext(node.contexts[0]);\n\t                } else {\n\t                  _this2._replaceContextAt(node.contextIndex, node.contexts[repeatIndex]);\n\t                }\n\t                _this2._pushNodes(node.children);\n\t                node.count++;\n\t              } else {\n\t                _this2._popNode();\n\t              }\n\t              break;\n\t\n\t            default:\n\t              _this2._popNode();\n\t              break;\n\t          }\n\t        }\n\t        _this2._checkStacks();\n\t        newline = out.length === 0 || out[out.length - 1] === '\\n';\n\t      };\n\t\n\t      while (this._stack.length > 0) {\n\t        _loop();\n\t      }\n\t      return out;\n\t    }\n\t  }, {\n\t    key: '_parse',\n\t    value: function _parse(src) {\n\t      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t      opts.extensions = this._extensions;\n\t      var parser = new _parser.Parser(opts);\n\t      return parser.parse(src);\n\t    }\n\t  }, {\n\t    key: '_pushNodes',\n\t    value: function _pushNodes(list) {\n\t      for (var i = list.length - 1; i >= 0; i--) {\n\t        this._stack.push(list[i]);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_pushNode',\n\t    value: function _pushNode(node) {\n\t      this._stack.push(node);\n\t    }\n\t  }, {\n\t    key: '_popNode',\n\t    value: function _popNode() {\n\t      this._stack.pop();\n\t    }\n\t  }, {\n\t    key: '_pushRepeaterNode',\n\t    value: function _pushRepeaterNode(repeat, nodes, contexts) {\n\t      this._stack.push({\n\t        type: REPEATER_NODE_TYPE,\n\t        count: 0,\n\t        repeat: repeat,\n\t        children: nodes.slice(0),\n\t        contexts: contexts\n\t      });\n\t    }\n\t  }, {\n\t    key: '_pushContext',\n\t    value: function _pushContext(context) {\n\t      return this._contextStack.push({\n\t        context: context,\n\t        sp: this._stack.length\n\t      }) - 1;\n\t    }\n\t  }, {\n\t    key: '_replaceContextAt',\n\t    value: function _replaceContextAt(index, context) {\n\t      if (index < 0 || index > this._contextStack.length - 1) {\n\t        throw new RangeError('Huz context index out of range.');\n\t      }\n\t      this._contextStack[index].context = context;\n\t    }\n\t  }, {\n\t    key: '_pushPartial',\n\t    value: function _pushPartial(_ref) {\n\t      var name = _ref.name;\n\t      var indent = _ref.indent;\n\t      var location = _ref.location;\n\t\n\t      this._partialStack.push({\n\t        name: name,\n\t        indent: indent || '',\n\t        location: location,\n\t        sp: this._stack.length\n\t      });\n\t    }\n\t  }, {\n\t    key: '_pushLambda',\n\t    value: function _pushLambda(_ref2) {\n\t      var name = _ref2.name;\n\t      var location = _ref2.location;\n\t\n\t      this._lambdaStack.push({\n\t        name: name,\n\t        location: location,\n\t        sp: this._stack.length\n\t      });\n\t    }\n\t  }, {\n\t    key: '_checkStacks',\n\t    value: function _checkStacks() {\n\t      if (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n\t        this._contextStack.pop();\n\t      }\n\t\n\t      if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n\t        this._partialStack.pop();\n\t      }\n\t\n\t      if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n\t        this._lambdaStack.pop();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_evaluate',\n\t    value: function _evaluate(name) {\n\t      if (name === '.') {\n\t        return this._contextStack[this._contextStack.length - 1].context;\n\t      }\n\t\n\t      var path = name.split('.');\n\t      for (var i = this._contextStack.length - 1; i >= 0; i--) {\n\t        var context = this._contextStack[i].context;\n\t        if (context === null || typeof context !== 'object') {\n\t          continue;\n\t        }\n\t\n\t        var current = context;\n\t        var resolved = true;\n\t        for (var pi = 0; pi < path.length; pi++) {\n\t          var key = path[pi];\n\t          if (typeof current === 'object' && current !== null && current.hasOwnProperty(key)) {\n\t            current = current[key];\n\t          } else {\n\t            resolved = false;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (resolved) {\n\t          return current;\n\t        }\n\t      }\n\t      return '';\n\t    }\n\t  }, {\n\t    key: '_getParsedPartial',\n\t    value: function _getParsedPartial(name) {\n\t      if (this._partialCached.hasOwnProperty(name)) {\n\t        return this._partialCached[name];\n\t      } else {\n\t        if (!this._partials.hasOwnProperty(name)) {\n\t          return null;\n\t        }\n\t        var ast = this._parse(this._partials[name], { filename: name });\n\t        var nodes = this._partialCached[name] = ast.children;\n\t        return nodes;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_expandPartial',\n\t    value: function _expandPartial(node) {\n\t      var name = node.name;\n\t\n\t      var nodes = this._getParsedPartial(name);\n\t\n\t      if (nodes === null) {\n\t        //The empty string should be used when the named partial is not found.\n\t        return;\n\t      }\n\t\n\t      this._pushPartial(node);\n\t\n\t      if (this._partialStack.length > MAX_PARTIAL_STACK) {\n\t        this._throw('Possible partial short circuit: ' + this._partialStack.map(function (f) {\n\t          return f.name + '@' + f.location.filename + ':' + (f.location.line + 1);\n\t        }).concat([name]).join(' -> '), node.location);\n\t      }\n\t\n\t      this._pushNodes(nodes);\n\t    }\n\t  }, {\n\t    key: '_expandLambda',\n\t    value: function _expandLambda(node, lambda) {\n\t      var name = node.name;\n\t\n\t      this._pushLambda(node);\n\t\n\t      if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n\t        this._throw('Possible lambda short circuit: ' + this._lambdaStack.map(function (f) {\n\t          return f.name + '@' + f.location.filename + ':' + (f.location.line + 1);\n\t        }).concat([name]).join(' -> '), node.location);\n\t      }\n\t\n\t      var ast = undefined;\n\t      var skipped = false;\n\t      if (node.type === nodeTypes.VARIABLE) {\n\t        var code = lambda();\n\t        if (code) {\n\t          //A lambda's return value should parse with the default delimiters.\n\t          ast = this._parse('' + code, { filename: '[lambda]' });\n\t          if (!node.unescaped) {\n\t            //Lambda results should be appropriately escaped.\n\t            (0, _helpers.walk)(ast, function (node) {\n\t              if (node.type === nodeTypes.TEXT) {\n\t                node.text = (0, _escapeHtml2['default'])(node.text);\n\t              }\n\t            });\n\t          }\n\t        } else {\n\t          skipped = true;\n\t        }\n\t      } else if (node.type === nodeTypes.SECTION) {\n\t        var code = lambda(node.raw);\n\t        if (code) {\n\t          //Lambdas used for inverted sections should be considered truthy.\n\t          //Lambdas used for sections should parse with the current delimiters.\n\t          ast = this._parse('' + code, {\n\t            filename: '[#lambda]',\n\t            delimiters: this._delimiters.slice(0)\n\t          });\n\t        } else {\n\t          skipped = true;\n\t        }\n\t      }\n\t\n\t      if (!skipped) {\n\t        this._pushNodes(ast.children);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_throw',\n\t    value: function _throw(message, location) {\n\t      var e = new Error(message);\n\t      e.location = location;\n\t      throw e;\n\t    }\n\t  }]);\n\t\n\t  return Renderer;\n\t})();\n\t\n\texports.Renderer = Renderer;\n\t\n\tfunction isFunction(x) {\n\t  return Object.prototype.toString.call(x) == '[object Function]';\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * escape-html\n\t * Copyright(c) 2012-2013 TJ Holowaychuk\n\t * Copyright(c) 2015 Andreas Lubbe\n\t * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n\t * MIT Licensed\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Module variables.\n\t * @private\n\t */\n\t\n\tvar matchHtmlRegExp = /[\"'&<>]/;\n\t\n\t/**\n\t * Module exports.\n\t * @public\n\t */\n\t\n\tmodule.exports = escapeHtml;\n\t\n\t/**\n\t * Escape special characters in the given string of html.\n\t *\n\t * @param  {string} string The string to escape for inserting into HTML\n\t * @return {string}\n\t * @public\n\t */\n\t\n\tfunction escapeHtml(string) {\n\t  var str = '' + string;\n\t  var match = matchHtmlRegExp.exec(str);\n\t\n\t  if (!match) {\n\t    return str;\n\t  }\n\t\n\t  var escape;\n\t  var html = '';\n\t  var index = 0;\n\t  var lastIndex = 0;\n\t\n\t  for (index = match.index; index < str.length; index++) {\n\t    switch (str.charCodeAt(index)) {\n\t      case 34: // \"\n\t        escape = '&quot;';\n\t        break;\n\t      case 38: // &\n\t        escape = '&amp;';\n\t        break;\n\t      case 39: // '\n\t        escape = '&#39;';\n\t        break;\n\t      case 60: // <\n\t        escape = '&lt;';\n\t        break;\n\t      case 62: // >\n\t        escape = '&gt;';\n\t        break;\n\t      default:\n\t        continue;\n\t    }\n\t\n\t    if (lastIndex !== index) {\n\t      html += str.substring(lastIndex, index);\n\t    }\n\t\n\t    lastIndex = index + 1;\n\t    html += escape;\n\t  }\n\t\n\t  return lastIndex !== index\n\t    ? html + str.substring(lastIndex, index)\n\t    : html;\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** huz.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7759b43e79111b918236\n **/","import { Parser } from './parser';\nimport { Renderer } from './renderer';\nimport * as TokenType from './token';\nimport * as NodeType from './node';\nimport * as Helpers from './helpers';\nimport { register } from './extension';\n\nexport { Tokenizer } from './tokenizer';\nexport { Parser, Renderer, TokenType, NodeType };\n\nimport { Inheritance } from './extensions/inheritance';\n\nregister(Inheritance);\n\nexport function parse(src, opts) {\n  const parser = new Parser(opts);\n  return parser.parse(src);\n}\n\nexport function compile(src, opts) {\n  return new Renderer(src, opts);\n}\n\nexport function render(src, context, opts) {\n  const r = compile(src, opts);\n  return r.render(context);\n}\n\nexport { register, Helpers };\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","const registry = [];\n\nexport class Extension {\n  //called by tokenizer\n  transformToken(token) { return token; }\n\n  //called by parser\n  handleToken(token, parserContext) { }\n  visit(root) { return root; }\n  \n  //called by renderer\n  handleNode(node, renderContext) { }\n}\n\nexport function instantiateAll(opts) {\n  return registry.map(ctor => {\n    return new ctor(opts);\n  });\n}\n\nexport function register(constructor) {\n  return registry.push(constructor);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/extension.js\n **/","import * as TokenType from './token';\n\nexport function walk(root, modifier) {\n  let stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    const node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nexport function visit(root, visitor) {\n  let stack = [root];\n  while (stack.length) {\n    const parent = stack.pop();\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      const modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nexport function trimStandaloneToken(tokens) {\n  const count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  let open = null;\n  let inline = 0;\n  let standalone = true;\n  let indentTokens = [];\n  for (let i = 0; standalone && i < count; i++) {\n    const token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline ++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline ++;\n        }\n        break;\n      default: //section-like tags\n        if (open === null) {\n          open = [token];\n          inline ++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n  \n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    let tailWSNodeCount = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount ++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        let indent = '';\n        indentTokens.forEach(t => { indent += t.text });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return /^\\s*$/.test(str);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/helpers.js\n **/","export const EOF                    = 'EOF';\nexport const TEXT                   = 'TEXT';\nexport const PARTIAL                = 'PARTIAL';\nexport const INVERTED_SECTION_OPEN  = 'INVERTED_SECTION_OPEN';\nexport const SECTION_OPEN           = 'SECTION_OPEN';\nexport const SECTION_CLOSE          = 'SECTION_CLOSE';\nexport const UNESCAPED_VARIABLE     = 'UNESCAPED_VARIABLE';\nexport const COMMENT                = 'COMMENT';\nexport const VARIABLE               = 'VARIABLE';\nexport const DELIMITER_CHANGE \t\t\t= 'DELIMITER_CHANGE';\n\n\n/** WEBPACK FOOTER **\n ** ./src/token.js\n **/","export const ROOT             = 'ROOT';\nexport const VARIABLE         = 'VARIABLE';\nexport const SECTION          = 'SECTION';\nexport const TEXT             = 'TEXT';\nexport const COMMENT          = 'COMMENT';\nexport const PARTIAL          = 'PARTIAL';\nexport const DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\n\n/** WEBPACK FOOTER **\n ** ./src/node.js\n **/","import * as TokenType from './token';\nimport * as NodeType from './node';\nimport { Tokenizer } from './tokenizer';\nimport { visit } from './helpers';\nimport { instantiateAll } from './extension';\n\nclass ParserContext {\n  constructor(parser) {\n    this._parser = parser;\n  }\n\n  appendNode(node) {\n    this._parser._appendNode(node);\n  }\n\n  pushParent(node) {\n    this._parser._pushParent(node);\n  }\n\n  popParent() {\n    return this._parser._popParent();\n  }\n\n  get filename() {\n    return this._parser._filename;\n  }\n\n  get top() {\n    return this._parser._stack.length;\n  }\n\n  get tailNode() {\n    return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n  }\n\n  throw(message) {\n    return this._parser._throw(message);\n  }\n}\n\nexport class Parser {\n  constructor(opts = {}) {\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    this._filename = opts.filename || '';\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  parse(src) {\n    const rootNode = { \n      type: NodeType.ROOT, \n      children: []\n    };\n    this._src = src;\n    this._stack = [rootNode];\n    this._lastToken = null;\n    this._parseNodes(src);\n\n    if (this._extensions.length > 0) {\n      for (let i = 0; i < this._extensions.length; i++) {\n        this._extensions[i].visit(rootNode);\n      }\n    }\n\n    return rootNode;\n  }\n\n  _addNodeToken(node) {\n    const token = this._lastToken;\n    if (node.tokens) {\n      node.tokens.push(token);\n    } else {\n      node.tokens = [token];\n    }\n  }\n\n  _appendNode(node) {\n    this._addNodeToken(node);\n    node.location.filename = this._filename;\n    this._stack[this._stack.length - 1].children.push(node);\n    return node;\n  }\n\n  _getTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  _clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  _makeLocation(beginLocation, endLocation) {\n    const location = this._clone(beginLocation);\n    if (endLocation) {\n      location.endIndex = endLocation.endIndex;\n      location.endLine = endLocation.endLine;\n    }\n    return location;\n  }\n\n  _parseNodes(src) {\n    let initialStackSize = this._stack.length;\n    let token;\n    const z = new Tokenizer(src, { \n      delimiters: this._delimiters.slice(0),\n      extensions: this._extensions\n    });\n\n    do {\n      token = z.getNextToken();\n\n      if (z.error !== null) {\n        throw z.error;\n      }\n\n      this._lastToken = token;\n\n      let handled = false;\n      if (this._extensions) {\n        for (let i = 0; i < this._extensions.length; i++) {\n          const ext = this._extensions[i];\n          if (ext.handleToken(token, this._parserContext) === true) {\n            handled = true;\n            break;\n          }\n        }\n      }\n\n      if (!handled) {\n        switch (token.type) {\n          case TokenType.TEXT:\n            this._appendNode({\n              type: NodeType.TEXT,\n              text: token.text,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.VARIABLE:\n          case TokenType.UNESCAPED_VARIABLE:\n            this._appendNode({\n              type: NodeType.VARIABLE,\n              name: token.name,\n              unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.SECTION_OPEN:\n            this._handleSectionOpen(token);\n            break;\n\n          case TokenType.INVERTED_SECTION_OPEN:\n            this._handleSectionOpen(token, true);\n            break;\n\n          case TokenType.SECTION_CLOSE:\n            this._handleSectionClose(token);\n            break;\n\n          case TokenType.PARTIAL:\n            this._appendNode({\n              type: NodeType.PARTIAL,\n              name: token.name,\n              indent: token.indent,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.COMMENT:\n            this._handleComment(token);\n            break;\n\n          case TokenType.DELIMITER_CHANGE:\n            this._appendNode({\n              type: NodeType.DELIMITER_CHANGE,\n              delimiters: token.delimiters,\n              location: this._makeLocation(token.location)\n            });\n            break;\n        }\n      }\n    } while (token.type !== TokenType.EOF);\n\n    if (this._stack.length > initialStackSize) {\n      this._throw('Unexpected EOF: sections not closed: ' + \n        this._stack.slice(initialStackSize).map(n => `'${n.name}'`).join(', '));\n    } else if (this._stack.length < initialStackSize) {\n      this._throw('Internal error.');\n    }\n  }\n\n  _throw(message) {\n    const e = new Error(message);\n    e.location = this._lastToken.location;\n    throw e;\n  }\n\n  _pushParent(node) {\n    this._addNodeToken(node);\n    node.children = [];\n    this._stack.push(node);\n  }\n\n  _popParent() {\n    return this._stack.pop();\n  }\n\n  _handleSectionOpen(token, inverted = false) {\n    const { name, location } = token;\n    this._pushParent({\n      type: NodeType.SECTION,\n      name,\n      inverted,\n      location\n    });\n  }\n\n  _handleSectionClose(token) {\n    const { name, location } = token;\n    const section = this._popParent();\n    if (section.type !== NodeType.SECTION) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}'`);\n    }\n\n    if (section.name !== name) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}', current section: '${section.name}'`);\n    }\n\n    section.raw = this._src.slice(section.location.endIndex, location.index);\n    section.location = this._makeLocation(section.location, token.location);\n\n    this._appendNode(section);\n  }\n\n  _handleComment(token) {\n    const { content, location } = token;\n    this._appendNode({\n      type: NodeType.COMMENT,\n      content,\n      location: this._makeLocation(location)\n    });\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parser.js\n **/","import * as TokenType from './token';\nimport { instantiateAll } from './extension';\nimport { trimStandaloneToken } from './helpers';\n\nconst STATE_NONE        = 'STATE_NONE';\nconst STATE_EOF         = 'STATE_EOF';\nconst STATE_TEXT        = 'STATE_TEXT';\nconst STATE_TEXT_BREAK  = 'STATE_TEXT_BREAK';\nconst STATE_TAG         = 'STATE_TAG';\n\nconst DELIMITER_LEFT  = 0;\nconst DELIMITER_RIGHT = 1;\n\nexport class Tokenizer {\n  constructor(src, opts = {}) {\n    this._extensions = opts.extensions || instantiateAll();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 0;\n    this._column = 0;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  getNextToken() {\n    if (this._tokens.length > 0) {\n      return this._tokens.shift();\n    }\n\n    let done = false;\n    let matched = false;\n    do {\n      //console.log(this._state, this._tokens);\n      if (this._error !== null) {\n        return null;\n      }\n\n      if (this._state !== STATE_NONE) {\n        matched = true;\n        this._markTokenStartLocation();\n      }\n\n      switch (this._state) {\n        case STATE_NONE:\n          this._read();\n          break;\n\n        case STATE_EOF:\n          this._handleEOF();\n          done = true;\n          break;\n\n        case STATE_TEXT:\n          this._handleText();\n          break;\n\n        case STATE_TEXT_BREAK:\n          this._handleTextBreak();\n          done = true;\n          break;\n\n        case STATE_TAG:\n          this._handleTag();\n          break;\n      }\n\n      if (matched && !this._error) {\n        this._markTokenEndLocation();\n        matched = false;\n      }\n\n      if (this._state === STATE_NONE) {\n        if (this._char === null) {\n          this._state = STATE_EOF;\n        } else if (this._char === '\\n') {\n          this._state = STATE_TEXT_BREAK;\n        } else if (this._isDelimiter(DELIMITER_LEFT)) {\n          this._state = STATE_TAG;\n        } else {\n          this._state = STATE_TEXT;\n        }\n      }\n\n    } while (!done);\n\n    return this._error === null ? this._tokens.shift() : null;\n  }\n\n  // Handlers\n\n  _handleEOF() {\n    this._handleStandaloneTag();\n    this._makeToken({ \n      type: TokenType.EOF\n    });\n  }\n\n  _handleTag() {\n    const [ left, right ] = this._delimiters;\n    this._skip(left.length);\n    this._skipAllWhitespaces();\n\n    if (this._char === null) {\n      this._setError('Unclosed tag.');\n    }\n    else if (this._isDelimiter(DELIMITER_RIGHT)) {\n      this._handleEmptyTag();\n    } else {\n      const tagTypeChar = this._char;\n      if (tagTypeChar === '{') {\n        this._handleVariableCurly();\n      } else {\n        let tagContentStart = this._index - 1;\n        //read content\n        while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n          this._read();\n        }\n\n        if (this._char === null) {\n          this._setError('Unclosed tag.');\n        } else {\n          const content = this._src.slice(tagContentStart, this._index - 1);\n          switch (tagTypeChar) {\n            case '>': this._handleSimpleTag(TokenType.PARTIAL, content); break;\n            case '^': this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content); break;\n            case '#': this._handleSimpleTag(TokenType.SECTION_OPEN, content); break;\n            case '/': this._handleSimpleTag(TokenType.SECTION_CLOSE, content); break;\n\n            case '!':\n              this._handleComment(content.substr(1));\n              break;\n\n            case '=':\n              this._handleDelimiterChange(content);\n              break;\n            case '&':\n              this._handleVariable(content.substr(1), true);\n              break;\n            default:\n              this._handleVariable(content);\n              break;\n          }\n        }\n      }\n    }\n    if (this._error === null) {\n      //eat right\n      for (let i = 0; i < right.length; i++) {\n        this._read();\n      }\n    }\n\n    this._state = STATE_NONE;\n  }\n\n  _handleDelimiterChange(content) {\n    const newDelimiters = extractNewDelimiters(content);\n    if (newDelimiters === null) {\n      this._setError('Invalid change delimiter syntax.');\n    } else {\n      const [ left, right ] = newDelimiters;\n      this._delimiters = newDelimiters;\n      this._makeToken({\n        type: TokenType.DELIMITER_CHANGE,\n        delimiters: [ left, right ]\n      });\n    }\n  }\n\n  _handleSimpleTag(type, content) {\n    this._makeToken({ type, name: content.substr(1).trim() });\n  }\n\n  _handleComment(content) {\n    this._makeToken({\n      type: TokenType.COMMENT,\n      content\n    });\n  }\n\n  _handleVariableCurly() {\n    this._read(); //eat '{'\n    const begin = this._index - 1;\n    const d = this._distance('}');\n    if (d === -1) {\n      this._setError('Unclosed variable tag: missingright curly.');\n    } else {\n      const content = this._src.slice(begin, begin + d);\n      this._skip(d + 1); //skip '}'\n      this._skipAllWhitespaces();\n      if (!this._isDelimiter(DELIMITER_RIGHT)) {\n        this._setError('Unclosed variable: missing right delimiter.');\n      } else {\n        this._makeToken({\n          type: TokenType.UNESCAPED_VARIABLE,\n          name: content.trim()\n        });\n      }\n    }\n  }\n\n  _handleEmptyTag() {\n    this._makeToken({\n      type: TokenType.VARIABLE,\n      name: ''\n    });\n  }\n\n  _handleVariable(content, unescaped) {\n    this._makeToken({\n      type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n      name: content.trim()\n    });\n  }\n\n  _handleText() {\n    let done = false;\n    let index = this._index - 1;\n    let length = 0;\n    do {\n      const c = this._char;\n\n      if (c === null || c === '\\n' || this._isDelimiter(DELIMITER_LEFT)) {\n        done = true;\n      } else {\n        length ++;\n      }\n\n      if (!done) {\n        this._read();\n      }\n    } while (!done);\n\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: this._src.slice(index, index + length)\n    });\n\n    this._state = STATE_NONE;\n  }\n\n  _handleTextBreak() {\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: '\\n'\n    });\n    this._read();\n    this._handleStandaloneTag();\n    this._state = STATE_NONE;\n  }\n\n  _handleStandaloneTag() {\n    this._tokens = trimStandaloneToken(this._tokens);\n  }\n\n  // Helpers\n  _dump(t = '') {\n    console.log(t +'>'+this._src.slice(this._index - 1));\n  }\n\n  _read() {\n    if (this._index < this._src.length) {\n      if (this._char === '\\n') {\n        this._line ++;\n        this._column = 0;\n      } else {\n        this._column ++;\n      }\n\n      this._char = this._src[this._index];\n      this._index ++;\n    } else {\n      this._char = null;\n    }\n  }\n\n  _peek() {\n    if (this._index < this._src.length - 1) {\n      return this._src[this._index];\n    } else {\n      return null;\n    }\n  }\n\n  _skip(n) {\n    for (let i = 0; i < n; i ++) {\n      this._read();\n    }\n  }\n\n  _distance(c) {\n    for (let i = this._index; i < this._src.length; i++) {\n      if (this._src[i] === c) {\n        return i - this._index + 1;\n      }\n    }\n    return -1;\n  }\n\n  _skipAllWhitespaces() {\n    while (this._isWhitespace()) {\n      this._read();\n    }\n  }\n\n  _markTokenStartLocation() {\n    this._location.index = this._index - 1;\n    this._location.line = this._line;\n    this._location.column = this._column;\n  }\n\n  _markTokenEndLocation() {\n    const token = this._tokens[this._tokens.length - 1];\n    const { index, line, column } = this._location;\n    token.location = {\n      index, line, column,\n      endIndex: this._index - 1,\n      endLine: this._line,\n      endColumn: this._column\n    };\n  }\n\n  _isWhitespace() {\n    return /\\s/.test(this._char);\n  }\n\n  _isDelimiter(d, offset = 0) {\n    const delimiter = this._delimiters[d];\n    const pos = this._index - 1 + offset;\n    return this._src.slice(pos, pos + delimiter.length) === delimiter;\n  }\n\n  _makeToken(token) {\n    if (this._extensions.length) {\n      try {\n        this._extensions.forEach(ext => {\n          token = ext.transformToken(token);\n        });\n      } catch (e) {\n        this._setError(e.message);\n        return;\n      }\n    }\n    this._tokens.push(token);\n  }\n\n  _setError(message) {\n    const error = new Error(message);\n    error.index = this._index - 1;\n    error.line = this._line;\n    error.column = this._column;\n    this._error = error;\n  }\n}\n\nconst R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  const matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/tokenizer.js\n **/","// https://github.com/mustache/spec/pull/75\n\nimport { Extension, register } from '../extension';\nimport * as NodeType from '../node';\nimport * as TokenType from '../token';\nimport { walk } from '../helpers';\n\nconst PARENT = 'Inheritance.PARENT';\nconst BLOCK = 'Inheritance.BLOCK';\nconst LEAVE_SCOPE = 'Inheritance.LEAVE_SCOPE';\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nexport class Inheritance extends Extension {\n  constructor() {\n    super();\n\n    this._blocks = null;\n  }\n\n  transformToken(token) {\n    const { type, name, location } = token;\n    switch (type) {\n      case TokenType.VARIABLE:\n        if (name) {\n          if (name[0] === '<') {\n            if (name.length === 1) {\n              throw new Error('Parent partial name expected');\n            }\n            token = {\n              type: PARENT,\n              name: name.slice(1),\n              location\n            };\n          } else if (name[0] === '$') {\n            if (name.length === 1) {\n              throw new Error('Block name expected');\n            }\n            token = {\n              type: BLOCK,\n              name: name.slice(1),\n              location\n            };\n          }\n        }\n        break;\n    }\n    return token;\n  }\n\n  handleToken(token, parserContext) {\n    let handled = false;\n    const { name, location, type } = token;\n    switch (type) {\n      case PARENT:\n        parserContext.pushParent({\n          type: PARENT,\n          name,\n          location\n        });\n        handled = true;\n        break;\n\n      case BLOCK:\n        parserContext.pushParent({\n          type: BLOCK,\n          name,\n          location\n        });\n        break;\n\n      case TokenType.SECTION_CLOSE:\n        const tagNode = parserContext.tailNode;\n        if (tagNode === null) {\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.throw('Unexpected tag close');\n          }\n        } else {\n          if (tagNode.name !== name) {\n            parserContext.throw(`Unexpected tag close, current tag: ${tagNode.name}`);\n          }\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.popParent();\n            tagNode.location.endIndex = location.endIndex;\n            tagNode.location.endLine = location.endLine;\n            parserContext.appendNode(tagNode);\n\n            //TODO move this to visit, handle whitespaces after Parent close tag.\n            const firstLine = tagNode.location.line;\n            const firstBlock = tagNode.children.find(c => c.type === BLOCK);\n            if (firstBlock && firstBlock.location.line === firstLine) {\n              for (let i = 0; i < firstBlock.children.length; i++) {\n                const blockNode = firstBlock.children[i];\n                if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n                  blockNode.text = '';\n                } else {\n                  break;\n                }\n              }\n            }\n\n            handled = true;\n          }\n        }\n        break;\n\n      case TokenType.EOF:\n        if (this.top > 0) {\n          parserContext.throw('Unexpected EOF: tags not closed: ' + \n            this.stack.map(f => f.name).join(', '));\n        }\n        break;\n    }\n    return handled;\n  }\n\n  handleNode(node, rendererContext) {\n    switch (node.type) {\n      case PARENT:\n        this._handleParent(node, rendererContext);\n        return true;\n\n      case BLOCK:\n        this._handleBlock(node, rendererContext);\n        return true;\n\n      case LEAVE_SCOPE:\n        this._blocks = null;\n        return true;\n    }\n  }\n\n  _handleParent(node, rendererContext) {\n    const { name, location } = node;\n\n    if (this._blocks === null) {\n      rendererContext.pushNodes([\n        {\n          type: LEAVE_SCOPE\n        }\n      ]);\n      this._blocks = {};\n    }\n\n    //find all blocks defined in parent\n    node.children.forEach(child => {\n      if (child.type === BLOCK) {\n        const blockName = child.name;\n        if (!this._blocks.hasOwnProperty(blockName)) {\n          this._blocks[blockName] = child;\n        }\n      }\n    });\n\n    rendererContext.pushNode({\n      type: TokenType.PARTIAL,\n      name, location,\n      indent: node.indent,\n    });\n  }\n\n  _handleBlock(node, rendererContext) {\n    const { name } = node;\n    if (this._blocks !== null && this._blocks.hasOwnProperty(name)) {\n      rendererContext.pushNodes(this._blocks[name].children);\n    } else {\n      rendererContext.pushNodes(node.children);\n    }\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/extensions/inheritance.js\n **/","import * as nodeTypes from './node';\nimport escapeHTML from 'escape-html';\nimport { Parser } from './parser';\nimport { walk, visit } from './helpers';\nimport { instantiateAll } from './extension';\n\nconst REPEATER_NODE_TYPE  = '_REPEATER';\nconst MAX_PARTIAL_STACK = 10;\nconst MAX_LAMBDA_STACK = 255;\n\nclass RenderContext {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n\n  get top() {\n    return this._renderer._stack.length;\n  }\n\n  evaluate(name) {\n    return this._renderer._evaluate(name);\n  }\n\n  pushNodes(nodes) {\n    this._renderer._pushNodes(nodes);\n  }\n\n  pushNode(node) {\n    this._renderer._pushNode(node);\n  }\n\n  pushContext(ctx) {\n    this._renderer._pushContext(ctx);\n  }\n\n  parse(src, opts) {\n    return this._renderer._parse(src, opts);\n  }\n\n  getParsedPartial(name) {\n    return this._renderer._getParsedPartial(name);\n  }\n\n  throw(message, location) {\n    return this._renderer._throw(message, location);\n  }\n}\n\nexport class Renderer {\n  constructor(src, opts = {}) {\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    \n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(k => {\n        this._partialCached[k] = this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n  }\n\n  render(context) {\n    this._stack = [];\n    this._contextStack = [];\n    this._partialStack = [];\n    this._lambdaStack = [];\n\n    this._pushContext(context);\n\n    //push root nodes\n    const rootNode = this._parsed ? this._src : this._parse(this._src);\n    this._stack = rootNode.children.slice(0).reverse();\n\n    let out = '';\n    let newline = true;\n    while (this._stack.length > 0) {\n      const top = this._stack.length - 1;\n      const node = this._stack[top];\n\n      let handled = false;\n      if (this._extensions) {\n        this._extensions.forEach(ext => {\n          if (ext.handleNode(node, this._renderContext)) {\n            handled = true;\n          }\n        });\n      }\n\n      if (handled) {\n        this._stack.splice(top, 1);\n      } else {\n        const partial = this._partialStack.length ? this._partialStack[this._partialStack.length - 1] : null;\n\n        //insert indent\n        if (node.type in nodeTypes) {\n          if (newline && partial !== null && partial.indent.length > 0) {\n            out += partial.indent;\n          }\n        }\n\n        let value;\n        switch (node.type) {\n          case nodeTypes.VARIABLE:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              if (!!value) {\n                out += node.unescaped ? value : escapeHTML(value);\n              }\n              this._popNode();\n            }\n            break;\n\n          case nodeTypes.SECTION:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              let isList = Array.isArray(value);\n\n              if (isList && value.length === 0) {\n                //Empty lists should behave like falsey values.\n                value = false;\n                isList = false;\n              }\n\n              let testResult = !!value;\n              if (node.inverted) {\n                testResult = !testResult;\n              }\n\n              if (testResult) {\n                if (isList) {\n                  this._popNode();\n                  this._pushRepeaterNode(value.length, node.children, value);\n                } else {\n                  this._popNode()\n                  this._pushContext(value);\n                  this._pushNodes(node.children);\n                }\n              } else {\n                this._popNode();\n              }\n            }\n            break;\n\n          case nodeTypes.TEXT:\n            out += node.text;\n            this._popNode()\n            break;\n\n          case nodeTypes.COMMENT:\n            this._popNode();\n            break;\n\n          case nodeTypes.PARTIAL:\n            this._popNode();\n            this._expandPartial(node);\n            break;\n\n          case nodeTypes.DELIMITER_CHANGE:\n            this._popNode();\n            this._delimiters = node.delimiters.slice(0);\n            break;\n\n          case REPEATER_NODE_TYPE:\n            if (node.count < node.repeat) {\n              const repeatIndex = node.count;\n              if (repeatIndex === 0) {\n                node.contextIndex = this._pushContext(node.contexts[0]);\n              } else {\n                this._replaceContextAt(node.contextIndex, node.contexts[repeatIndex]);\n              }\n              this._pushNodes(node.children);\n              node.count ++;\n            } else {\n              this._popNode();\n            }\n            break;\n\n          default:\n            this._popNode();\n            break;\n        }\n      }\n      this._checkStacks();\n      newline = out.length === 0 || (out[out.length -1 ] === '\\n');\n    }\n    return out;\n  }\n\n  _parse(src, opts = {}) {\n    opts.extensions = this._extensions;\n    const parser = new Parser(opts);\n    return parser.parse(src);\n  }\n\n  _pushNodes(list) {\n    for (let i = list.length - 1; i >= 0; i --) {\n      this._stack.push(list[i]);\n    }\n  }\n\n  _pushNode(node) {\n    this._stack.push(node);\n  }\n\n  _popNode() {\n    this._stack.pop();\n  }\n\n  _pushRepeaterNode(repeat, nodes, contexts) {\n    this._stack.push({\n      type: REPEATER_NODE_TYPE,\n      count: 0,\n      repeat,\n      children: nodes.slice(0),\n      contexts\n    });\n  }\n\n  _pushContext(context) {\n    return this._contextStack.push({\n      context,\n      sp: this._stack.length\n    }) - 1;\n  }\n\n  _replaceContextAt(index, context) {\n    if (index < 0 || index > this._contextStack.length - 1) {\n      throw new RangeError('Huz context index out of range.');\n    }\n    this._contextStack[index].context = context;\n  }\n\n  _pushPartial({ name, indent, location }) {\n    this._partialStack.push({\n      name,\n      indent: indent || '',\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _pushLambda({ name, location }) {\n    this._lambdaStack.push({\n      name,\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _checkStacks() {\n    if (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n      this._contextStack.pop();\n    }\n\n    if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n      this._partialStack.pop();\n    }\n\n    if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n      this._lambdaStack.pop();\n    }\n  }\n\n  _evaluate(name) {\n    if (name === '.') {\n      return this._contextStack[this._contextStack.length - 1].context;\n    }\n\n    const path = name.split('.');\n    for (let i = this._contextStack.length - 1; i >= 0; i--) {\n      const context = this._contextStack[i].context;\n      if (context === null || typeof context !== 'object') {\n        continue;\n      }\n\n      let current = context;\n      let resolved = true;\n      for (let pi = 0; pi < path.length; pi++) {\n        const key = path[pi];\n        if (typeof current === 'object' && current !== null && current.hasOwnProperty(key)) {\n          current = current[key];\n        } else {\n          resolved = false;\n          break;\n        }\n      }\n\n      if (resolved) {\n        return current;\n      }\n    }\n    return '';\n  }\n\n  _getParsedPartial(name) {\n    if (this._partialCached.hasOwnProperty(name)) {\n      return this._partialCached[name];\n    } else {\n      if (!this._partials.hasOwnProperty(name)) {\n        return null;\n      }\n      const ast = this._parse(this._partials[name], { filename: name });\n      const nodes = this._partialCached[name] = ast.children;\n      return nodes;\n    }\n  }\n\n  _expandPartial(node) {\n    const { name } = node;\n    const nodes = this._getParsedPartial(name);\n\n    if (nodes === null) {\n      //The empty string should be used when the named partial is not found.\n      return;\n    }\n\n    this._pushPartial(node);\n\n    if (this._partialStack.length > MAX_PARTIAL_STACK) {\n      this._throw(\n        'Possible partial short circuit: ' +\n          this._partialStack.map(f => `${f.name}@${f.location.filename}:${f.location.line+1}`).concat([name]).join(' -> '),\n        node.location\n      );\n    }\n\n    this._pushNodes(nodes);\n  }\n\n  _expandLambda(node, lambda) {\n    const { name } = node;\n\n    this._pushLambda(node);\n\n    if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n      this._throw(\n        'Possible lambda short circuit: ' +\n          this._lambdaStack.map(f => `${f.name}@${f.location.filename}:${f.location.line+1}`).concat([name]).join(' -> '),\n        node.location\n      );\n    }\n\n    let ast;\n    let skipped = false;\n    if (node.type === nodeTypes.VARIABLE) {\n      const code = lambda();\n      if (code) {\n        //A lambda's return value should parse with the default delimiters.\n        ast = this._parse('' + code, { filename: '[lambda]' });\n        if (!node.unescaped) {\n          //Lambda results should be appropriately escaped.\n          walk(ast, node => {\n            if (node.type === nodeTypes.TEXT) {\n              node.text = escapeHTML(node.text);\n            }\n          });\n        }\n      } else {\n        skipped = true;\n      }\n    } else if (node.type === nodeTypes.SECTION) {\n      const code = lambda(node.raw);\n      if (code) {\n        //Lambdas used for inverted sections should be considered truthy.\n        //Lambdas used for sections should parse with the current delimiters.\n        ast = this._parse('' + code, {\n          filename: '[#lambda]',\n          delimiters: this._delimiters.slice(0)\n        });\n      } else {\n        skipped = true;\n      }\n    }\n\n    if (!skipped) {\n      this._pushNodes(ast.children);\n    }\n  }\n\n  _throw(message, location) {\n    const e = new Error(message);\n    e.location = location;\n    throw e;\n  }\n}\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == '[object Function]';\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/renderer.js\n **/","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escape-html/index.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}