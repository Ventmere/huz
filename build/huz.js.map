{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///huz.js","webpack:///webpack/bootstrap 0ef94e3274bc90421735","webpack:///./src/index.js","webpack:///./src/extension.js","webpack:///./src/token.js","webpack:///./src/helpers.js","webpack:///./src/node.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js","webpack:///./src/extensions/inheritance.js","webpack:///./src/renderer.js","webpack:///./~/escape-html/index.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","parse","src","opts","parser","_parser","Parser","compile","_renderer","Renderer","render","context","r","defineProperty","value","_token","TokenType","_node","NodeType","_extension","_extensionsInheritance","_tokenizer","enumerable","get","Tokenizer","register","Inheritance","_classCallCheck","instance","Constructor","TypeError","instantiateAll","registry","map","ctor","constructor","push","_createClass","defineProperties","target","props","length","descriptor","configurable","writable","protoProps","staticProps","Extension","token","parserContext","node","renderContext","EOF","TEXT","PARTIAL","INVERTED_SECTION_OPEN","SECTION_OPEN","SECTION_CLOSE","UNESCAPED_VARIABLE","COMMENT","VARIABLE","DELIMITER_CHANGE","walk","modifier","stack","children","slice","reverse","pop","undefined","concat","visit","visitor","_parent","child","modified","trimStandaloneToken","tokens","count","open","inline","standalone","indentTokens","type","isStringWhitespace","text","name","tailWSNodeCount","indent","forEach","t","str","test","ROOT","SECTION","ParserContext","_appendNode","_pushParent","_popParent","message","_throw","_stack","arguments","_delimiters","delimiters","_extensions","extensions","_filename","filename","_parserContext","_lastToken","_src","rootNode","_parseNodes","JSON","stringify","beginLocation","endLocation","location","_clone","endIndex","endLine","initialStackSize","z","getNextToken","error","handled","ext","handleToken","_makeLocation","unescaped","_handleSectionOpen","_handleSectionClose","_handleComment","n","join","e","Error","inverted","section","raw","index","content","extractNewDelimiters","tagContent","matches","match","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","Array","isArray","_helpers","STATE_NONE","STATE_EOF","STATE_TEXT","STATE_TEXT_BREAK","STATE_TAG","DELIMITER_LEFT","DELIMITER_RIGHT","_index","_char","_tokens","_line","_column","_state","_error","_location","line","column","shift","matched","_markTokenStartLocation","_read","_handleEOF","_handleText","_handleTextBreak","_handleTag","_markTokenEndLocation","_isDelimiter","_handleStandaloneTag","_makeToken","left","right","_skip","_skipAllWhitespaces","_setError","_handleEmptyTag","tagTypeChar","_handleVariableCurly","tagContentStart","_handleSimpleTag","substr","_handleDelimiterChange","_handleVariable","newDelimiters","_newDelimiters","trim","begin","d","_distance","console","log","_isWhitespace","endColumn","offset","delimiter","pos","transformToken","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","isInheritanceTagType","PARENT","BLOCK","_get","_x","_x2","_x3","_again","object","property","receiver","desc","parent","getter","Function","getOwnPropertyDescriptor","getPrototypeOf","_token2","LEAVE_SCOPE","_Extension","_blocks","pushParent","tagNode","tailNode","popParent","appendNode","firstLine","firstBlock","find","blockNode","top","f","rendererContext","_handleParent","_handleBlock","_this","pushNodes","blockName","_interopRequireDefault","default","isFunction","x","toString","nodeTypes","_escapeHtml","_escapeHtml2","REPEATER_NODE_TYPE","MAX_PARTIAL_STACK","MAX_LAMBDA_STACK","RenderContext","renderer","_evaluate","nodes","_pushNodes","ctx","_pushContext","_parse","_getParsedPartial","_partials","partials","_renderContext","_partialCached","_contextStack","_partialStack","_lambdaStack","out","newline","_loop","partial","_popNode","_expandLambda","isList","testResult","_pushRepeaterNode","_expandPartial","repeat","repeatIndex","contexts","_replaceTopContext","handleNode","_checkStacks","list","sp","_ref","_ref2","path","split","current","resolved","pi","ast","_pushPartial","lambda","_pushLambda","skipped","code","escapeHtml","string","matchHtmlRegExp","exec","escape","html","lastIndex","charCodeAt","substring"],"mappings":"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","file":"huz.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.parse = parse;\n\texports.compile = compile;\n\texports.render = render;\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tvar _parser = __webpack_require__(5);\n\t\n\tvar _renderer = __webpack_require__(8);\n\t\n\tvar _token = __webpack_require__(2);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _extensionsInheritance = __webpack_require__(7);\n\t\n\tvar _tokenizer = __webpack_require__(6);\n\t\n\tObject.defineProperty(exports, 'Tokenizer', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _tokenizer.Tokenizer;\n\t  }\n\t});\n\texports.Parser = _parser.Parser;\n\texports.Renderer = _renderer.Renderer;\n\texports.TokenType = TokenType;\n\texports.NodeType = NodeType;\n\t\n\t(0, _extension.register)(_extensionsInheritance.Inheritance);\n\t\n\tfunction parse(src, opts) {\n\t  var parser = new _parser.Parser(opts);\n\t  return parser.parse(src);\n\t}\n\t\n\tfunction compile(src, opts) {\n\t  return new _renderer.Renderer(src, opts);\n\t}\n\t\n\tfunction render(src, context, opts) {\n\t  var r = compile(src, opts);\n\t  return r.render(context);\n\t}\n\t\n\texports.register = _extension.register;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\texports.instantiateAll = instantiateAll;\n\texports.register = register;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar registry = [];\n\t\n\tvar Extension = (function () {\n\t  function Extension() {\n\t    _classCallCheck(this, Extension);\n\t  }\n\t\n\t  _createClass(Extension, [{\n\t    key: \"transformToken\",\n\t\n\t    //called by tokenizer\n\t    value: function transformToken(token) {\n\t      return token;\n\t    }\n\t\n\t    //called by parser\n\t  }, {\n\t    key: \"handleToken\",\n\t    value: function handleToken(token, parserContext) {}\n\t  }, {\n\t    key: \"visit\",\n\t    value: function visit(root) {\n\t      return root;\n\t    }\n\t\n\t    //called by renderer\n\t  }, {\n\t    key: \"handleNode\",\n\t    value: function handleNode(node, renderContext) {}\n\t  }]);\n\t\n\t  return Extension;\n\t})();\n\t\n\texports.Extension = Extension;\n\t\n\tfunction instantiateAll() {\n\t  return registry.map(function (ctor) {\n\t    return new ctor();\n\t  });\n\t}\n\t\n\tfunction register(constructor) {\n\t  return registry.push(constructor);\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar EOF = 'EOF';\n\texports.EOF = EOF;\n\tvar TEXT = 'TEXT';\n\texports.TEXT = TEXT;\n\tvar PARTIAL = 'PARTIAL';\n\texports.PARTIAL = PARTIAL;\n\tvar INVERTED_SECTION_OPEN = 'INVERTED_SECTION_OPEN';\n\texports.INVERTED_SECTION_OPEN = INVERTED_SECTION_OPEN;\n\tvar SECTION_OPEN = 'SECTION_OPEN';\n\texports.SECTION_OPEN = SECTION_OPEN;\n\tvar SECTION_CLOSE = 'SECTION_CLOSE';\n\texports.SECTION_CLOSE = SECTION_CLOSE;\n\tvar UNESCAPED_VARIABLE = 'UNESCAPED_VARIABLE';\n\texports.UNESCAPED_VARIABLE = UNESCAPED_VARIABLE;\n\tvar COMMENT = 'COMMENT';\n\texports.COMMENT = COMMENT;\n\tvar VARIABLE = 'VARIABLE';\n\texports.VARIABLE = VARIABLE;\n\tvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\texports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.walk = walk;\n\texports.visit = visit;\n\texports.trimStandaloneToken = trimStandaloneToken;\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tvar _token = __webpack_require__(2);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tfunction walk(root, modifier) {\n\t  var stack = root.children.slice(0).reverse();\n\t  while (stack.length) {\n\t    var node = stack.pop();\n\t    modifier(node);\n\t    if (node.children !== undefined) {\n\t      stack = stack.concat(node.children.slice(0).reverse());\n\t    }\n\t  }\n\t}\n\t\n\tfunction visit(root, visitor) {\n\t  var stack = [root];\n\t  while (stack.length) {\n\t    var _parent = stack.pop();\n\t    for (var i = 0; i < _parent.children.length; i++) {\n\t      var child = _parent.children[i];\n\t      var modified = visitor.visit(child) || child;\n\t      if (modified !== child) {\n\t        _parent.children[i] = modified;\n\t      }\n\t      if (child.children && child.children.length) {\n\t        stack.push(child);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction trimStandaloneToken(tokens) {\n\t  var count = tokens.length;\n\t\n\t  if (count === 0) {\n\t    return tokens;\n\t  }\n\t\n\t  var open = null;\n\t  var inline = 0;\n\t  var standalone = true;\n\t  var indentTokens = [];\n\t  for (var i = 0; standalone && i < count; i++) {\n\t    var token = tokens[i];\n\t    switch (token.type) {\n\t      case TokenType.VARIABLE:\n\t      case TokenType.UNESCAPED_VARIABLE:\n\t        standalone = false;\n\t        break;\n\t      case TokenType.TEXT:\n\t        if (isStringWhitespace(token.text)) {\n\t          if (inline === 0) {\n\t            indentTokens.push(token);\n\t          }\n\t        } else {\n\t          standalone = false;\n\t        }\n\t        break;\n\t      case TokenType.DELIMITER_CHANGE:\n\t      case TokenType.COMMENT:\n\t        if (open !== null) {\n\t          open.push(token);\n\t        } else {\n\t          inline++;\n\t        }\n\t        break;\n\t      case TokenType.SECTION_CLOSE:\n\t        if (open) {\n\t          if (open[0].name === token.name) {\n\t            open = null;\n\t          } else {\n\t            standalone = false;\n\t          }\n\t        } else {\n\t          inline++;\n\t        }\n\t        break;\n\t      default:\n\t        //section-like tags\n\t        if (open === null) {\n\t          open = [token];\n\t          inline++;\n\t        } else {\n\t          standalone = false;\n\t        }\n\t        break;\n\t    }\n\t\n\t    if (inline > 1) {\n\t      standalone = false;\n\t    }\n\t  }\n\t\n\t  if (open && open.length > 1) {\n\t    standalone = false;\n\t  }\n\t\n\t  if (standalone) {\n\t    //all whitespace\n\t    if (indentTokens.length === count) {\n\t      return tokens;\n\t    }\n\t\n\t    var tailWSNodeCount = 0;\n\t    for (var i = count - 1; i >= 0; i--) {\n\t      var token = tokens[i];\n\t      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n\t        tailWSNodeCount++;\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n\t      //trim\n\t      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n\t      if (indentTokens.length) {\n\t        var indent = '';\n\t        indentTokens.forEach(function (t) {\n\t          indent += t.text;\n\t        });\n\t        tokens[0].indent = indent;\n\t      }\n\t    }\n\t  }\n\t  return tokens;\n\t}\n\t\n\tfunction isStringWhitespace(str) {\n\t  return (/^\\s*$/.test(str)\n\t  );\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar ROOT = 'ROOT';\n\texports.ROOT = ROOT;\n\tvar VARIABLE = 'VARIABLE';\n\texports.VARIABLE = VARIABLE;\n\tvar SECTION = 'SECTION';\n\texports.SECTION = SECTION;\n\tvar TEXT = 'TEXT';\n\texports.TEXT = TEXT;\n\tvar COMMENT = 'COMMENT';\n\texports.COMMENT = COMMENT;\n\tvar PARTIAL = 'PARTIAL';\n\texports.PARTIAL = PARTIAL;\n\tvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\texports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _token = __webpack_require__(2);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _tokenizer = __webpack_require__(6);\n\t\n\tvar _helpers = __webpack_require__(3);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar ParserContext = (function () {\n\t  function ParserContext(parser) {\n\t    _classCallCheck(this, ParserContext);\n\t\n\t    this._parser = parser;\n\t  }\n\t\n\t  _createClass(ParserContext, [{\n\t    key: 'appendNode',\n\t    value: function appendNode(node) {\n\t      this._parser._appendNode(node);\n\t    }\n\t  }, {\n\t    key: 'pushParent',\n\t    value: function pushParent(node) {\n\t      this._parser._pushParent(node);\n\t    }\n\t  }, {\n\t    key: 'popParent',\n\t    value: function popParent() {\n\t      return this._parser._popParent();\n\t    }\n\t  }, {\n\t    key: 'throw',\n\t    value: function _throw(message) {\n\t      return this._parser._throw(message);\n\t    }\n\t  }, {\n\t    key: 'top',\n\t    get: function get() {\n\t      return this._parser._stack.length;\n\t    }\n\t  }, {\n\t    key: 'tailNode',\n\t    get: function get() {\n\t      return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n\t    }\n\t  }]);\n\t\n\t  return ParserContext;\n\t})();\n\t\n\tvar Parser = (function () {\n\t  function Parser() {\n\t    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t    _classCallCheck(this, Parser);\n\t\n\t    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n\t    this._filename = opts.filename || '';\n\t\n\t    if (this._extensions.length > 0) {\n\t      this._parserContext = new ParserContext(this);\n\t    }\n\t\n\t    this._stack = null;\n\t    this._lastToken = null;\n\t    this._src = null;\n\t  }\n\t\n\t  _createClass(Parser, [{\n\t    key: 'parse',\n\t    value: function parse(src) {\n\t      var rootNode = {\n\t        type: NodeType.ROOT,\n\t        children: []\n\t      };\n\t      this._src = src;\n\t      this._stack = [rootNode];\n\t      this._lastToken = null;\n\t      this._parseNodes(src);\n\t\n\t      if (this._extensions.length > 0) {\n\t        for (var i = 0; i < this._extensions.length; i++) {\n\t          this._extensions[i].visit(rootNode);\n\t        }\n\t      }\n\t\n\t      return rootNode;\n\t    }\n\t  }, {\n\t    key: '_appendNode',\n\t    value: function _appendNode(node) {\n\t      this._stack[this._stack.length - 1].children.push(node);\n\t      return node;\n\t    }\n\t  }, {\n\t    key: '_getTop',\n\t    value: function _getTop() {\n\t      return this._stack[this._stack.length - 1];\n\t    }\n\t  }, {\n\t    key: '_clone',\n\t    value: function _clone(obj) {\n\t      return JSON.parse(JSON.stringify(obj));\n\t    }\n\t  }, {\n\t    key: '_makeLocation',\n\t    value: function _makeLocation(beginLocation, endLocation) {\n\t      var location = this._clone(beginLocation);\n\t      location.filename = this._filename;\n\t      if (endLocation) {\n\t        location.endIndex = endLocation.endIndex;\n\t        location.endLine = endLocation.endLine;\n\t      }\n\t      return location;\n\t    }\n\t  }, {\n\t    key: '_parseNodes',\n\t    value: function _parseNodes(src) {\n\t      var initialStackSize = this._stack.length;\n\t      var token = undefined;\n\t      var z = new _tokenizer.Tokenizer(src, {\n\t        delimiters: this._delimiters.slice(0),\n\t        extensions: this._extensions\n\t      });\n\t\n\t      do {\n\t        token = z.getNextToken();\n\t\n\t        if (z.error !== null) {\n\t          throw z.error;\n\t        }\n\t\n\t        this._lastToken = token;\n\t\n\t        var handled = false;\n\t        if (this._extensions) {\n\t          for (var i = 0; i < this._extensions.length; i++) {\n\t            var ext = this._extensions[i];\n\t            if (ext.handleToken(token, this._parserContext) === true) {\n\t              handled = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (!handled) {\n\t          switch (token.type) {\n\t            case TokenType.TEXT:\n\t              this._appendNode({\n\t                type: NodeType.TEXT,\n\t                text: token.text,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.VARIABLE:\n\t            case TokenType.UNESCAPED_VARIABLE:\n\t              this._appendNode({\n\t                type: NodeType.VARIABLE,\n\t                name: token.name,\n\t                unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.SECTION_OPEN:\n\t              this._handleSectionOpen(token);\n\t              break;\n\t\n\t            case TokenType.INVERTED_SECTION_OPEN:\n\t              this._handleSectionOpen(token, true);\n\t              break;\n\t\n\t            case TokenType.SECTION_CLOSE:\n\t              this._handleSectionClose(token);\n\t              break;\n\t\n\t            case TokenType.PARTIAL:\n\t              this._appendNode({\n\t                type: NodeType.PARTIAL,\n\t                name: token.name,\n\t                indent: token.indent,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.COMMENT:\n\t              this._handleComment(token);\n\t              break;\n\t\n\t            case TokenType.DELIMITER_CHANGE:\n\t              this._appendNode({\n\t                type: NodeType.DELIMITER_CHANGE,\n\t                delimiters: token.delimiters,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t          }\n\t        }\n\t      } while (token.type !== TokenType.EOF);\n\t\n\t      if (this._stack.length > initialStackSize) {\n\t        this._throw('Unexpected EOF: sections not closed: ' + this._stack.slice(initialStackSize).map(function (n) {\n\t          return '\\'' + n.name + '\\'';\n\t        }).join(', '));\n\t      } else if (this._stack.length < initialStackSize) {\n\t        this._throw('Internal error.');\n\t      }\n\t    }\n\t  }, {\n\t    key: '_throw',\n\t    value: function _throw(message) {\n\t      var e = new Error(message);\n\t      e.location = this._lastToken.location;\n\t      throw e;\n\t    }\n\t  }, {\n\t    key: '_pushParent',\n\t    value: function _pushParent(node) {\n\t      node.children = [];\n\t      this._stack.push(node);\n\t    }\n\t  }, {\n\t    key: '_popParent',\n\t    value: function _popParent() {\n\t      return this._stack.pop();\n\t    }\n\t  }, {\n\t    key: '_handleSectionOpen',\n\t    value: function _handleSectionOpen(token) {\n\t      var inverted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t      var name = token.name;\n\t      var location = token.location;\n\t\n\t      this._pushParent({\n\t        type: NodeType.SECTION,\n\t        name: name,\n\t        inverted: inverted,\n\t        location: location\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleSectionClose',\n\t    value: function _handleSectionClose(token) {\n\t      var name = token.name;\n\t      var location = token.location;\n\t\n\t      var section = this._popParent();\n\t      if (section.type !== NodeType.SECTION) {\n\t        this._throw('Unexpected SECTION_CLOSE: \\'' + name + '\\'');\n\t      }\n\t\n\t      if (section.name !== name) {\n\t        this._throw('Unexpected SECTION_CLOSE: \\'' + name + '\\', current section: \\'' + section.name + '\\'');\n\t      }\n\t\n\t      section.raw = this._src.slice(section.location.endIndex, location.index);\n\t      section.location = this._makeLocation(section.location, token.location);\n\t\n\t      this._appendNode(section);\n\t    }\n\t  }, {\n\t    key: '_handleComment',\n\t    value: function _handleComment(token) {\n\t      var content = token.content;\n\t      var location = token.location;\n\t\n\t      this._appendNode({\n\t        type: NodeType.COMMENT,\n\t        content: content,\n\t        location: this._makeLocation(location)\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Parser;\n\t})();\n\n\texports.Parser = Parser;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _token = __webpack_require__(2);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _helpers = __webpack_require__(3);\n\t\n\tvar STATE_NONE = 'STATE_NONE';\n\tvar STATE_EOF = 'STATE_EOF';\n\tvar STATE_TEXT = 'STATE_TEXT';\n\tvar STATE_TEXT_BREAK = 'STATE_TEXT_BREAK';\n\tvar STATE_TAG = 'STATE_TAG';\n\t\n\tvar DELIMITER_LEFT = 0;\n\tvar DELIMITER_RIGHT = 1;\n\t\n\tvar Tokenizer = (function () {\n\t  function Tokenizer(src) {\n\t    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Tokenizer);\n\t\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n\t    this._src = src;\n\t    this._index = 0;\n\t    this._char = null;\n\t    this._tokens = [];\n\t    this._line = 0;\n\t    this._column = 0;\n\t    this._state = STATE_NONE;\n\t    this._error = null;\n\t    this._location = {\n\t      index: 0,\n\t      line: 0,\n\t      column: 0\n\t    };\n\t    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n\t  }\n\t\n\t  _createClass(Tokenizer, [{\n\t    key: 'getNextToken',\n\t    value: function getNextToken() {\n\t      if (this._tokens.length > 0) {\n\t        return this._tokens.shift();\n\t      }\n\t\n\t      var done = false;\n\t      var matched = false;\n\t      do {\n\t        //console.log(this._state, this._tokens);\n\t        if (this._error !== null) {\n\t          return null;\n\t        }\n\t\n\t        if (this._state !== STATE_NONE) {\n\t          matched = true;\n\t          this._markTokenStartLocation();\n\t        }\n\t\n\t        switch (this._state) {\n\t          case STATE_NONE:\n\t            this._read();\n\t            break;\n\t\n\t          case STATE_EOF:\n\t            this._handleEOF();\n\t            done = true;\n\t            break;\n\t\n\t          case STATE_TEXT:\n\t            this._handleText();\n\t            break;\n\t\n\t          case STATE_TEXT_BREAK:\n\t            this._handleTextBreak();\n\t            done = true;\n\t            break;\n\t\n\t          case STATE_TAG:\n\t            this._handleTag();\n\t            break;\n\t        }\n\t\n\t        if (matched) {\n\t          this._markTokenEndLocation();\n\t          matched = false;\n\t        }\n\t\n\t        if (this._state === STATE_NONE) {\n\t          if (this._char === null) {\n\t            this._state = STATE_EOF;\n\t          } else if (this._char === '\\n') {\n\t            this._state = STATE_TEXT_BREAK;\n\t          } else if (this._isDelimiter(DELIMITER_LEFT)) {\n\t            this._state = STATE_TAG;\n\t          } else {\n\t            this._state = STATE_TEXT;\n\t          }\n\t        }\n\t      } while (!done);\n\t\n\t      return this._error === null ? this._tokens.shift() : null;\n\t    }\n\t\n\t    // Handlers\n\t\n\t  }, {\n\t    key: '_handleEOF',\n\t    value: function _handleEOF() {\n\t      this._handleStandaloneTag();\n\t      this._makeToken({\n\t        type: TokenType.EOF\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleTag',\n\t    value: function _handleTag() {\n\t      var _delimiters = _slicedToArray(this._delimiters, 2);\n\t\n\t      var left = _delimiters[0];\n\t      var right = _delimiters[1];\n\t\n\t      this._skip(left.length);\n\t      this._skipAllWhitespaces();\n\t\n\t      if (this._char === null) {\n\t        this._setError('Unclosed tag.');\n\t      } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n\t        this._handleEmptyTag();\n\t      } else {\n\t        var tagTypeChar = this._char;\n\t        if (tagTypeChar === '{') {\n\t          this._handleVariableCurly();\n\t        } else {\n\t          var tagContentStart = this._index - 1;\n\t          //read content\n\t          while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n\t            this._read();\n\t          }\n\t\n\t          if (this._char === null) {\n\t            this._setError('Unclosed tag.');\n\t          } else {\n\t            var content = this._src.slice(tagContentStart, this._index - 1);\n\t            switch (tagTypeChar) {\n\t              case '>':\n\t                this._handleSimpleTag(TokenType.PARTIAL, content);break;\n\t              case '^':\n\t                this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);break;\n\t              case '#':\n\t                this._handleSimpleTag(TokenType.SECTION_OPEN, content);break;\n\t              case '/':\n\t                this._handleSimpleTag(TokenType.SECTION_CLOSE, content);break;\n\t\n\t              case '!':\n\t                this._handleComment(content.substr(1));\n\t                break;\n\t\n\t              case '=':\n\t                this._handleDelimiterChange(content);\n\t                break;\n\t              case '&':\n\t                this._handleVariable(content.substr(1), true);\n\t                break;\n\t              default:\n\t                this._handleVariable(content);\n\t                break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      if (this._error === null) {\n\t        //eat right\n\t        for (var i = 0; i < right.length; i++) {\n\t          this._read();\n\t        }\n\t      }\n\t\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleDelimiterChange',\n\t    value: function _handleDelimiterChange(content) {\n\t      var newDelimiters = extractNewDelimiters(content);\n\t      if (newDelimiters === null) {\n\t        this._setError('Invalid change delimiter syntax.');\n\t      } else {\n\t        var _newDelimiters = _slicedToArray(newDelimiters, 2);\n\t\n\t        var left = _newDelimiters[0];\n\t        var right = _newDelimiters[1];\n\t\n\t        this._delimiters = newDelimiters;\n\t        this._makeToken({\n\t          type: TokenType.DELIMITER_CHANGE,\n\t          delimiters: [left, right]\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleSimpleTag',\n\t    value: function _handleSimpleTag(type, content) {\n\t      this._makeToken({ type: type, name: content.substr(1).trim() });\n\t    }\n\t  }, {\n\t    key: '_handleComment',\n\t    value: function _handleComment(content) {\n\t      this._makeToken({\n\t        type: TokenType.COMMENT,\n\t        content: content\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleVariableCurly',\n\t    value: function _handleVariableCurly() {\n\t      this._read(); //eat '{'\n\t      var begin = this._index - 1;\n\t      var d = this._distance('}');\n\t      if (d === -1) {\n\t        this._setError('Unclosed variable tag: missingright curly.');\n\t      } else {\n\t        var content = this._src.slice(begin, begin + d);\n\t        this._skip(d + 1); //skip '}'\n\t        this._skipAllWhitespaces();\n\t        if (!this._isDelimiter(DELIMITER_RIGHT)) {\n\t          this._setError('Unclosed variable: missing right delimiter.');\n\t        } else {\n\t          this._makeToken({\n\t            type: TokenType.UNESCAPED_VARIABLE,\n\t            name: content.trim()\n\t          });\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleEmptyTag',\n\t    value: function _handleEmptyTag() {\n\t      this._makeToken({\n\t        type: TokenType.VARIABLE,\n\t        name: ''\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleVariable',\n\t    value: function _handleVariable(content, unescaped) {\n\t      this._makeToken({\n\t        type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n\t        name: content.trim()\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleText',\n\t    value: function _handleText() {\n\t      var done = false;\n\t      var index = this._index - 1;\n\t      var length = 0;\n\t      do {\n\t        var c = this._char;\n\t\n\t        if (c === null || c === '\\n' || this._isDelimiter(DELIMITER_LEFT)) {\n\t          done = true;\n\t        } else {\n\t          length++;\n\t        }\n\t\n\t        if (!done) {\n\t          this._read();\n\t        }\n\t      } while (!done);\n\t\n\t      this._makeToken({\n\t        type: TokenType.TEXT,\n\t        text: this._src.slice(index, index + length)\n\t      });\n\t\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleTextBreak',\n\t    value: function _handleTextBreak() {\n\t      this._makeToken({\n\t        type: TokenType.TEXT,\n\t        text: '\\n'\n\t      });\n\t      this._read();\n\t      this._handleStandaloneTag();\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleStandaloneTag',\n\t    value: function _handleStandaloneTag() {\n\t      this._tokens = (0, _helpers.trimStandaloneToken)(this._tokens);\n\t    }\n\t\n\t    // Helpers\n\t  }, {\n\t    key: '_dump',\n\t    value: function _dump() {\n\t      var t = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\t\n\t      console.log(t + '>' + this._src.slice(this._index - 1));\n\t    }\n\t  }, {\n\t    key: '_read',\n\t    value: function _read() {\n\t      if (this._index < this._src.length) {\n\t        if (this._char === '\\n') {\n\t          this._line++;\n\t          this._column = 0;\n\t        } else {\n\t          this._column++;\n\t        }\n\t\n\t        this._char = this._src[this._index];\n\t        this._index++;\n\t      } else {\n\t        this._char = null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_peek',\n\t    value: function _peek() {\n\t      if (this._index < this._src.length - 1) {\n\t        return this._src[this._index];\n\t      } else {\n\t        return null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_skip',\n\t    value: function _skip(n) {\n\t      for (var i = 0; i < n; i++) {\n\t        this._read();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_distance',\n\t    value: function _distance(c) {\n\t      for (var i = this._index; i < this._src.length; i++) {\n\t        if (this._src[i] === c) {\n\t          return i - this._index + 1;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t  }, {\n\t    key: '_skipAllWhitespaces',\n\t    value: function _skipAllWhitespaces() {\n\t      while (this._isWhitespace()) {\n\t        this._read();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_markTokenStartLocation',\n\t    value: function _markTokenStartLocation() {\n\t      this._location.index = this._index - 1;\n\t      this._location.line = this._line;\n\t      this._location.column = this._column;\n\t    }\n\t  }, {\n\t    key: '_markTokenEndLocation',\n\t    value: function _markTokenEndLocation() {\n\t      var token = this._tokens[this._tokens.length - 1];\n\t      var _location = this._location;\n\t      var index = _location.index;\n\t      var line = _location.line;\n\t      var column = _location.column;\n\t\n\t      token.location = {\n\t        index: index, line: line, column: column,\n\t        endIndex: this._index - 1,\n\t        endLine: this._line,\n\t        endColumn: this._column\n\t      };\n\t    }\n\t  }, {\n\t    key: '_isWhitespace',\n\t    value: function _isWhitespace() {\n\t      return (/\\s/.test(this._char)\n\t      );\n\t    }\n\t  }, {\n\t    key: '_isDelimiter',\n\t    value: function _isDelimiter(d) {\n\t      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\t\n\t      var delimiter = this._delimiters[d];\n\t      var pos = this._index - 1 + offset;\n\t      return this._src.slice(pos, pos + delimiter.length) === delimiter;\n\t    }\n\t  }, {\n\t    key: '_makeToken',\n\t    value: function _makeToken(token) {\n\t      if (this._extensions.length) {\n\t        try {\n\t          this._extensions.forEach(function (ext) {\n\t            token = ext.transformToken(token);\n\t          });\n\t        } catch (e) {\n\t          this._setError(e.message);\n\t          return;\n\t        }\n\t      }\n\t      this._tokens.push(token);\n\t    }\n\t  }, {\n\t    key: '_setError',\n\t    value: function _setError(message) {\n\t      var error = new Error(message);\n\t      error.index = this._index - 1;\n\t      error.line = this._line;\n\t      error.column = this._column;\n\t      this._error = error;\n\t    }\n\t  }, {\n\t    key: 'error',\n\t    get: function get() {\n\t      return this._error;\n\t    }\n\t  }]);\n\t\n\t  return Tokenizer;\n\t})();\n\t\n\texports.Tokenizer = Tokenizer;\n\t\n\tfunction extractNewDelimiters(tagContent) {\n\t  var matches = tagContent.match(/=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/);\n\t  if (matches) {\n\t    return matches.slice(1);\n\t  } else {\n\t    return null;\n\t  }\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://github.com/mustache/spec/pull/75\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _token2 = __webpack_require__(2);\n\t\n\tvar TokenType = _interopRequireWildcard(_token2);\n\t\n\tvar _helpers = __webpack_require__(3);\n\t\n\tvar PARENT = 'Inheritance.PARENT';\n\tvar BLOCK = 'Inheritance.BLOCK';\n\tvar LEAVE_SCOPE = 'Inheritance.LEAVE_SCOPE';\n\t\n\tfunction isInheritanceTagType(type) {\n\t  return type === PARENT || type === BLOCK;\n\t}\n\t\n\tvar Inheritance = (function (_Extension) {\n\t  _inherits(Inheritance, _Extension);\n\t\n\t  function Inheritance() {\n\t    _classCallCheck(this, Inheritance);\n\t\n\t    _get(Object.getPrototypeOf(Inheritance.prototype), 'constructor', this).call(this);\n\t\n\t    this._blocks = null;\n\t  }\n\t\n\t  _createClass(Inheritance, [{\n\t    key: 'transformToken',\n\t    value: function transformToken(token) {\n\t      var _token = token;\n\t      var type = _token.type;\n\t      var name = _token.name;\n\t      var location = _token.location;\n\t\n\t      switch (type) {\n\t        case TokenType.VARIABLE:\n\t          if (name) {\n\t            if (name[0] === '<') {\n\t              if (name.length === 1) {\n\t                throw new Error('Parent partial name expected');\n\t              }\n\t              token = {\n\t                type: PARENT,\n\t                name: name.slice(1),\n\t                location: location\n\t              };\n\t            } else if (name[0] === '$') {\n\t              if (name.length === 1) {\n\t                throw new Error('Block name expected');\n\t              }\n\t              token = {\n\t                type: BLOCK,\n\t                name: name.slice(1),\n\t                location: location\n\t              };\n\t            }\n\t          }\n\t          break;\n\t      }\n\t      return token;\n\t    }\n\t  }, {\n\t    key: 'handleToken',\n\t    value: function handleToken(token, parserContext) {\n\t      var handled = false;\n\t      var name = token.name;\n\t      var location = token.location;\n\t      var type = token.type;\n\t\n\t      switch (type) {\n\t        case PARENT:\n\t          parserContext.pushParent({\n\t            type: PARENT,\n\t            name: name,\n\t            location: location\n\t          });\n\t          handled = true;\n\t          break;\n\t\n\t        case BLOCK:\n\t          parserContext.pushParent({\n\t            type: BLOCK,\n\t            name: name,\n\t            location: location\n\t          });\n\t          break;\n\t\n\t        case TokenType.SECTION_CLOSE:\n\t          var tagNode = parserContext.tailNode;\n\t          if (tagNode === null) {\n\t            if (isInheritanceTagType(tagNode.type)) {\n\t              parserContext['throw']('Unexpected tag close');\n\t            }\n\t          } else {\n\t            if (tagNode.name !== name) {\n\t              parserContext['throw']('Unexpected tag close, current tag: ' + tagNode.name);\n\t            }\n\t            if (isInheritanceTagType(tagNode.type)) {\n\t              parserContext.popParent();\n\t              tagNode.location.endIndex = location.endIndex;\n\t              tagNode.location.endLine = location.endLine;\n\t              parserContext.appendNode(tagNode);\n\t\n\t              //TODO move this to visit, handle whitespaces after Parent close tag.\n\t              var firstLine = tagNode.location.line;\n\t              var firstBlock = tagNode.children.find(function (c) {\n\t                return c.type === BLOCK;\n\t              });\n\t              if (firstBlock && firstBlock.location.line === firstLine) {\n\t                for (var i = 0; i < firstBlock.children.length; i++) {\n\t                  var blockNode = firstBlock.children[i];\n\t                  if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n\t                    blockNode.text = '';\n\t                  } else {\n\t                    break;\n\t                  }\n\t                }\n\t              }\n\t\n\t              handled = true;\n\t            }\n\t          }\n\t          break;\n\t\n\t        case TokenType.EOF:\n\t          if (this.top > 0) {\n\t            parserContext['throw']('Unexpected EOF: tags not closed: ' + this.stack.map(function (f) {\n\t              return f.name;\n\t            }).join(', '));\n\t          }\n\t          break;\n\t      }\n\t      return handled;\n\t    }\n\t  }, {\n\t    key: 'handleNode',\n\t    value: function handleNode(node, rendererContext) {\n\t      switch (node.type) {\n\t        case PARENT:\n\t          this._handleParent(node, rendererContext);\n\t          break;\n\t\n\t        case BLOCK:\n\t          this._handleBlock(node, rendererContext);\n\t          break;\n\t\n\t        case LEAVE_SCOPE:\n\t          this._blocks = null;\n\t          break;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleParent',\n\t    value: function _handleParent(node, rendererContext) {\n\t      var _this = this;\n\t\n\t      var name = node.name;\n\t\n\t      if (this._blocks === null) {\n\t        rendererContext.pushNodes([{\n\t          type: LEAVE_SCOPE\n\t        }]);\n\t        this._blocks = {};\n\t      }\n\t\n\t      //find all blocks defined in parent\n\t      node.children.forEach(function (child) {\n\t        if (child.type === BLOCK) {\n\t          var blockName = child.name;\n\t          if (!_this._blocks.hasOwnProperty(blockName)) {\n\t            _this._blocks[blockName] = child;\n\t          }\n\t        }\n\t      });\n\t\n\t      rendererContext.pushNodes([{\n\t        type: TokenType.PARTIAL,\n\t        name: name,\n\t        indent: node.indent\n\t      }]);\n\t    }\n\t  }, {\n\t    key: '_handleBlock',\n\t    value: function _handleBlock(node, rendererContext) {\n\t      var name = node.name;\n\t\n\t      if (this._blocks !== null && this._blocks.hasOwnProperty(name)) {\n\t        rendererContext.pushNodes(this._blocks[name].children);\n\t      } else {\n\t        rendererContext.pushNodes(node.children);\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return Inheritance;\n\t})(_extension.Extension);\n\n\texports.Inheritance = Inheritance;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar nodeTypes = _interopRequireWildcard(_node);\n\t\n\tvar _escapeHtml = __webpack_require__(9);\n\t\n\tvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\t\n\tvar _parser = __webpack_require__(5);\n\t\n\tvar _helpers = __webpack_require__(3);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar REPEATER_NODE_TYPE = '_REPEATER';\n\tvar MAX_PARTIAL_STACK = 10;\n\tvar MAX_LAMBDA_STACK = 255;\n\t\n\tvar RenderContext = (function () {\n\t  function RenderContext(renderer) {\n\t    _classCallCheck(this, RenderContext);\n\t\n\t    this._renderer = renderer;\n\t  }\n\t\n\t  _createClass(RenderContext, [{\n\t    key: 'evaluate',\n\t    value: function evaluate(name) {\n\t      return this._renderer._evaluate(name);\n\t    }\n\t  }, {\n\t    key: 'pushNodes',\n\t    value: function pushNodes(nodes) {\n\t      this._renderer._pushNodes(nodes);\n\t    }\n\t  }, {\n\t    key: 'pushContext',\n\t    value: function pushContext(ctx) {\n\t      this._pushContext(ctx);\n\t    }\n\t  }, {\n\t    key: 'parse',\n\t    value: function parse(src, opts) {\n\t      return this._renderer._parse(src, opts);\n\t    }\n\t  }, {\n\t    key: 'getParsedPartial',\n\t    value: function getParsedPartial(name) {\n\t      return this._renderer._getParsedPartial(name);\n\t    }\n\t  }, {\n\t    key: 'throw',\n\t    value: function _throw(message, location) {\n\t      return this._renderer._throw(message, location);\n\t    }\n\t  }, {\n\t    key: 'top',\n\t    get: function get() {\n\t      return this._renderer._stack.length;\n\t    }\n\t  }]);\n\t\n\t  return RenderContext;\n\t})();\n\t\n\tvar Renderer = (function () {\n\t  function Renderer(src) {\n\t    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Renderer);\n\t\n\t    this._partials = opts.partials || {};\n\t    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n\t    if (this._extensions.length > 0) {\n\t      this._renderContext = new RenderContext(this);\n\t    }\n\t\n\t    this._partialCached = {};\n\t    this._stack = null;\n\t    this._contextStack = null;\n\t    this._partialStack = null;\n\t    this._lambdaStack = null;\n\t    this._src = src;\n\t  }\n\t\n\t  _createClass(Renderer, [{\n\t    key: 'render',\n\t    value: function render(context) {\n\t      var _this = this;\n\t\n\t      this._stack = [];\n\t      this._contextStack = [];\n\t      this._partialStack = [];\n\t      this._lambdaStack = [];\n\t\n\t      this._pushContext(context);\n\t\n\t      //push root nodes\n\t      var rootNode = this._parse(this._src);\n\t      this._stack = rootNode.children.slice(0).reverse();\n\t\n\t      var out = '';\n\t      var newline = true;\n\t\n\t      var _loop = function () {\n\t        var node = _this._stack[_this._stack.length - 1];\n\t        var partial = _this._partialStack.length ? _this._partialStack[_this._partialStack.length - 1] : null;\n\t\n\t        //insert indent\n\t        if (node.type in nodeTypes) {\n\t          if (newline && partial !== null && partial.indent.length > 0) {\n\t            out += partial.indent;\n\t          }\n\t        }\n\t\n\t        var value = undefined;\n\t        switch (node.type) {\n\t          case nodeTypes.VARIABLE:\n\t            value = _this._evaluate(node.name);\n\t            if (isFunction(value)) {\n\t              _this._popNode();\n\t              _this._expandLambda(node, value);\n\t            } else {\n\t              if (!!value) {\n\t                out += node.unescaped ? value : (0, _escapeHtml2['default'])(value);\n\t              }\n\t              _this._popNode();\n\t            }\n\t            break;\n\t\n\t          case nodeTypes.SECTION:\n\t            value = _this._evaluate(node.name);\n\t            if (isFunction(value)) {\n\t              _this._popNode();\n\t              _this._expandLambda(node, value);\n\t            } else {\n\t              var isList = Array.isArray(value);\n\t\n\t              if (isList && value.length === 0) {\n\t                //Empty lists should behave like falsey values.\n\t                value = false;\n\t                isList = false;\n\t              }\n\t\n\t              var testResult = !!value;\n\t              if (node.inverted) {\n\t                testResult = !testResult;\n\t              }\n\t\n\t              if (testResult) {\n\t                if (isList) {\n\t                  _this._popNode();\n\t                  _this._pushRepeaterNode(value.length, node.children, value);\n\t                } else {\n\t                  _this._popNode();\n\t                  _this._pushContext(value);\n\t                  _this._pushNodes(node.children);\n\t                }\n\t              } else {\n\t                _this._popNode();\n\t              }\n\t            }\n\t            break;\n\t\n\t          case nodeTypes.TEXT:\n\t            out += node.text;\n\t            _this._popNode();\n\t            break;\n\t\n\t          case nodeTypes.COMMENT:\n\t            _this._popNode();\n\t            break;\n\t\n\t          case nodeTypes.PARTIAL:\n\t            _this._popNode();\n\t            _this._expandPartial(node);\n\t            break;\n\t\n\t          case nodeTypes.DELIMITER_CHANGE:\n\t            _this._popNode();\n\t            _this._delimiters = node.delimiters.slice(0);\n\t            break;\n\t\n\t          case REPEATER_NODE_TYPE:\n\t            if (node.count < node.repeat) {\n\t              var repeatIndex = node.count;\n\t              if (repeatIndex === 0) {\n\t                _this._pushContext(node.contexts[0]);\n\t              } else {\n\t                _this._replaceTopContext(node.contexts[repeatIndex]);\n\t              }\n\t              _this._pushNodes(node.children);\n\t              node.count++;\n\t            } else {\n\t              _this._popNode();\n\t            }\n\t            break;\n\t\n\t          default:\n\t            _this._popNode();\n\t            if (_this._extensions) {\n\t              _this._extensions.forEach(function (ext) {\n\t                ext.handleNode(node, _this._renderContext);\n\t              });\n\t            }\n\t            break;\n\t        }\n\t\n\t        _this._checkStacks();\n\t        newline = out.length === 0 || out[out.length - 1] === '\\n';\n\t      };\n\t\n\t      while (this._stack.length > 0) {\n\t        _loop();\n\t      }\n\t      return out;\n\t    }\n\t  }, {\n\t    key: '_parse',\n\t    value: function _parse(src) {\n\t      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t      opts.extensions = this._extensions;\n\t      var parser = new _parser.Parser(opts);\n\t      return parser.parse(src);\n\t    }\n\t  }, {\n\t    key: '_pushNodes',\n\t    value: function _pushNodes(list) {\n\t      for (var i = list.length - 1; i >= 0; i--) {\n\t        this._stack.push(list[i]);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_popNode',\n\t    value: function _popNode() {\n\t      this._stack.pop();\n\t    }\n\t  }, {\n\t    key: '_pushRepeaterNode',\n\t    value: function _pushRepeaterNode(repeat, nodes, contexts) {\n\t      this._stack.push({\n\t        type: REPEATER_NODE_TYPE,\n\t        count: 0,\n\t        repeat: repeat,\n\t        children: nodes.slice(0),\n\t        contexts: contexts\n\t      });\n\t    }\n\t  }, {\n\t    key: '_pushContext',\n\t    value: function _pushContext(context) {\n\t      this._contextStack.push({\n\t        context: context,\n\t        sp: this._stack.length\n\t      });\n\t    }\n\t  }, {\n\t    key: '_pushPartial',\n\t    value: function _pushPartial(_ref) {\n\t      var name = _ref.name;\n\t      var indent = _ref.indent;\n\t      var location = _ref.location;\n\t\n\t      this._partialStack.push({\n\t        name: name,\n\t        indent: indent || '',\n\t        location: location,\n\t        sp: this._stack.length\n\t      });\n\t    }\n\t  }, {\n\t    key: '_pushLambda',\n\t    value: function _pushLambda(_ref2) {\n\t      var name = _ref2.name;\n\t      var location = _ref2.location;\n\t\n\t      this._lambdaStack.push({\n\t        name: name,\n\t        location: location,\n\t        sp: this._stack.length\n\t      });\n\t    }\n\t  }, {\n\t    key: '_replaceTopContext',\n\t    value: function _replaceTopContext(context) {\n\t      this._contextStack[this._contextStack.length - 1].context = context;\n\t    }\n\t  }, {\n\t    key: '_checkStacks',\n\t    value: function _checkStacks() {\n\t      //console.log('STACK', this._stack);\n\t\n\t      //console.log('CONTEXT STACK:', this._contextStack);\n\t      if (this._stack.length === this._contextStack[this._contextStack.length - 1].sp) {\n\t        this._contextStack.pop();\n\t      }\n\t\n\t      //console.log('PARTIAL STACK:', this._partialStack);\n\t      if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n\t        this._partialStack.pop();\n\t      }\n\t\n\t      if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n\t        this._lambdaStack.pop();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_evaluate',\n\t    value: function _evaluate(name) {\n\t      if (name === '.') {\n\t        return this._contextStack[this._contextStack.length - 1].context;\n\t      }\n\t\n\t      var path = name.split('.');\n\t      for (var i = this._contextStack.length - 1; i >= 0; i--) {\n\t        var context = this._contextStack[i].context;\n\t        if (context === null || typeof context !== 'object') {\n\t          continue;\n\t        }\n\t\n\t        var current = context;\n\t        var resolved = true;\n\t        for (var pi = 0; pi < path.length; pi++) {\n\t          var key = path[pi];\n\t          if (current.hasOwnProperty(key)) {\n\t            current = current[key];\n\t          } else {\n\t            resolved = false;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (resolved) {\n\t          return current;\n\t        }\n\t      }\n\t      return '';\n\t    }\n\t  }, {\n\t    key: '_getParsedPartial',\n\t    value: function _getParsedPartial(name) {\n\t      if (this._partialCached.hasOwnProperty(name)) {\n\t        return this._partialCached[name];\n\t      } else {\n\t        if (!this._partials.hasOwnProperty(name)) {\n\t          return null;\n\t        }\n\t        var ast = this._parse(this._partials[name], { name: name });\n\t        var nodes = this._partialCached[name] = ast.children;\n\t        return nodes;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_expandPartial',\n\t    value: function _expandPartial(node) {\n\t      var name = node.name;\n\t\n\t      var nodes = this._getParsedPartial(name);\n\t\n\t      if (nodes === null) {\n\t        //The empty string should be used when the named partial is not found.\n\t        return;\n\t      }\n\t\n\t      this._pushPartial(node);\n\t\n\t      if (this._partialStack.length > MAX_PARTIAL_STACK) {\n\t        this._throw('Possible partial short circuit: ' + this._partialStack.map(function (f) {\n\t          return f.name + '@' + f.location.filename + ':' + (f.location.line + 1);\n\t        }).concat([name]).join(' -> '), node.location);\n\t      }\n\t\n\t      this._pushNodes(nodes);\n\t    }\n\t  }, {\n\t    key: '_expandLambda',\n\t    value: function _expandLambda(node, lambda) {\n\t      var name = node.name;\n\t\n\t      this._pushLambda(node);\n\t\n\t      if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n\t        this._throw('Possible lambda short circuit: ' + this._lambdaStack.map(function (f) {\n\t          return f.name + '@' + f.location.filename + ':' + (f.location.line + 1);\n\t        }).concat([name]).join(' -> '), node.location);\n\t      }\n\t\n\t      var ast = undefined;\n\t      var skipped = false;\n\t      if (node.type === nodeTypes.VARIABLE) {\n\t        var code = lambda();\n\t        if (code) {\n\t          //A lambda's return value should parse with the default delimiters.\n\t          ast = this._parse('' + code, { name: '[lambda]' });\n\t          if (!node.unescaped) {\n\t            //Lambda results should be appropriately escaped.\n\t            (0, _helpers.walk)(ast, function (node) {\n\t              if (node.type === nodeTypes.TEXT) {\n\t                node.text = (0, _escapeHtml2['default'])(node.text);\n\t              }\n\t            });\n\t          }\n\t        } else {\n\t          skipped = true;\n\t        }\n\t      } else if (node.type === nodeTypes.SECTION) {\n\t        var code = lambda(node.raw);\n\t        if (code) {\n\t          //Lambdas used for inverted sections should be considered truthy.\n\t          //Lambdas used for sections should parse with the current delimiters.\n\t          ast = this._parse('' + code, {\n\t            name: '[#lambda]',\n\t            delimiters: this._delimiters.slice(0)\n\t          });\n\t        } else {\n\t          skipped = true;\n\t        }\n\t      }\n\t\n\t      if (!skipped) {\n\t        this._pushNodes(ast.children);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_throw',\n\t    value: function _throw(message, location) {\n\t      var e = new Error(message);\n\t      e.location = location;\n\t      throw e;\n\t    }\n\t  }]);\n\t\n\t  return Renderer;\n\t})();\n\t\n\texports.Renderer = Renderer;\n\t\n\tfunction isFunction(x) {\n\t  return Object.prototype.toString.call(x) == '[object Function]';\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * escape-html\n\t * Copyright(c) 2012-2013 TJ Holowaychuk\n\t * Copyright(c) 2015 Andreas Lubbe\n\t * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n\t * MIT Licensed\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Module variables.\n\t * @private\n\t */\n\t\n\tvar matchHtmlRegExp = /[\"'&<>]/;\n\t\n\t/**\n\t * Module exports.\n\t * @public\n\t */\n\t\n\tmodule.exports = escapeHtml;\n\t\n\t/**\n\t * Escape special characters in the given string of html.\n\t *\n\t * @param  {string} string The string to escape for inserting into HTML\n\t * @return {string}\n\t * @public\n\t */\n\t\n\tfunction escapeHtml(string) {\n\t  var str = '' + string;\n\t  var match = matchHtmlRegExp.exec(str);\n\t\n\t  if (!match) {\n\t    return str;\n\t  }\n\t\n\t  var escape;\n\t  var html = '';\n\t  var index = 0;\n\t  var lastIndex = 0;\n\t\n\t  for (index = match.index; index < str.length; index++) {\n\t    switch (str.charCodeAt(index)) {\n\t      case 34: // \"\n\t        escape = '&quot;';\n\t        break;\n\t      case 38: // &\n\t        escape = '&amp;';\n\t        break;\n\t      case 39: // '\n\t        escape = '&#39;';\n\t        break;\n\t      case 60: // <\n\t        escape = '&lt;';\n\t        break;\n\t      case 62: // >\n\t        escape = '&gt;';\n\t        break;\n\t      default:\n\t        continue;\n\t    }\n\t\n\t    if (lastIndex !== index) {\n\t      html += str.substring(lastIndex, index);\n\t    }\n\t\n\t    lastIndex = index + 1;\n\t    html += escape;\n\t  }\n\t\n\t  return lastIndex !== index\n\t    ? html + str.substring(lastIndex, index)\n\t    : html;\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** huz.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0ef94e3274bc90421735\n **/","import { Parser } from './parser';\nimport { Renderer } from './renderer';\nimport * as TokenType from './token';\nimport * as NodeType from './node';\nimport { register } from './extension';\n\nexport { Tokenizer } from './tokenizer';\nexport { Parser, Renderer, TokenType, NodeType };\n\nimport { Inheritance } from './extensions/inheritance';\n\nregister(Inheritance);\n\nexport function parse(src, opts) {\n  const parser = new Parser(opts);\n  return parser.parse(src);\n}\n\nexport function compile(src, opts) {\n  return new Renderer(src, opts);\n}\n\nexport function render(src, context, opts) {\n  const r = compile(src, opts);\n  return r.render(context);\n}\n\nexport { register };\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","const registry = [];\n\nexport class Extension {\n  //called by tokenizer\n  transformToken(token) { return token; }\n\n  //called by parser\n  handleToken(token, parserContext) { }\n  visit(root) { return root; }\n  \n  //called by renderer\n  handleNode(node, renderContext) { }\n}\n\nexport function instantiateAll() {\n  return registry.map(ctor => {\n    return new ctor();\n  });\n}\n\nexport function register(constructor) {\n  return registry.push(constructor);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/extension.js\n **/","export const EOF                    = 'EOF';\nexport const TEXT                   = 'TEXT';\nexport const PARTIAL                = 'PARTIAL';\nexport const INVERTED_SECTION_OPEN  = 'INVERTED_SECTION_OPEN';\nexport const SECTION_OPEN           = 'SECTION_OPEN';\nexport const SECTION_CLOSE          = 'SECTION_CLOSE';\nexport const UNESCAPED_VARIABLE     = 'UNESCAPED_VARIABLE';\nexport const COMMENT                = 'COMMENT';\nexport const VARIABLE               = 'VARIABLE';\nexport const DELIMITER_CHANGE \t\t\t= 'DELIMITER_CHANGE';\n\n\n/** WEBPACK FOOTER **\n ** ./src/token.js\n **/","import * as TokenType from './token';\n\nexport function walk(root, modifier) {\n  let stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    const node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nexport function visit(root, visitor) {\n  let stack = [root];\n  while (stack.length) {\n    const parent = stack.pop();\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      const modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nexport function trimStandaloneToken(tokens) {\n  const count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  let open = null;\n  let inline = 0;\n  let standalone = true;\n  let indentTokens = [];\n  for (let i = 0; standalone && i < count; i++) {\n    const token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline ++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline ++;\n        }\n        break;\n      default: //section-like tags\n        if (open === null) {\n          open = [token];\n          inline ++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n  \n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    let tailWSNodeCount = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount ++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        let indent = '';\n        indentTokens.forEach(t => { indent += t.text });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return /^\\s*$/.test(str);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/helpers.js\n **/","export const ROOT             = 'ROOT';\nexport const VARIABLE         = 'VARIABLE';\nexport const SECTION          = 'SECTION';\nexport const TEXT             = 'TEXT';\nexport const COMMENT          = 'COMMENT';\nexport const PARTIAL          = 'PARTIAL';\nexport const DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\n\n/** WEBPACK FOOTER **\n ** ./src/node.js\n **/","import * as TokenType from './token';\nimport * as NodeType from './node';\nimport { Tokenizer } from './tokenizer';\nimport { visit } from './helpers';\nimport { instantiateAll } from './extension';\n\nclass ParserContext {\n  constructor(parser) {\n    this._parser = parser;\n  }\n\n  appendNode(node) {\n    this._parser._appendNode(node);\n  }\n\n  pushParent(node) {\n    this._parser._pushParent(node);\n  }\n\n  popParent() {\n    return this._parser._popParent();\n  }\n\n  get top() {\n    return this._parser._stack.length;\n  }\n\n  get tailNode() {\n    return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n  }\n\n  throw(message) {\n    return this._parser._throw(message);\n  }\n}\n\nexport class Parser {\n  constructor(opts = {}) {\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll();\n    this._filename = opts.filename || '';\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  parse(src) {\n    const rootNode = { \n      type: NodeType.ROOT, \n      children: []\n    };\n    this._src = src;\n    this._stack = [rootNode];\n    this._lastToken = null;\n    this._parseNodes(src);\n\n    if (this._extensions.length > 0) {\n      for (let i = 0; i < this._extensions.length; i++) {\n        this._extensions[i].visit(rootNode);\n      }\n    }\n\n    return rootNode;\n  }\n\n  _appendNode(node) {\n    this._stack[this._stack.length - 1].children.push(node);\n    return node;\n  }\n\n  _getTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  _clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  _makeLocation(beginLocation, endLocation) {\n    const location = this._clone(beginLocation);\n    location.filename = this._filename;\n    if (endLocation) {\n      location.endIndex = endLocation.endIndex;\n      location.endLine = endLocation.endLine;\n    }\n    return location;\n  }\n\n  _parseNodes(src) {\n    let initialStackSize = this._stack.length;\n    let token;\n    const z = new Tokenizer(src, { \n      delimiters: this._delimiters.slice(0),\n      extensions: this._extensions\n    });\n\n    do {\n      token = z.getNextToken();\n\n      if (z.error !== null) {\n        throw z.error;\n      }\n\n      this._lastToken = token;\n\n      let handled = false;\n      if (this._extensions) {\n        for (let i = 0; i < this._extensions.length; i++) {\n          const ext = this._extensions[i];\n          if (ext.handleToken(token, this._parserContext) === true) {\n            handled = true;\n            break;\n          }\n        }\n      }\n\n      if (!handled) {\n        switch (token.type) {\n          case TokenType.TEXT:\n            this._appendNode({\n              type: NodeType.TEXT,\n              text: token.text,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.VARIABLE:\n          case TokenType.UNESCAPED_VARIABLE:\n            this._appendNode({\n              type: NodeType.VARIABLE,\n              name: token.name,\n              unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.SECTION_OPEN:\n            this._handleSectionOpen(token);\n            break;\n\n          case TokenType.INVERTED_SECTION_OPEN:\n            this._handleSectionOpen(token, true);\n            break;\n\n          case TokenType.SECTION_CLOSE:\n            this._handleSectionClose(token);\n            break;\n\n          case TokenType.PARTIAL:\n            this._appendNode({\n              type: NodeType.PARTIAL,\n              name: token.name,\n              indent: token.indent,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.COMMENT:\n            this._handleComment(token);\n            break;\n\n          case TokenType.DELIMITER_CHANGE:\n            this._appendNode({\n              type: NodeType.DELIMITER_CHANGE,\n              delimiters: token.delimiters,\n              location: this._makeLocation(token.location)\n            });\n            break;\n        }\n      }\n    } while (token.type !== TokenType.EOF);\n\n    if (this._stack.length > initialStackSize) {\n      this._throw('Unexpected EOF: sections not closed: ' + \n        this._stack.slice(initialStackSize).map(n => `'${n.name}'`).join(', '));\n    } else if (this._stack.length < initialStackSize) {\n      this._throw('Internal error.');\n    }\n  }\n\n  _throw(message) {\n    const e = new Error(message);\n    e.location = this._lastToken.location;\n    throw e;\n  }\n\n  _pushParent(node) {\n    node.children = [];\n    this._stack.push(node);\n  }\n\n  _popParent() {\n    return this._stack.pop();\n  }\n\n  _handleSectionOpen(token, inverted = false) {\n    const { name, location } = token;\n    this._pushParent({\n      type: NodeType.SECTION,\n      name,\n      inverted,\n      location\n    });\n  }\n\n  _handleSectionClose(token) {\n    const { name, location } = token;\n    const section = this._popParent();\n    if (section.type !== NodeType.SECTION) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}'`);\n    }\n\n    if (section.name !== name) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}', current section: '${section.name}'`);\n    }\n\n    section.raw = this._src.slice(section.location.endIndex, location.index);\n    section.location = this._makeLocation(section.location, token.location);\n\n    this._appendNode(section);\n  }\n\n  _handleComment(token) {\n    const { content, location } = token;\n    this._appendNode({\n      type: NodeType.COMMENT,\n      content,\n      location: this._makeLocation(location)\n    });\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parser.js\n **/","import * as TokenType from './token';\nimport { instantiateAll } from './extension';\nimport { trimStandaloneToken } from './helpers';\n\nconst STATE_NONE        = 'STATE_NONE';\nconst STATE_EOF         = 'STATE_EOF';\nconst STATE_TEXT        = 'STATE_TEXT';\nconst STATE_TEXT_BREAK  = 'STATE_TEXT_BREAK';\nconst STATE_TAG         = 'STATE_TAG';\n\nconst DELIMITER_LEFT  = 0;\nconst DELIMITER_RIGHT = 1;\n\nexport class Tokenizer {\n  constructor(src, opts = {}) {\n    this._extensions = opts.extensions || instantiateAll();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 0;\n    this._column = 0;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  getNextToken() {\n    if (this._tokens.length > 0) {\n      return this._tokens.shift();\n    }\n\n    let done = false;\n    let matched = false;\n    do {\n      //console.log(this._state, this._tokens);\n      if (this._error !== null) {\n        return null;\n      }\n\n      if (this._state !== STATE_NONE) {\n        matched = true;\n        this._markTokenStartLocation();\n      }\n\n      switch (this._state) {\n        case STATE_NONE:\n          this._read();\n          break;\n\n        case STATE_EOF:\n          this._handleEOF();\n          done = true;\n          break;\n\n        case STATE_TEXT:\n          this._handleText();\n          break;\n\n        case STATE_TEXT_BREAK:\n          this._handleTextBreak();\n          done = true;\n          break;\n\n        case STATE_TAG:\n          this._handleTag();\n          break;\n      }\n\n      if (matched) {\n        this._markTokenEndLocation();\n        matched = false;\n      }\n\n      if (this._state === STATE_NONE) {\n        if (this._char === null) {\n          this._state = STATE_EOF;\n        } else if (this._char === '\\n') {\n          this._state = STATE_TEXT_BREAK;\n        } else if (this._isDelimiter(DELIMITER_LEFT)) {\n          this._state = STATE_TAG;\n        } else {\n          this._state = STATE_TEXT;\n        }\n      }\n\n    } while (!done);\n\n    return this._error === null ? this._tokens.shift() : null;\n  }\n\n  // Handlers\n\n  _handleEOF() {\n    this._handleStandaloneTag();\n    this._makeToken({ \n      type: TokenType.EOF\n    });\n  }\n\n  _handleTag() {\n    const [ left, right ] = this._delimiters;\n    this._skip(left.length);\n    this._skipAllWhitespaces();\n\n    if (this._char === null) {\n      this._setError('Unclosed tag.');\n    }\n    else if (this._isDelimiter(DELIMITER_RIGHT)) {\n      this._handleEmptyTag();\n    } else {\n      const tagTypeChar = this._char;\n      if (tagTypeChar === '{') {\n        this._handleVariableCurly();\n      } else {\n        let tagContentStart = this._index - 1;\n        //read content\n        while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n          this._read();\n        }\n\n        if (this._char === null) {\n          this._setError('Unclosed tag.');\n        } else {\n          const content = this._src.slice(tagContentStart, this._index - 1);\n          switch (tagTypeChar) {\n            case '>': this._handleSimpleTag(TokenType.PARTIAL, content); break;\n            case '^': this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content); break;\n            case '#': this._handleSimpleTag(TokenType.SECTION_OPEN, content); break;\n            case '/': this._handleSimpleTag(TokenType.SECTION_CLOSE, content); break;\n\n            case '!':\n              this._handleComment(content.substr(1));\n              break;\n\n            case '=':\n              this._handleDelimiterChange(content);\n              break;\n            case '&':\n              this._handleVariable(content.substr(1), true);\n              break;\n            default:\n              this._handleVariable(content);\n              break;\n          }\n        }\n      }\n    }\n    if (this._error === null) {\n      //eat right\n      for (let i = 0; i < right.length; i++) {\n        this._read();\n      }\n    }\n\n    this._state = STATE_NONE;\n  }\n\n  _handleDelimiterChange(content) {\n    const newDelimiters = extractNewDelimiters(content);\n    if (newDelimiters === null) {\n      this._setError('Invalid change delimiter syntax.');\n    } else {\n      const [ left, right ] = newDelimiters;\n      this._delimiters = newDelimiters;\n      this._makeToken({\n        type: TokenType.DELIMITER_CHANGE,\n        delimiters: [ left, right ]\n      });\n    }\n  }\n\n  _handleSimpleTag(type, content) {\n    this._makeToken({ type, name: content.substr(1).trim() });\n  }\n\n  _handleComment(content) {\n    this._makeToken({\n      type: TokenType.COMMENT,\n      content\n    });\n  }\n\n  _handleVariableCurly() {\n    this._read(); //eat '{'\n    const begin = this._index - 1;\n    const d = this._distance('}');\n    if (d === -1) {\n      this._setError('Unclosed variable tag: missingright curly.');\n    } else {\n      const content = this._src.slice(begin, begin + d);\n      this._skip(d + 1); //skip '}'\n      this._skipAllWhitespaces();\n      if (!this._isDelimiter(DELIMITER_RIGHT)) {\n        this._setError('Unclosed variable: missing right delimiter.');\n      } else {\n        this._makeToken({\n          type: TokenType.UNESCAPED_VARIABLE,\n          name: content.trim()\n        });\n      }\n    }\n  }\n\n  _handleEmptyTag() {\n    this._makeToken({\n      type: TokenType.VARIABLE,\n      name: ''\n    });\n  }\n\n  _handleVariable(content, unescaped) {\n    this._makeToken({\n      type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n      name: content.trim()\n    });\n  }\n\n  _handleText() {\n    let done = false;\n    let index = this._index - 1;\n    let length = 0;\n    do {\n      const c = this._char;\n\n      if (c === null || c === '\\n' || this._isDelimiter(DELIMITER_LEFT)) {\n        done = true;\n      } else {\n        length ++;\n      }\n\n      if (!done) {\n        this._read();\n      }\n    } while (!done);\n\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: this._src.slice(index, index + length)\n    });\n\n    this._state = STATE_NONE;\n  }\n\n  _handleTextBreak() {\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: '\\n'\n    });\n    this._read();\n    this._handleStandaloneTag();\n    this._state = STATE_NONE;\n  }\n\n  _handleStandaloneTag() {\n    this._tokens = trimStandaloneToken(this._tokens);\n  }\n\n  // Helpers\n  _dump(t = '') {\n    console.log(t +'>'+this._src.slice(this._index - 1));\n  }\n\n  _read() {\n    if (this._index < this._src.length) {\n      if (this._char === '\\n') {\n        this._line ++;\n        this._column = 0;\n      } else {\n        this._column ++;\n      }\n\n      this._char = this._src[this._index];\n      this._index ++;\n    } else {\n      this._char = null;\n    }\n  }\n\n  _peek() {\n    if (this._index < this._src.length - 1) {\n      return this._src[this._index];\n    } else {\n      return null;\n    }\n  }\n\n  _skip(n) {\n    for (let i = 0; i < n; i ++) {\n      this._read();\n    }\n  }\n\n  _distance(c) {\n    for (let i = this._index; i < this._src.length; i++) {\n      if (this._src[i] === c) {\n        return i - this._index + 1;\n      }\n    }\n    return -1;\n  }\n\n  _skipAllWhitespaces() {\n    while (this._isWhitespace()) {\n      this._read();\n    }\n  }\n\n  _markTokenStartLocation() {\n    this._location.index = this._index - 1;\n    this._location.line = this._line;\n    this._location.column = this._column;\n  }\n\n  _markTokenEndLocation() {\n    const token = this._tokens[this._tokens.length - 1];\n    const { index, line, column } = this._location;\n    token.location = {\n      index, line, column,\n      endIndex: this._index - 1,\n      endLine: this._line,\n      endColumn: this._column\n    };\n  }\n\n  _isWhitespace() {\n    return /\\s/.test(this._char);\n  }\n\n  _isDelimiter(d, offset = 0) {\n    const delimiter = this._delimiters[d];\n    const pos = this._index - 1 + offset;\n    return this._src.slice(pos, pos + delimiter.length) === delimiter;\n  }\n\n  _makeToken(token) {\n    if (this._extensions.length) {\n      try {\n        this._extensions.forEach(ext => {\n          token = ext.transformToken(token);\n        });\n      } catch (e) {\n        this._setError(e.message);\n        return;\n      }\n    }\n    this._tokens.push(token);\n  }\n\n  _setError(message) {\n    const error = new Error(message);\n    error.index = this._index - 1;\n    error.line = this._line;\n    error.column = this._column;\n    this._error = error;\n  }\n}\n\nfunction extractNewDelimiters(tagContent) {\n  const matches = tagContent.match(/=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/tokenizer.js\n **/","// https://github.com/mustache/spec/pull/75\n\nimport { Extension, register } from '../extension';\nimport * as NodeType from '../node';\nimport * as TokenType from '../token';\nimport { walk } from '../helpers';\n\nconst PARENT = 'Inheritance.PARENT';\nconst BLOCK = 'Inheritance.BLOCK';\nconst LEAVE_SCOPE = 'Inheritance.LEAVE_SCOPE';\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nexport class Inheritance extends Extension {\n  constructor() {\n    super();\n\n    this._blocks = null;\n  }\n\n  transformToken(token) {\n    const { type, name, location } = token;\n    switch (type) {\n      case TokenType.VARIABLE:\n        if (name) {\n          if (name[0] === '<') {\n            if (name.length === 1) {\n              throw new Error('Parent partial name expected');\n            }\n            token = {\n              type: PARENT,\n              name: name.slice(1),\n              location\n            };\n          } else if (name[0] === '$') {\n            if (name.length === 1) {\n              throw new Error('Block name expected');\n            }\n            token = {\n              type: BLOCK,\n              name: name.slice(1),\n              location\n            };\n          }\n        }\n        break;\n    }\n    return token;\n  }\n\n  handleToken(token, parserContext) {\n    let handled = false;\n    const { name, location, type } = token;\n    switch (type) {\n      case PARENT:\n        parserContext.pushParent({\n          type: PARENT,\n          name,\n          location\n        });\n        handled = true;\n        break;\n\n      case BLOCK:\n        parserContext.pushParent({\n          type: BLOCK,\n          name,\n          location\n        });\n        break;\n\n      case TokenType.SECTION_CLOSE:\n        const tagNode = parserContext.tailNode;\n        if (tagNode === null) {\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.throw('Unexpected tag close');\n          }\n        } else {\n          if (tagNode.name !== name) {\n            parserContext.throw(`Unexpected tag close, current tag: ${tagNode.name}`);\n          }\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.popParent();\n            tagNode.location.endIndex = location.endIndex;\n            tagNode.location.endLine = location.endLine;\n            parserContext.appendNode(tagNode);\n\n            //TODO move this to visit, handle whitespaces after Parent close tag.\n            const firstLine = tagNode.location.line;\n            const firstBlock = tagNode.children.find(c => c.type === BLOCK);\n            if (firstBlock && firstBlock.location.line === firstLine) {\n              for (let i = 0; i < firstBlock.children.length; i++) {\n                const blockNode = firstBlock.children[i];\n                if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n                  blockNode.text = '';\n                } else {\n                  break;\n                }\n              }\n            }\n\n            handled = true;\n          }\n        }\n        break;\n\n      case TokenType.EOF:\n        if (this.top > 0) {\n          parserContext.throw('Unexpected EOF: tags not closed: ' + \n            this.stack.map(f => f.name).join(', '));\n        }\n        break;\n    }\n    return handled;\n  }\n\n  handleNode(node, rendererContext) {\n    switch (node.type) {\n      case PARENT:\n        this._handleParent(node, rendererContext);\n        break;\n\n      case BLOCK:\n        this._handleBlock(node, rendererContext);\n        break;\n\n      case LEAVE_SCOPE:\n        this._blocks = null;\n        break;\n    }\n  }\n\n  _handleParent(node, rendererContext) {\n    const { name } = node;\n\n    if (this._blocks === null) {\n      rendererContext.pushNodes([\n        {\n          type: LEAVE_SCOPE\n        }\n      ]);\n      this._blocks = {};\n    }\n\n    //find all blocks defined in parent\n    node.children.forEach(child => {\n      if (child.type === BLOCK) {\n        const blockName = child.name;\n        if (!this._blocks.hasOwnProperty(blockName)) {\n          this._blocks[blockName] = child;\n        }\n      }\n    });\n\n    rendererContext.pushNodes([\n      {\n        type: TokenType.PARTIAL,\n        name,\n        indent: node.indent\n      }\n    ]);\n  }\n\n  _handleBlock(node, rendererContext) {\n    const { name } = node;\n    if (this._blocks !== null && this._blocks.hasOwnProperty(name)) {\n      rendererContext.pushNodes(this._blocks[name].children);\n    } else {\n      rendererContext.pushNodes(node.children);\n    }\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/extensions/inheritance.js\n **/","import * as nodeTypes from './node';\nimport escapeHTML from 'escape-html';\nimport { Parser } from './parser';\nimport { walk, visit } from './helpers';\nimport { instantiateAll } from './extension';\n\nconst REPEATER_NODE_TYPE  = '_REPEATER';\nconst MAX_PARTIAL_STACK = 10;\nconst MAX_LAMBDA_STACK = 255;\n\nclass RenderContext {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n\n  get top() {\n    return this._renderer._stack.length;\n  }\n\n  evaluate(name) {\n    return this._renderer._evaluate(name);\n  }\n\n  pushNodes(nodes) {\n    this._renderer._pushNodes(nodes);\n  }\n\n  pushContext(ctx) {\n    this._pushContext(ctx);\n  }\n\n  parse(src, opts) {\n    return this._renderer._parse(src, opts);\n  }\n\n  getParsedPartial(name) {\n    return this._renderer._getParsedPartial(name);\n  }\n\n  throw(message, location) {\n    return this._renderer._throw(message, location);\n  }\n}\n\nexport class Renderer {\n  constructor(src, opts = {}) {\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n    this._extensions = opts.extensions || instantiateAll();\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n  }\n\n  render(context) {\n    this._stack = [];\n    this._contextStack = [];\n    this._partialStack = [];\n    this._lambdaStack = [];\n\n    this._pushContext(context);\n\n    //push root nodes\n    const rootNode = this._parse(this._src);\n    this._stack = rootNode.children.slice(0).reverse();\n\n    let out = '';\n    let newline = true;\n    while (this._stack.length > 0) {\n      const node = this._stack[this._stack.length - 1];\n      const partial = this._partialStack.length ? this._partialStack[this._partialStack.length - 1] : null;\n\n      //insert indent\n      if (node.type in nodeTypes) {\n        if (newline && partial !== null && partial.indent.length > 0) {\n          out += partial.indent;\n        }\n      }\n\n      let value;\n      switch (node.type) {\n        case nodeTypes.VARIABLE:\n          value = this._evaluate(node.name);\n          if (isFunction(value)) {\n            this._popNode();\n            this._expandLambda(node, value);\n          } else {\n            if (!!value) {\n              out += node.unescaped ? value : escapeHTML(value);\n            }\n            this._popNode();\n          }\n          break;\n\n        case nodeTypes.SECTION:\n          value = this._evaluate(node.name);\n          if (isFunction(value)) {\n            this._popNode();\n            this._expandLambda(node, value);\n          } else {\n            let isList = Array.isArray(value);\n\n            if (isList && value.length === 0) {\n              //Empty lists should behave like falsey values.\n              value = false;\n              isList = false;\n            }\n\n            let testResult = !!value;\n            if (node.inverted) {\n              testResult = !testResult;\n            }\n\n            if (testResult) {\n              if (isList) {\n                this._popNode();\n                this._pushRepeaterNode(value.length, node.children, value);\n              } else {\n                this._popNode()\n                this._pushContext(value);\n                this._pushNodes(node.children);\n              }\n            } else {\n              this._popNode();\n            }\n          }\n          break;\n\n        case nodeTypes.TEXT:\n          out += node.text;\n          this._popNode()\n          break;\n\n        case nodeTypes.COMMENT:\n          this._popNode();\n          break;\n\n        case nodeTypes.PARTIAL:\n          this._popNode();\n          this._expandPartial(node);\n          break;\n\n        case nodeTypes.DELIMITER_CHANGE:\n          this._popNode();\n          this._delimiters = node.delimiters.slice(0);\n          break;\n\n        case REPEATER_NODE_TYPE:\n          if (node.count < node.repeat) {\n            const repeatIndex = node.count;\n            if (repeatIndex === 0) {\n              this._pushContext(node.contexts[0]);\n            } else {\n              this._replaceTopContext(node.contexts[repeatIndex]);\n            }\n            this._pushNodes(node.children);\n            node.count ++;\n          } else {\n            this._popNode();\n          }\n          break;\n\n        default:\n          this._popNode();\n          if (this._extensions) {\n            this._extensions.forEach(ext => {\n              ext.handleNode(node, this._renderContext);\n            });\n          }\n          break;\n      }\n\n      this._checkStacks();\n      newline = out.length === 0 || (out[out.length -1 ] === '\\n');\n    }\n    return out;\n  }\n\n  _parse(src, opts = {}) {\n    opts.extensions = this._extensions;\n    const parser = new Parser(opts);\n    return parser.parse(src);\n  }\n\n  _pushNodes(list) {\n    for (let i = list.length - 1; i >= 0; i --) {\n      this._stack.push(list[i]);\n    }\n  }\n\n  _popNode() {\n    this._stack.pop();\n  }\n\n  _pushRepeaterNode(repeat, nodes, contexts) {\n    this._stack.push({\n      type: REPEATER_NODE_TYPE,\n      count: 0,\n      repeat,\n      children: nodes.slice(0),\n      contexts\n    });\n  }\n\n  _pushContext(context) {\n    this._contextStack.push({\n      context,\n      sp: this._stack.length\n    });\n  }\n\n  _pushPartial({ name, indent, location }) {\n    this._partialStack.push({\n      name,\n      indent: indent || '',\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _pushLambda({ name, location }) {\n    this._lambdaStack.push({\n      name,\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _replaceTopContext(context) {\n    this._contextStack[this._contextStack.length - 1].context = context;\n  }\n\n  _checkStacks() {\n    //console.log('STACK', this._stack);\n\n    //console.log('CONTEXT STACK:', this._contextStack);\n    if (this._stack.length === this._contextStack[this._contextStack.length - 1].sp) {\n      this._contextStack.pop();\n    }\n\n    //console.log('PARTIAL STACK:', this._partialStack);\n    if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n      this._partialStack.pop();\n    }\n\n    if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n      this._lambdaStack.pop();\n    }\n  }\n\n  _evaluate(name) {\n    if (name === '.') {\n      return this._contextStack[this._contextStack.length - 1].context;\n    }\n\n    const path = name.split('.');\n    for (let i = this._contextStack.length - 1; i >= 0; i--) {\n      const context = this._contextStack[i].context;\n      if (context === null || typeof context !== 'object') {\n        continue;\n      }\n\n      let current = context;\n      let resolved = true;\n      for (let pi = 0; pi < path.length; pi++) {\n        const key = path[pi];\n        if (current.hasOwnProperty(key)) {\n          current = current[key];\n        } else {\n          resolved = false;\n          break;\n        }\n      }\n\n      if (resolved) {\n        return current;\n      }\n    }\n    return '';\n  }\n\n  _getParsedPartial(name) {\n    if (this._partialCached.hasOwnProperty(name)) {\n      return this._partialCached[name];\n    } else {\n      if (!this._partials.hasOwnProperty(name)) {\n        return null;\n      }\n      const ast = this._parse(this._partials[name], { name });\n      const nodes = this._partialCached[name] = ast.children;\n      return nodes;\n    }\n  }\n\n  _expandPartial(node) {\n    const { name } = node;\n    const nodes = this._getParsedPartial(name);\n\n    if (nodes === null) {\n      //The empty string should be used when the named partial is not found.\n      return;\n    }\n\n    this._pushPartial(node);\n\n    if (this._partialStack.length > MAX_PARTIAL_STACK) {\n      this._throw(\n        'Possible partial short circuit: ' +\n          this._partialStack.map(f => `${f.name}@${f.location.filename}:${f.location.line+1}`).concat([name]).join(' -> '),\n        node.location\n      );\n    }\n\n    this._pushNodes(nodes);\n  }\n\n  _expandLambda(node, lambda) {\n    const { name } = node;\n\n    this._pushLambda(node);\n\n    if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n      this._throw(\n        'Possible lambda short circuit: ' +\n          this._lambdaStack.map(f => `${f.name}@${f.location.filename}:${f.location.line+1}`).concat([name]).join(' -> '),\n        node.location\n      );\n    }\n\n    let ast;\n    let skipped = false;\n    if (node.type === nodeTypes.VARIABLE) {\n      const code = lambda();\n      if (code) {\n        //A lambda's return value should parse with the default delimiters.\n        ast = this._parse('' + code, { name: '[lambda]' });\n        if (!node.unescaped) {\n          //Lambda results should be appropriately escaped.\n          walk(ast, node => {\n            if (node.type === nodeTypes.TEXT) {\n              node.text = escapeHTML(node.text);\n            }\n          });\n        }\n      } else {\n        skipped = true;\n      }\n    } else if (node.type === nodeTypes.SECTION) {\n      const code = lambda(node.raw);\n      if (code) {\n        //Lambdas used for inverted sections should be considered truthy.\n        //Lambdas used for sections should parse with the current delimiters.\n        ast = this._parse('' + code, {\n          name: '[#lambda]',\n          delimiters: this._delimiters.slice(0)\n        });\n      } else {\n        skipped = true;\n      }\n    }\n\n    if (!skipped) {\n      this._pushNodes(ast.children);\n    }\n  }\n\n  _throw(message, location) {\n    const e = new Error(message);\n    e.location = location;\n    throw e;\n  }\n}\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == '[object Function]';\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/renderer.js\n **/","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escape-html/index.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}