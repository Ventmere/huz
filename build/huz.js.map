{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 5f9d2d36675eebc7e1fc","webpack:///huz.js","webpack:///./src/extension.js","webpack:///./src/token.js","webpack:///./src/helpers.js","webpack:///./src/node.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js","webpack:///./src/extensions/inheritance.js","webpack:///./src/renderer.js","webpack:///./src/index.js","webpack:///./~/escape-html/index.js"],"names":["root","factory","exports","module","define","amd","a","i","this","__webpack_require__","moduleId","installedModules","l","modules","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","instantiateAll","opts","registry","map","ctor","register","constructor","push","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Extension","token","parserContext","node","renderContext","result","nodeResult","EOF","TEXT","PARTIAL","INVERTED_SECTION_OPEN","SECTION_OPEN","SECTION_CLOSE","UNESCAPED_VARIABLE","COMMENT","VARIABLE","DELIMITER_CHANGE","walk","modifier","stack","children","slice","reverse","pop","undefined","concat","visit","visitor","child","modified","trimStandaloneToken","tokens","count","open","inline","standalone","indentTokens","type","TokenType","isStringWhitespace","text","tailWSNodeCount","indent","forEach","t","str","test","_token","obj","newObj","ROOT","SECTION","_interopRequireWildcard","_node","NodeType","_tokenizer","_extension","ParserContext","parser","_parser","_appendNode","_pushParent","_popParent","f","_stack","item","message","location","_throw","_filename","parentNode","_src","Parser","_delimiters","delimiters","_extensions","extensions","filename","_parserContext","_lastToken","src","rootNode","_parseNodes","_addNodeToken","JSON","parse","stringify","beginLocation","endLocation","_clone","endIndex","endLine","initialStackSize","z","getNextToken","error","handled","ext","handleToken","_makeLocation","unescaped","_handleSectionOpen","_handleSectionClose","_handleComment","join","e","Error","inverted","section","raw","index","content","extractNewDelimiters","tagContent","matches","match","R_DELIMITER_CHANGE","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","Array","isArray","_helpers","STATE_NONE","Tokenizer","_index","_char","_tokens","_line","_column","_state","_error","_location","line","column","shift","matched","_markTokenStartLocation","_read","_handleEOF","_handleText","_handleTextBreak","_handleTag","_markTokenEndLocation","_isDelimiter","_handleStandaloneTag","_makeToken","left","right","_skip","_skipAllWhitespaces","_setError","_handleEmptyTag","tagTypeChar","_handleVariableCurly","tagContentStart","_handleSimpleTag","substr","_handleDelimiterChange","_handleVariable","newDelimiters","_newDelimiters","trim","begin","_distance","console","log","_isWhitespace","endColumn","offset","delimiter","pos","transformToken","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","isInheritanceTagType","PARENT","BLOCK","_get","_x","_x2","_x3","_again","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_token2","Inheritance","_blocks","_parentStack","pushParent","_pushBlock","tagNode","popParent","appendNode","firstLine","firstBlock","find","blockNode","rendererContext","top","_checkTop","_handleParent","_handleBlock","findParentNode","pushNodes","blocks","blockName","keys","_setDefaultBlocks","pushNode","defaultBlock","_getDefaultBlock","frame","topFrame","assign","isFunction","x","toString","nodeTypes","_escapeHtml","_escapeHtml2","default","RenderContext","renderer","_renderer","_evaluate","nodes","_pushNodes","_pushNode","ctx","sp","_pushContext","_out","_parse","_getParsedPartial","Renderer","_this","_parsed","parsed","_partials","partials","_renderContext","_partialCached","k","_contextStack","_partialStack","_lambdaStack","_transformNodeResult","reduce","r","transformNodeResult","context","_this2","node_count","newline","handleNode","splice","partial","_popNode","_expandLambda","isList","testResult","_pushRepeaterNode","_expandPartial","repeat","repeatIndex","contextIndex","contexts","_replaceContextAt","_checkStacks","transformResult","list","Math","min","max","RangeError","path","split","current","resolved","pi","ast","_pushPartial","lambda","_pushLambda","skipped","code","compile","render","Helpers","_extensionsInheritance","escapeHtml","string","matchHtmlRegExp","exec","escape","html","lastIndex","charCodeAt","substring"],"mappings":"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","file":"huz.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5f9d2d36675eebc7e1fc","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.instantiateAll = instantiateAll;\nexports.register = register;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar registry = [];\n\nvar Extension = (function () {\n  function Extension() {\n    _classCallCheck(this, Extension);\n  }\n\n  _createClass(Extension, [{\n    key: \"transformToken\",\n\n    //called by tokenizer\n    value: function transformToken(token) {\n      return token;\n    }\n\n    //called by parser\n  }, {\n    key: \"handleToken\",\n    value: function handleToken(token, parserContext) {}\n  }, {\n    key: \"visit\",\n    value: function visit(root) {\n      return root;\n    }\n\n    //called by renderer\n  }, {\n    key: \"handleNode\",\n    value: function handleNode(node, renderContext) {}\n  }, {\n    key: \"transformNodeResult\",\n    value: function transformNodeResult(node, result, nodeResult) {\n      return nodeResult;\n    }\n  }, {\n    key: \"transformResult\",\n    value: function transformResult(result) {\n      return result;\n    }\n  }]);\n\n  return Extension;\n})();\n\nexports.Extension = Extension;\n\nfunction instantiateAll(opts) {\n  return registry.map(function (ctor) {\n    return new ctor(opts);\n  });\n}\n\nfunction register(constructor) {\n  return registry.push(constructor);\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar EOF = 'EOF';\nexports.EOF = EOF;\nvar TEXT = 'TEXT';\nexports.TEXT = TEXT;\nvar PARTIAL = 'PARTIAL';\nexports.PARTIAL = PARTIAL;\nvar INVERTED_SECTION_OPEN = 'INVERTED_SECTION_OPEN';\nexports.INVERTED_SECTION_OPEN = INVERTED_SECTION_OPEN;\nvar SECTION_OPEN = 'SECTION_OPEN';\nexports.SECTION_OPEN = SECTION_OPEN;\nvar SECTION_CLOSE = 'SECTION_CLOSE';\nexports.SECTION_CLOSE = SECTION_CLOSE;\nvar UNESCAPED_VARIABLE = 'UNESCAPED_VARIABLE';\nexports.UNESCAPED_VARIABLE = UNESCAPED_VARIABLE;\nvar COMMENT = 'COMMENT';\nexports.COMMENT = COMMENT;\nvar VARIABLE = 'VARIABLE';\nexports.VARIABLE = VARIABLE;\nvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\nexports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.walk = walk;\nexports.visit = visit;\nexports.trimStandaloneToken = trimStandaloneToken;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nfunction walk(root, modifier) {\n  var stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    var node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nfunction visit(root, visitor) {\n  var stack = [root];\n  while (stack.length) {\n    var _parent = stack.pop();\n    for (var i = 0; i < _parent.children.length; i++) {\n      var child = _parent.children[i];\n      var modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        _parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nfunction trimStandaloneToken(tokens) {\n  var count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  var open = null;\n  var inline = 0;\n  var standalone = true;\n  var indentTokens = [];\n  for (var i = 0; standalone && i < count; i++) {\n    var token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline++;\n        }\n        break;\n      default:\n        //section-like tags\n        if (open === null) {\n          open = [token];\n          inline++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n\n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    var tailWSNodeCount = 0;\n    for (var i = count - 1; i >= 0; i--) {\n      var token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        var indent = '';\n        indentTokens.forEach(function (t) {\n          indent += t.text;\n        });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return (/^\\s*$/.test(str)\n  );\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ROOT = \"ROOT\";\nexports.ROOT = ROOT;\nvar VARIABLE = \"VARIABLE\";\nexports.VARIABLE = VARIABLE;\nvar SECTION = \"SECTION\";\nexports.SECTION = SECTION;\nvar TEXT = \"TEXT\";\nexports.TEXT = TEXT;\nvar COMMENT = \"COMMENT\";\nexports.COMMENT = COMMENT;\nvar PARTIAL = \"PARTIAL\";\nexports.PARTIAL = PARTIAL;\nvar DELIMITER_CHANGE = \"DELIMITER_CHANGE\";\nexports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _tokenizer = __webpack_require__(5);\n\nvar _helpers = __webpack_require__(2);\n\nvar _extension = __webpack_require__(0);\n\nvar ParserContext = (function () {\n  function ParserContext(parser) {\n    _classCallCheck(this, ParserContext);\n\n    this._parser = parser;\n  }\n\n  _createClass(ParserContext, [{\n    key: \"appendNode\",\n    value: function appendNode(node) {\n      this._parser._appendNode(node);\n    }\n  }, {\n    key: \"pushParent\",\n    value: function pushParent(node) {\n      this._parser._pushParent(node);\n    }\n  }, {\n    key: \"popParent\",\n    value: function popParent() {\n      return this._parser._popParent();\n    }\n  }, {\n    key: \"findParentNode\",\n    value: function findParentNode(f) {\n      for (var i = this._parser._stack.length - 1; i >= 0; i--) {\n        var item = this._parser._stack[i];\n        if (f(item)) {\n          return item;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(message, location) {\n      return this._parser._throw(message, location);\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._parser._filename;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._parser._stack.length;\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n    }\n\n    /// deprecated, use `parentNode` instead\n  }, {\n    key: \"tailNode\",\n    get: function get() {\n      return this.parentNode;\n    }\n  }, {\n    key: \"src\",\n    get: function get() {\n      return this._parser._src;\n    }\n  }]);\n\n  return ParserContext;\n})();\n\nvar Parser = (function () {\n  function Parser() {\n    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, Parser);\n\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n    this._filename = opts.filename || \"\";\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(src) {\n      var rootNode = {\n        type: NodeType.ROOT,\n        children: []\n      };\n      this._src = src;\n      this._stack = [rootNode];\n      this._lastToken = null;\n      this._parseNodes(src);\n\n      if (this._extensions.length > 0) {\n        for (var i = 0; i < this._extensions.length; i++) {\n          this._extensions[i].visit(rootNode);\n        }\n      }\n\n      return rootNode;\n    }\n  }, {\n    key: \"_addNodeToken\",\n    value: function _addNodeToken(node) {\n      var token = this._lastToken;\n      if (node.tokens) {\n        node.tokens.push(token);\n      } else {\n        node.tokens = [token];\n      }\n    }\n  }, {\n    key: \"_appendNode\",\n    value: function _appendNode(node) {\n      this._addNodeToken(node);\n      node.location.filename = this._filename;\n      this._stack[this._stack.length - 1].children.push(node);\n      return node;\n    }\n  }, {\n    key: \"_getTop\",\n    value: function _getTop() {\n      return this._stack[this._stack.length - 1];\n    }\n  }, {\n    key: \"_clone\",\n    value: function _clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  }, {\n    key: \"_makeLocation\",\n    value: function _makeLocation(beginLocation, endLocation) {\n      var location = this._clone(beginLocation);\n      if (endLocation) {\n        location.endIndex = endLocation.endIndex;\n        location.endLine = endLocation.endLine;\n      }\n      return location;\n    }\n  }, {\n    key: \"_parseNodes\",\n    value: function _parseNodes(src) {\n      var initialStackSize = this._stack.length;\n      var token = undefined;\n      var z = new _tokenizer.Tokenizer(src, {\n        delimiters: this._delimiters.slice(0),\n        extensions: this._extensions,\n        filename: this._filename\n      });\n\n      do {\n        token = z.getNextToken();\n\n        if (z.error !== null) {\n          throw z.error;\n        }\n\n        this._lastToken = token;\n\n        var handled = false;\n        if (this._extensions) {\n          for (var i = 0; i < this._extensions.length; i++) {\n            var ext = this._extensions[i];\n            if (ext.handleToken(token, this._parserContext) === true) {\n              handled = true;\n              break;\n            }\n          }\n        }\n\n        if (!handled) {\n          switch (token.type) {\n            case TokenType.TEXT:\n              this._appendNode({\n                type: NodeType.TEXT,\n                text: token.text,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.VARIABLE:\n            case TokenType.UNESCAPED_VARIABLE:\n              this._appendNode({\n                type: NodeType.VARIABLE,\n                name: token.name,\n                unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.SECTION_OPEN:\n              this._handleSectionOpen(token);\n              break;\n\n            case TokenType.INVERTED_SECTION_OPEN:\n              this._handleSectionOpen(token, true);\n              break;\n\n            case TokenType.SECTION_CLOSE:\n              this._handleSectionClose(token);\n              break;\n\n            case TokenType.PARTIAL:\n              this._appendNode({\n                type: NodeType.PARTIAL,\n                name: token.name,\n                indent: token.indent,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.COMMENT:\n              this._handleComment(token);\n              break;\n\n            case TokenType.DELIMITER_CHANGE:\n              this._appendNode({\n                type: NodeType.DELIMITER_CHANGE,\n                delimiters: token.delimiters,\n                location: this._makeLocation(token.location)\n              });\n              break;\n          }\n        }\n      } while (token.type !== TokenType.EOF);\n\n      if (this._stack.length > initialStackSize) {\n        this._throw(\"Unexpected EOF: sections not closed: \" + this._stack.slice(initialStackSize).map(function (n) {\n          return \"'\" + n.name + \"'\";\n        }).join(\", \"));\n      } else if (this._stack.length < initialStackSize) {\n        this._throw(\"Internal error.\");\n      }\n    }\n  }, {\n    key: \"_throw\",\n    value: function _throw(message, location) {\n      location = location || this._lastToken.location;\n      var e = new Error(message);\n      e.filename = location.filename;\n      e.location = location;\n      throw e;\n    }\n  }, {\n    key: \"_pushParent\",\n    value: function _pushParent(node) {\n      this._addNodeToken(node);\n      node.children = [];\n      this._stack.push(node);\n    }\n  }, {\n    key: \"_popParent\",\n    value: function _popParent() {\n      return this._stack.pop();\n    }\n  }, {\n    key: \"_handleSectionOpen\",\n    value: function _handleSectionOpen(token) {\n      var inverted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n      var name = token.name;\n      var location = token.location;\n\n      this._pushParent({\n        type: NodeType.SECTION,\n        name: name,\n        inverted: inverted,\n        location: location\n      });\n    }\n  }, {\n    key: \"_handleSectionClose\",\n    value: function _handleSectionClose(token) {\n      var name = token.name;\n      var location = token.location;\n\n      var section = this._popParent();\n      if (section.type !== NodeType.SECTION) {\n        this._throw(\"Unexpected SECTION_CLOSE: '\" + name + \"'\");\n      }\n\n      if (section.name !== name) {\n        this._throw(\"Unexpected SECTION_CLOSE: '\" + name + \"', current section: '\" + section.name + \"'\");\n      }\n\n      section.raw = this._src.slice(section.location.endIndex, location.index);\n      section.location = this._makeLocation(section.location, token.location);\n\n      this._appendNode(section);\n    }\n  }, {\n    key: \"_handleComment\",\n    value: function _handleComment(token) {\n      var content = token.content;\n      var location = token.location;\n\n      this._appendNode({\n        type: NodeType.COMMENT,\n        content: content,\n        location: this._makeLocation(location)\n      });\n    }\n  }]);\n\n  return Parser;\n})();\n\nexports.Parser = Parser;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; })();\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _extension = __webpack_require__(0);\n\nvar _helpers = __webpack_require__(2);\n\nvar STATE_NONE = \"STATE_NONE\";\nvar STATE_EOF = \"STATE_EOF\";\nvar STATE_TEXT = \"STATE_TEXT\";\nvar STATE_TEXT_BREAK = \"STATE_TEXT_BREAK\";\nvar STATE_TAG = \"STATE_TAG\";\n\nvar DELIMITER_LEFT = 0;\nvar DELIMITER_RIGHT = 1;\n\nvar Tokenizer = (function () {\n  function Tokenizer(src) {\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Tokenizer);\n\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 1;\n    this._column = 1;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n  }\n\n  _createClass(Tokenizer, [{\n    key: \"getNextToken\",\n    value: function getNextToken() {\n      if (this._tokens.length > 0) {\n        return this._tokens.shift();\n      }\n\n      var done = false;\n      var matched = false;\n      do {\n        //console.log(this._state, this._tokens);\n        if (this._error !== null) {\n          return null;\n        }\n\n        if (this._state !== STATE_NONE) {\n          matched = true;\n          this._markTokenStartLocation();\n        }\n\n        switch (this._state) {\n          case STATE_NONE:\n            this._read();\n            break;\n\n          case STATE_EOF:\n            this._handleEOF();\n            done = true;\n            break;\n\n          case STATE_TEXT:\n            this._handleText();\n            break;\n\n          case STATE_TEXT_BREAK:\n            this._handleTextBreak();\n            done = true;\n            break;\n\n          case STATE_TAG:\n            this._handleTag();\n            break;\n        }\n\n        if (matched && !this._error) {\n          this._markTokenEndLocation();\n          matched = false;\n        }\n\n        if (this._state === STATE_NONE) {\n          if (this._char === null) {\n            this._state = STATE_EOF;\n          } else if (this._char === \"\\n\") {\n            this._state = STATE_TEXT_BREAK;\n          } else if (this._isDelimiter(DELIMITER_LEFT)) {\n            this._state = STATE_TAG;\n          } else {\n            this._state = STATE_TEXT;\n          }\n        }\n      } while (!done);\n\n      return this._error === null ? this._tokens.shift() : null;\n    }\n\n    // Handlers\n\n  }, {\n    key: \"_handleEOF\",\n    value: function _handleEOF() {\n      this._handleStandaloneTag();\n      this._makeToken({\n        type: TokenType.EOF\n      });\n    }\n  }, {\n    key: \"_handleTag\",\n    value: function _handleTag() {\n      var _delimiters = _slicedToArray(this._delimiters, 2);\n\n      var left = _delimiters[0];\n      var right = _delimiters[1];\n\n      this._skip(left.length);\n      this._skipAllWhitespaces();\n\n      if (this._char === null) {\n        this._setError(\"Unclosed tag.\");\n      } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n        this._handleEmptyTag();\n      } else {\n        var tagTypeChar = this._char;\n        if (tagTypeChar === \"{\") {\n          this._handleVariableCurly();\n        } else {\n          var tagContentStart = this._index - 1;\n          //read content\n          while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n            this._read();\n          }\n\n          if (this._char === null) {\n            this._setError(\"Unclosed tag.\");\n          } else {\n            var content = this._src.slice(tagContentStart, this._index - 1);\n            switch (tagTypeChar) {\n              case \">\":\n                this._handleSimpleTag(TokenType.PARTIAL, content);\n                break;\n              case \"^\":\n                this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);\n                break;\n              case \"#\":\n                this._handleSimpleTag(TokenType.SECTION_OPEN, content);\n                break;\n              case \"/\":\n                this._handleSimpleTag(TokenType.SECTION_CLOSE, content);\n                break;\n\n              case \"!\":\n                this._handleComment(content.substr(1));\n                break;\n\n              case \"=\":\n                this._handleDelimiterChange(content);\n                break;\n              case \"&\":\n                this._handleVariable(content.substr(1), true);\n                break;\n              default:\n                this._handleVariable(content);\n                break;\n            }\n          }\n        }\n      }\n      if (this._error === null) {\n        //eat right\n        for (var i = 0; i < right.length; i++) {\n          this._read();\n        }\n      }\n\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleDelimiterChange\",\n    value: function _handleDelimiterChange(content) {\n      var newDelimiters = extractNewDelimiters(content);\n      if (newDelimiters === null) {\n        this._setError(\"Invalid change delimiter syntax.\");\n      } else {\n        var _newDelimiters = _slicedToArray(newDelimiters, 2);\n\n        var left = _newDelimiters[0];\n        var right = _newDelimiters[1];\n\n        this._delimiters = newDelimiters;\n        this._makeToken({\n          type: TokenType.DELIMITER_CHANGE,\n          delimiters: [left, right]\n        });\n      }\n    }\n  }, {\n    key: \"_handleSimpleTag\",\n    value: function _handleSimpleTag(type, content) {\n      this._makeToken({ type: type, name: content.substr(1).trim() });\n    }\n  }, {\n    key: \"_handleComment\",\n    value: function _handleComment(content) {\n      this._makeToken({\n        type: TokenType.COMMENT,\n        content: content\n      });\n    }\n  }, {\n    key: \"_handleVariableCurly\",\n    value: function _handleVariableCurly() {\n      this._read(); //eat '{'\n      var begin = this._index - 1;\n      var d = this._distance(\"}\");\n      if (d === -1) {\n        this._setError(\"Unclosed variable tag: missingright curly.\");\n      } else {\n        var content = this._src.slice(begin, begin + d);\n        this._skip(d + 1); //skip '}'\n        this._skipAllWhitespaces();\n        if (!this._isDelimiter(DELIMITER_RIGHT)) {\n          this._setError(\"Unclosed variable: missing right delimiter.\");\n        } else {\n          this._makeToken({\n            type: TokenType.UNESCAPED_VARIABLE,\n            name: content.trim()\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_handleEmptyTag\",\n    value: function _handleEmptyTag() {\n      this._makeToken({\n        type: TokenType.VARIABLE,\n        name: \"\"\n      });\n    }\n  }, {\n    key: \"_handleVariable\",\n    value: function _handleVariable(content, unescaped) {\n      this._makeToken({\n        type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n        name: content.trim()\n      });\n    }\n  }, {\n    key: \"_handleText\",\n    value: function _handleText() {\n      var done = false;\n      var index = this._index - 1;\n      var length = 0;\n      do {\n        var c = this._char;\n\n        if (c === null || c === \"\\n\" || this._isDelimiter(DELIMITER_LEFT)) {\n          done = true;\n        } else {\n          length++;\n        }\n\n        if (!done) {\n          this._read();\n        }\n      } while (!done);\n\n      this._makeToken({\n        type: TokenType.TEXT,\n        text: this._src.slice(index, index + length)\n      });\n\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleTextBreak\",\n    value: function _handleTextBreak() {\n      this._makeToken({\n        type: TokenType.TEXT,\n        text: \"\\n\"\n      });\n      this._read();\n      this._handleStandaloneTag();\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleStandaloneTag\",\n    value: function _handleStandaloneTag() {\n      this._tokens = (0, _helpers.trimStandaloneToken)(this._tokens);\n    }\n\n    // Helpers\n  }, {\n    key: \"_dump\",\n    value: function _dump() {\n      var t = arguments.length <= 0 || arguments[0] === undefined ? \"\" : arguments[0];\n\n      console.log(t + \">\" + this._src.slice(this._index - 1));\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      if (this._index < this._src.length) {\n        if (this._char === \"\\n\") {\n          this._line++;\n          this._column = 0;\n        } else {\n          this._column++;\n        }\n\n        this._char = this._src[this._index];\n        this._index++;\n      } else {\n        this._char = null;\n      }\n    }\n  }, {\n    key: \"_peek\",\n    value: function _peek() {\n      if (this._index < this._src.length - 1) {\n        return this._src[this._index];\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_skip\",\n    value: function _skip(n) {\n      for (var i = 0; i < n; i++) {\n        this._read();\n      }\n    }\n  }, {\n    key: \"_distance\",\n    value: function _distance(c) {\n      for (var i = this._index; i < this._src.length; i++) {\n        if (this._src[i] === c) {\n          return i - this._index + 1;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"_skipAllWhitespaces\",\n    value: function _skipAllWhitespaces() {\n      while (this._isWhitespace()) {\n        this._read();\n      }\n    }\n  }, {\n    key: \"_markTokenStartLocation\",\n    value: function _markTokenStartLocation() {\n      this._location.index = this._index - 1;\n      this._location.line = this._line;\n      this._location.column = this._column;\n    }\n  }, {\n    key: \"_markTokenEndLocation\",\n    value: function _markTokenEndLocation() {\n      var token = this._tokens[this._tokens.length - 1];\n      token.location.endIndex = this._index - 1;\n      token.location.endLine = this._line;\n      token.location.endColumn = this._column;\n    }\n  }, {\n    key: \"_isWhitespace\",\n    value: function _isWhitespace() {\n      return (/\\s/.test(this._char)\n      );\n    }\n  }, {\n    key: \"_isDelimiter\",\n    value: function _isDelimiter(d) {\n      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      var delimiter = this._delimiters[d];\n      var pos = this._index - 1 + offset;\n      return this._src.slice(pos, pos + delimiter.length) === delimiter;\n    }\n  }, {\n    key: \"_makeToken\",\n    value: function _makeToken(token) {\n      token.filename = this._filename;\n      var _location = this._location;\n      var index = _location.index;\n      var line = _location.line;\n      var column = _location.column;\n\n      token.location = {\n        filename: this._filename,\n        index: index,\n        line: line,\n        column: column\n      };\n      if (this._extensions.length) {\n        try {\n          this._extensions.forEach(function (ext) {\n            token = ext.transformToken(token);\n          });\n        } catch (e) {\n          this._setError(e.message);\n          return;\n        }\n      }\n      this._tokens.push(token);\n    }\n  }, {\n    key: \"_setError\",\n    value: function _setError(message) {\n      var error = new Error(message);\n      error.filename = this._filename;\n      error.index = this._index - 1;\n      error.line = this._line;\n      error.column = this._column;\n      this._error = error;\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      return this._error;\n    }\n  }]);\n\n  return Tokenizer;\n})();\n\nexports.Tokenizer = Tokenizer;\n\nvar R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  var matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// https://github.com/mustache/spec/pull/75\n\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _extension = __webpack_require__(0);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _token2 = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token2);\n\nvar PARENT = \"Inheritance.PARENT\";\nvar BLOCK = \"Inheritance.BLOCK\";\nvar LEAVE_SCOPE = \"Inheritance.LEAVE_SCOPE\";\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nvar Inheritance = (function (_Extension) {\n  _inherits(Inheritance, _Extension);\n\n  function Inheritance() {\n    _classCallCheck(this, Inheritance);\n\n    _get(Object.getPrototypeOf(Inheritance.prototype), \"constructor\", this).call(this);\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  _createClass(Inheritance, [{\n    key: \"transformToken\",\n    value: function transformToken(token) {\n      var _token = token;\n      var type = _token.type;\n      var name = _token.name;\n      var location = _token.location;\n\n      switch (type) {\n        case TokenType.VARIABLE:\n          if (name) {\n            if (name[0] === \"<\") {\n              if (name.length === 1) {\n                throw new Error(\"Parent partial name expected\");\n              }\n              token = {\n                type: PARENT,\n                name: name.slice(1),\n                location: location\n              };\n            } else if (name[0] === \"$\") {\n              if (name.length === 1) {\n                throw new Error(\"Block name expected\");\n              }\n              token = {\n                type: BLOCK,\n                name: name.slice(1),\n                location: location\n              };\n            }\n          }\n          break;\n      }\n      return token;\n    }\n  }, {\n    key: \"handleToken\",\n    value: function handleToken(token, parserContext) {\n      var handled = false;\n      var name = token.name;\n      var location = token.location;\n      var type = token.type;\n\n      switch (type) {\n        case PARENT:\n          parserContext.pushParent({\n            type: PARENT,\n            name: name,\n            location: location\n          });\n          handled = true;\n          break;\n\n        case BLOCK:\n          this._pushBlock({\n            type: BLOCK,\n            content: \"\",\n            name: name,\n            location: location\n          }, parserContext);\n          break;\n\n        case TokenType.SECTION_CLOSE:\n          var tagNode = parserContext.parentNode;\n          if (isInheritanceTagType(tagNode.type) && tagNode.name !== name) {\n            parserContext[\"throw\"](\"Unexpected tag close '\" + name + \"', current tag: '\" + tagNode.name + \"'\");\n          }\n          if (isInheritanceTagType(tagNode.type)) {\n            if (tagNode.type === BLOCK) {\n              var content = parserContext.src.slice(tagNode.location.endIndex, location.index);\n              tagNode.content = content;\n            }\n\n            parserContext.popParent();\n            tagNode.location.endIndex = location.endIndex;\n            tagNode.location.endLine = location.endLine;\n            parserContext.appendNode(tagNode);\n\n            //TODO move this to visit, handle whitespaces after Parent close tag.\n            var firstLine = tagNode.location.line;\n            var firstBlock = tagNode.children.find(function (c) {\n              return c.type === BLOCK;\n            });\n            if (firstBlock && firstBlock.location.line === firstLine) {\n              for (var i = 0; i < firstBlock.children.length; i++) {\n                var blockNode = firstBlock.children[i];\n                if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n                  blockNode.text = \"\";\n                } else {\n                  break;\n                }\n              }\n            }\n\n            handled = true;\n          }\n          break;\n      }\n      return handled;\n    }\n  }, {\n    key: \"handleNode\",\n    value: function handleNode(node, rendererContext) {\n      var top = rendererContext.top;\n      this._checkTop(top);\n\n      switch (node.type) {\n        case PARENT:\n          this._handleParent(node, rendererContext);\n          return true;\n\n        case BLOCK:\n          this._handleBlock(node, rendererContext);\n          return true;\n\n        case LEAVE_SCOPE:\n          this._blocks = null;\n          return true;\n      }\n    }\n  }, {\n    key: \"_pushBlock\",\n    value: function _pushBlock(node, parserContext) {\n      var parent = parserContext.findParentNode(function (parent) {\n        return parent.type === BLOCK && parent.name === node.name;\n      });\n      if (parent) {\n        parserContext[\"throw\"](\"Recursive block: '\" + node.name + \"'\");\n      }\n      parserContext.pushParent(node);\n    }\n  }, {\n    key: \"_handleParent\",\n    value: function _handleParent(node, rendererContext) {\n      var name = node.name;\n      var location = node.location;\n\n      var top = rendererContext.top;\n\n      this._pushParent(name, top);\n\n      if (this._blocks === null) {\n        rendererContext.pushNodes([{\n          type: LEAVE_SCOPE\n        }]);\n        this._blocks = {};\n      }\n\n      //find all blocks defined in parent\n      var blocks = {};\n      node.children.forEach(function (child) {\n        if (child.type === BLOCK) {\n          var blockName = child.name;\n          blocks[blockName] = child;\n        }\n      });\n      if (Object.keys(blocks).length) {\n        this._setDefaultBlocks(blocks);\n      }\n\n      rendererContext.pushNode({\n        type: TokenType.PARTIAL,\n        name: name,\n        location: location,\n        indent: node.indent\n      });\n    }\n  }, {\n    key: \"_handleBlock\",\n    value: function _handleBlock(node, rendererContext) {\n      var name = node.name;\n\n      var defaultBlock = this._getDefaultBlock(name);\n      if (defaultBlock) {\n        rendererContext.pushNodes(defaultBlock.children);\n      } else {\n        rendererContext.pushNodes(node.children);\n      }\n    }\n  }, {\n    key: \"_pushParent\",\n    value: function _pushParent(name, top) {\n      return this._parentStack.push({\n        name: name,\n        blocks: {},\n        top: top\n      });\n    }\n  }, {\n    key: \"_checkTop\",\n    value: function _checkTop(top) {\n      var pop = 0;\n      for (var i = this._parentStack.length - 1; i >= 0; i--) {\n        var frame = this._parentStack[i];\n        if (frame.top > top) {\n          pop++;\n        } else {\n          break;\n        }\n      }\n      if (pop > 0) {\n        this._parentStack = this._parentStack.slice(0, this._parentStack.length - pop);\n      }\n    }\n  }, {\n    key: \"_popParent\",\n    value: function _popParent() {\n      return this._parentStack.pop();\n    }\n  }, {\n    key: \"_getDefaultBlock\",\n    value: function _getDefaultBlock(name) {\n      for (var i = 0; i < this._parentStack.length; i++) {\n        var frame = this._parentStack[i];\n        if (name in frame.blocks) {\n          return frame.blocks[name];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_setDefaultBlocks\",\n    value: function _setDefaultBlocks(blocks) {\n      var topFrame = this._parentStack[this._parentStack.length - 1];\n      topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n    }\n  }]);\n\n  return Inheritance;\n})(_extension.Extension);\n\nexports.Inheritance = Inheritance;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _node = __webpack_require__(3);\n\nvar nodeTypes = _interopRequireWildcard(_node);\n\nvar _escapeHtml = __webpack_require__(9);\n\nvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\nvar _parser = __webpack_require__(4);\n\nvar _helpers = __webpack_require__(2);\n\nvar _extension = __webpack_require__(0);\n\nvar REPEATER_NODE_TYPE = \"_REPEATER\";\nvar MAX_PARTIAL_STACK = 100;\nvar MAX_LAMBDA_STACK = 255;\nvar MAX_NODE_COUNT = 30000;\n\nvar RenderContext = (function () {\n  function RenderContext(renderer) {\n    _classCallCheck(this, RenderContext);\n\n    this._renderer = renderer;\n  }\n\n  _createClass(RenderContext, [{\n    key: \"evaluate\",\n    value: function evaluate(name) {\n      return this._renderer._evaluate(name);\n    }\n  }, {\n    key: \"pushNodes\",\n    value: function pushNodes(nodes) {\n      this._renderer._pushNodes(nodes);\n    }\n  }, {\n    key: \"pushNode\",\n    value: function pushNode(node) {\n      this._renderer._pushNode(node);\n    }\n  }, {\n    key: \"pushContext\",\n    value: function pushContext(ctx, sp) {\n      this._renderer._pushContext(ctx, sp);\n    }\n  }, {\n    key: \"appendText\",\n    value: function appendText(text) {\n      this._renderer._out += text;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(src, opts) {\n      return this._renderer._parse(src, opts);\n    }\n  }, {\n    key: \"getParsedPartial\",\n    value: function getParsedPartial(name) {\n      return this._renderer._getParsedPartial(name);\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(message, location) {\n      return this._renderer._throw(message, location);\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._renderer._stack.length;\n    }\n  }, {\n    key: \"result\",\n    get: function get() {\n      return this._renderer._out;\n    }\n  }]);\n\n  return RenderContext;\n})();\n\nvar Renderer = (function () {\n  function Renderer(src) {\n    var _this = this;\n\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Renderer);\n\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    this._filename = opts.filename;\n\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(function (k) {\n        _this._partialCached[k] = _this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = \"\";\n    this._transformNodeResult = function (node, result, nodeResult) {\n      return _this._extensions.reduce(function (r, e) {\n        return e.transformNodeResult(node, result, r);\n      }, nodeResult);\n    };\n  }\n\n  _createClass(Renderer, [{\n    key: \"render\",\n    value: function render(context) {\n      var _this2 = this;\n\n      this._out = \"\";\n      this._stack = [];\n      this._contextStack = [];\n      this._partialStack = [];\n      this._lambdaStack = [];\n\n      this._pushContext(context);\n\n      //push root nodes\n      var rootNode = this._parsed ? this._src : this._parse(this._src, { filename: this._filename });\n      this._stack = rootNode.children.slice(0).reverse();\n\n      var node_count = 0;\n\n      var newline = true;\n\n      var _loop = function () {\n        var top = _this2._stack.length - 1;\n        var node = _this2._stack[top];\n\n        if (node.type !== nodeTypes.TEXT) {\n          node_count++;\n          if (node_count > MAX_NODE_COUNT) {\n            _this2._throw(\"Possible infinity loop detected: last node type is '\" + node.type + \"'\", node.location);\n          }\n        }\n\n        var handled = false;\n        if (_this2._extensions) {\n          _this2._extensions.forEach(function (ext) {\n            if (ext.handleNode(node, _this2._renderContext)) {\n              handled = true;\n            }\n          });\n        }\n\n        if (handled) {\n          _this2._stack.splice(top, 1);\n        } else {\n          var partial = _this2._partialStack.length ? _this2._partialStack[_this2._partialStack.length - 1] : null;\n\n          //insert indent\n          if (node.type in nodeTypes) {\n            if (newline && partial !== null && partial.indent.length > 0) {\n              _this2._out += partial.indent;\n            }\n          }\n\n          var value = undefined;\n          switch (node.type) {\n            case nodeTypes.VARIABLE:\n              value = _this2._evaluate(node.name);\n              if (isFunction(value)) {\n                _this2._popNode();\n                _this2._expandLambda(node, value);\n              } else {\n                if (!!value) {\n                  var result = node.unescaped ? value : (0, _escapeHtml2[\"default\"])(value);\n                  _this2._out += _this2._transformNodeResult(node, _this2._out, result);\n                }\n                _this2._popNode();\n              }\n              break;\n\n            case nodeTypes.SECTION:\n              value = _this2._evaluate(node.name);\n              if (isFunction(value)) {\n                _this2._popNode();\n                _this2._expandLambda(node, value);\n              } else {\n                var isList = Array.isArray(value);\n\n                if (isList && value.length === 0) {\n                  //Empty lists should behave like falsey values.\n                  value = false;\n                  isList = false;\n                }\n\n                var testResult = !!value;\n                if (node.inverted) {\n                  testResult = !testResult;\n                }\n\n                if (testResult) {\n                  if (isList) {\n                    _this2._popNode();\n                    _this2._pushRepeaterNode(value.length, node.children, value);\n                  } else {\n                    _this2._popNode();\n                    _this2._pushContext(value);\n                    _this2._pushNodes(node.children);\n                  }\n                } else {\n                  _this2._popNode();\n                }\n              }\n              break;\n\n            case nodeTypes.TEXT:\n              _this2._out += _this2._transformNodeResult(node, _this2._out, node.text);\n              _this2._popNode();\n              break;\n\n            case nodeTypes.COMMENT:\n              _this2._popNode();\n              break;\n\n            case nodeTypes.PARTIAL:\n              _this2._popNode();\n              _this2._expandPartial(node);\n              break;\n\n            case nodeTypes.DELIMITER_CHANGE:\n              _this2._popNode();\n              _this2._delimiters = node.delimiters.slice(0);\n              break;\n\n            case REPEATER_NODE_TYPE:\n              if (node.count < node.repeat) {\n                var repeatIndex = node.count;\n                if (repeatIndex === 0) {\n                  node.contextIndex = _this2._pushContext(node.contexts[0]);\n                } else {\n                  _this2._replaceContextAt(node.contextIndex, node.contexts[repeatIndex]);\n                }\n                _this2._pushNodes(node.children);\n                node.count++;\n              } else {\n                _this2._popNode();\n              }\n              break;\n\n            default:\n              _this2._popNode();\n              break;\n          }\n        }\n        _this2._checkStacks();\n        newline = _this2._out.length === 0 || _this2._out[_this2._out.length - 1] === \"\\n\";\n      };\n\n      while (this._stack.length > 0) {\n        _loop();\n      }\n\n      return this._extensions.reduce(function (result, ext) {\n        return ext.transformResult(result);\n      }, this._out);\n    }\n  }, {\n    key: \"_parse\",\n    value: function _parse(src) {\n      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      opts.extensions = this._extensions;\n      var parser = new _parser.Parser(opts);\n      return parser.parse(src);\n    }\n  }, {\n    key: \"_pushNodes\",\n    value: function _pushNodes(list) {\n      for (var i = list.length - 1; i >= 0; i--) {\n        this._stack.push(list[i]);\n      }\n    }\n  }, {\n    key: \"_pushNode\",\n    value: function _pushNode(node) {\n      this._stack.push(node);\n    }\n  }, {\n    key: \"_popNode\",\n    value: function _popNode() {\n      this._stack.pop();\n    }\n  }, {\n    key: \"_pushRepeaterNode\",\n    value: function _pushRepeaterNode(repeat, nodes, contexts) {\n      this._stack.push({\n        type: REPEATER_NODE_TYPE,\n        count: 0,\n        repeat: repeat,\n        children: nodes.slice(0),\n        contexts: contexts\n      });\n    }\n  }, {\n    key: \"_pushContext\",\n    value: function _pushContext(context) {\n      var sp = arguments.length <= 1 || arguments[1] === undefined ? this._stack.length : arguments[1];\n\n      if (this._contextStack.length) {\n        sp = Math.min(Math.max(this._contextStack[this._contextStack.length - 1].sp, sp), this._stack.length);\n      }\n      return this._contextStack.push({\n        context: context,\n        sp: sp\n      }) - 1;\n    }\n  }, {\n    key: \"_replaceContextAt\",\n    value: function _replaceContextAt(index, context) {\n      if (index < 0 || index > this._contextStack.length - 1) {\n        throw new RangeError(\"Huz context index out of range.\");\n      }\n      this._contextStack[index].context = context;\n    }\n  }, {\n    key: \"_pushPartial\",\n    value: function _pushPartial(_ref) {\n      var name = _ref.name;\n      var indent = _ref.indent;\n      var location = _ref.location;\n\n      this._partialStack.push({\n        name: name,\n        indent: indent || \"\",\n        location: location,\n        sp: this._stack.length\n      });\n    }\n  }, {\n    key: \"_pushLambda\",\n    value: function _pushLambda(_ref2) {\n      var name = _ref2.name;\n      var location = _ref2.location;\n\n      this._lambdaStack.push({\n        name: name,\n        location: location,\n        sp: this._stack.length\n      });\n    }\n  }, {\n    key: \"_checkStacks\",\n    value: function _checkStacks() {\n      while (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n        this._contextStack.pop();\n      }\n\n      if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n        this._partialStack.pop();\n      }\n\n      if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n        this._lambdaStack.pop();\n      }\n    }\n  }, {\n    key: \"_evaluate\",\n    value: function _evaluate(name) {\n      if (name === \".\") {\n        return this._contextStack[this._contextStack.length - 1].context;\n      }\n\n      var path = name.split(\".\");\n      for (var i = this._contextStack.length - 1; i >= 0; i--) {\n        var context = this._contextStack[i].context;\n        if (context === null || typeof context !== \"object\") {\n          continue;\n        }\n\n        var current = context;\n        var resolved = true;\n        for (var pi = 0; pi < path.length; pi++) {\n          var key = path[pi];\n          if (typeof current === \"object\" && current !== null && current.hasOwnProperty(key)) {\n            current = current[key];\n          } else {\n            resolved = false;\n            break;\n          }\n        }\n\n        if (resolved) {\n          return current;\n        }\n      }\n      return \"\";\n    }\n  }, {\n    key: \"_getParsedPartial\",\n    value: function _getParsedPartial(name) {\n      if (this._partialCached.hasOwnProperty(name)) {\n        return this._partialCached[name];\n      } else {\n        if (!this._partials.hasOwnProperty(name)) {\n          return null;\n        }\n        var ast = this._parse(this._partials[name], { filename: name });\n        var nodes = this._partialCached[name] = ast.children;\n        return nodes;\n      }\n    }\n  }, {\n    key: \"_expandPartial\",\n    value: function _expandPartial(node) {\n      var name = node.name;\n\n      var nodes = this._getParsedPartial(name);\n\n      if (nodes === null) {\n        //The empty string should be used when the named partial is not found.\n        return;\n      }\n\n      this._pushPartial(node);\n\n      if (this._partialStack.length > MAX_PARTIAL_STACK) {\n        this._throw(\"Possible partial short circuit: \" + this._partialStack.map(function (f) {\n          return f.name + \"@\" + f.location.filename + \":\" + (f.location.line + 1);\n        }).concat([name]).join(\" -> \"), node.location);\n      }\n\n      this._pushNodes(nodes);\n    }\n  }, {\n    key: \"_expandLambda\",\n    value: function _expandLambda(node, lambda) {\n      var name = node.name;\n\n      this._pushLambda(node);\n\n      if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n        this._throw(\"Possible lambda short circuit: \" + this._lambdaStack.map(function (f) {\n          return f.name + \"@\" + f.location.filename + \":\" + (f.location.line + 1);\n        }).concat([name]).join(\" -> \"), node.location);\n      }\n\n      var ast = undefined;\n      var skipped = false;\n      if (node.type === nodeTypes.VARIABLE) {\n        var code = lambda();\n        if (code) {\n          //A lambda's return value should parse with the default delimiters.\n          ast = this._parse(\"\" + code, { filename: \"[lambda]\" });\n          if (!node.unescaped) {\n            //Lambda results should be appropriately escaped.\n            (0, _helpers.walk)(ast, function (node) {\n              if (node.type === nodeTypes.TEXT) {\n                node.text = (0, _escapeHtml2[\"default\"])(node.text);\n              }\n            });\n          }\n        } else {\n          skipped = true;\n        }\n      } else if (node.type === nodeTypes.SECTION) {\n        var code = lambda(node.raw);\n        if (code) {\n          //Lambdas used for inverted sections should be considered truthy.\n          //Lambdas used for sections should parse with the current delimiters.\n          ast = this._parse(\"\" + code, {\n            filename: \"[#lambda]\",\n            delimiters: this._delimiters.slice(0)\n          });\n        } else {\n          skipped = true;\n        }\n      }\n\n      if (!skipped) {\n        this._pushNodes(ast.children);\n      }\n    }\n  }, {\n    key: \"_throw\",\n    value: function _throw(message, location) {\n      var e = new Error(message);\n      e.filename = location.filename;\n      e.location = location;\n      throw e;\n    }\n  }]);\n\n  return Renderer;\n})();\n\nexports.Renderer = Renderer;\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == \"[object Function]\";\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.compile = compile;\nexports.render = render;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _parser = __webpack_require__(4);\n\nvar _renderer = __webpack_require__(7);\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _helpers = __webpack_require__(2);\n\nvar Helpers = _interopRequireWildcard(_helpers);\n\nvar _extension = __webpack_require__(0);\n\nvar _extensionsInheritance = __webpack_require__(6);\n\n// import { Section } from \"./extensions/section\";\n\nvar _tokenizer = __webpack_require__(5);\n\nObject.defineProperty(exports, \"Tokenizer\", {\n  enumerable: true,\n  get: function get() {\n    return _tokenizer.Tokenizer;\n  }\n});\nexports.Parser = _parser.Parser;\nexports.Renderer = _renderer.Renderer;\nexports.TokenType = TokenType;\nexports.NodeType = NodeType;\nObject.defineProperty(exports, \"Extension\", {\n  enumerable: true,\n  get: function get() {\n    return _extension.Extension;\n  }\n});\n(0, _extension.register)(_extensionsInheritance.Inheritance);\n// register(Section);\n\nfunction parse(src, opts) {\n  var parser = new _parser.Parser(opts);\n  return parser.parse(src);\n}\n\nfunction compile(src, opts) {\n  return new _renderer.Renderer(src, opts);\n}\n\nfunction render(src, context, opts) {\n  var r = compile(src, opts);\n  return r.render(context);\n}\n\nexports.register = _extension.register;\nexports.Helpers = Helpers;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// huz.js","const registry = [];\n\nexport class Extension {\n  //called by tokenizer\n  transformToken(token) { return token; }\n\n  //called by parser\n  handleToken(token, parserContext) { }\n  visit(root) { return root; }\n  \n  //called by renderer\n  handleNode(node, renderContext) { }\n  transformNodeResult(node, result, nodeResult) { return nodeResult; }\n  transformResult(result) { return result; }\n}\n\nexport function instantiateAll(opts) {\n  return registry.map(ctor => {\n    return new ctor(opts);\n  });\n}\n\nexport function register(constructor) {\n  return registry.push(constructor);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/extension.js","export const EOF                    = 'EOF';\nexport const TEXT                   = 'TEXT';\nexport const PARTIAL                = 'PARTIAL';\nexport const INVERTED_SECTION_OPEN  = 'INVERTED_SECTION_OPEN';\nexport const SECTION_OPEN           = 'SECTION_OPEN';\nexport const SECTION_CLOSE          = 'SECTION_CLOSE';\nexport const UNESCAPED_VARIABLE     = 'UNESCAPED_VARIABLE';\nexport const COMMENT                = 'COMMENT';\nexport const VARIABLE               = 'VARIABLE';\nexport const DELIMITER_CHANGE \t\t\t= 'DELIMITER_CHANGE';\n\n\n// WEBPACK FOOTER //\n// ./src/token.js","import * as TokenType from './token';\n\nexport function walk(root, modifier) {\n  let stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    const node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nexport function visit(root, visitor) {\n  let stack = [root];\n  while (stack.length) {\n    const parent = stack.pop();\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      const modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nexport function trimStandaloneToken(tokens) {\n  const count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  let open = null;\n  let inline = 0;\n  let standalone = true;\n  let indentTokens = [];\n  for (let i = 0; standalone && i < count; i++) {\n    const token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline ++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline ++;\n        }\n        break;\n      default: //section-like tags\n        if (open === null) {\n          open = [token];\n          inline ++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n  \n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    let tailWSNodeCount = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount ++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        let indent = '';\n        indentTokens.forEach(t => { indent += t.text });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return /^\\s*$/.test(str);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/helpers.js","export const ROOT = \"ROOT\";\nexport const VARIABLE = \"VARIABLE\";\nexport const SECTION = \"SECTION\";\nexport const TEXT = \"TEXT\";\nexport const COMMENT = \"COMMENT\";\nexport const PARTIAL = \"PARTIAL\";\nexport const DELIMITER_CHANGE = \"DELIMITER_CHANGE\";\n\n\n\n// WEBPACK FOOTER //\n// ./src/node.js","import * as TokenType from \"./token\";\nimport * as NodeType from \"./node\";\nimport { Tokenizer } from \"./tokenizer\";\nimport { visit } from \"./helpers\";\nimport { instantiateAll } from \"./extension\";\n\nclass ParserContext {\n  constructor(parser) {\n    this._parser = parser;\n  }\n\n  appendNode(node) {\n    this._parser._appendNode(node);\n  }\n\n  pushParent(node) {\n    this._parser._pushParent(node);\n  }\n\n  popParent() {\n    return this._parser._popParent();\n  }\n\n  get filename() {\n    return this._parser._filename;\n  }\n\n  get top() {\n    return this._parser._stack.length;\n  }\n\n  get parentNode() {\n    return this._parser._stack.length > 0\n      ? this._parser._stack[this._parser._stack.length - 1]\n      : null;\n  }\n\n  /// deprecated, use `parentNode` instead\n  get tailNode() {\n    return this.parentNode;\n  }\n\n  get src() {\n    return this._parser._src;\n  }\n\n  findParentNode(f) {\n    for (let i = this._parser._stack.length - 1; i >= 0; i--) {\n      const item = this._parser._stack[i];\n      if (f(item)) {\n        return item;\n      }\n    }\n    return null;\n  }\n\n  throw(message, location) {\n    return this._parser._throw(message, location);\n  }\n}\n\nexport class Parser {\n  constructor(opts = {}) {\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    this._filename = opts.filename || \"\";\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  parse(src) {\n    const rootNode = {\n      type: NodeType.ROOT,\n      children: []\n    };\n    this._src = src;\n    this._stack = [rootNode];\n    this._lastToken = null;\n    this._parseNodes(src);\n\n    if (this._extensions.length > 0) {\n      for (let i = 0; i < this._extensions.length; i++) {\n        this._extensions[i].visit(rootNode);\n      }\n    }\n\n    return rootNode;\n  }\n\n  _addNodeToken(node) {\n    const token = this._lastToken;\n    if (node.tokens) {\n      node.tokens.push(token);\n    } else {\n      node.tokens = [token];\n    }\n  }\n\n  _appendNode(node) {\n    this._addNodeToken(node);\n    node.location.filename = this._filename;\n    this._stack[this._stack.length - 1].children.push(node);\n    return node;\n  }\n\n  _getTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  _clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  _makeLocation(beginLocation, endLocation) {\n    const location = this._clone(beginLocation);\n    if (endLocation) {\n      location.endIndex = endLocation.endIndex;\n      location.endLine = endLocation.endLine;\n    }\n    return location;\n  }\n\n  _parseNodes(src) {\n    let initialStackSize = this._stack.length;\n    let token;\n    const z = new Tokenizer(src, {\n      delimiters: this._delimiters.slice(0),\n      extensions: this._extensions,\n      filename: this._filename\n    });\n\n    do {\n      token = z.getNextToken();\n\n      if (z.error !== null) {\n        throw z.error;\n      }\n\n      this._lastToken = token;\n\n      let handled = false;\n      if (this._extensions) {\n        for (let i = 0; i < this._extensions.length; i++) {\n          const ext = this._extensions[i];\n          if (ext.handleToken(token, this._parserContext) === true) {\n            handled = true;\n            break;\n          }\n        }\n      }\n\n      if (!handled) {\n        switch (token.type) {\n          case TokenType.TEXT:\n            this._appendNode({\n              type: NodeType.TEXT,\n              text: token.text,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.VARIABLE:\n          case TokenType.UNESCAPED_VARIABLE:\n            this._appendNode({\n              type: NodeType.VARIABLE,\n              name: token.name,\n              unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.SECTION_OPEN:\n            this._handleSectionOpen(token);\n            break;\n\n          case TokenType.INVERTED_SECTION_OPEN:\n            this._handleSectionOpen(token, true);\n            break;\n\n          case TokenType.SECTION_CLOSE:\n            this._handleSectionClose(token);\n            break;\n\n          case TokenType.PARTIAL:\n            this._appendNode({\n              type: NodeType.PARTIAL,\n              name: token.name,\n              indent: token.indent,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.COMMENT:\n            this._handleComment(token);\n            break;\n\n          case TokenType.DELIMITER_CHANGE:\n            this._appendNode({\n              type: NodeType.DELIMITER_CHANGE,\n              delimiters: token.delimiters,\n              location: this._makeLocation(token.location)\n            });\n            break;\n        }\n      }\n    } while (token.type !== TokenType.EOF);\n\n    if (this._stack.length > initialStackSize) {\n      this._throw(\n        \"Unexpected EOF: sections not closed: \" +\n          this._stack\n            .slice(initialStackSize)\n            .map(n => `'${n.name}'`)\n            .join(\", \")\n      );\n    } else if (this._stack.length < initialStackSize) {\n      this._throw(\"Internal error.\");\n    }\n  }\n\n  _throw(message, location) {\n    location = location || this._lastToken.location;\n    const e = new Error(message);\n    e.filename = location.filename;\n    e.location = location;\n    throw e;\n  }\n\n  _pushParent(node) {\n    this._addNodeToken(node);\n    node.children = [];\n    this._stack.push(node);\n  }\n\n  _popParent() {\n    return this._stack.pop();\n  }\n\n  _handleSectionOpen(token, inverted = false) {\n    const { name, location } = token;\n    this._pushParent({\n      type: NodeType.SECTION,\n      name,\n      inverted,\n      location\n    });\n  }\n\n  _handleSectionClose(token) {\n    const { name, location } = token;\n    const section = this._popParent();\n    if (section.type !== NodeType.SECTION) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}'`);\n    }\n\n    if (section.name !== name) {\n      this._throw(\n        `Unexpected SECTION_CLOSE: '${name}', current section: '${\n          section.name\n        }'`\n      );\n    }\n\n    section.raw = this._src.slice(section.location.endIndex, location.index);\n    section.location = this._makeLocation(section.location, token.location);\n\n    this._appendNode(section);\n  }\n\n  _handleComment(token) {\n    const { content, location } = token;\n    this._appendNode({\n      type: NodeType.COMMENT,\n      content,\n      location: this._makeLocation(location)\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/parser.js","import * as TokenType from \"./token\";\nimport { instantiateAll } from \"./extension\";\nimport { trimStandaloneToken } from \"./helpers\";\n\nconst STATE_NONE = \"STATE_NONE\";\nconst STATE_EOF = \"STATE_EOF\";\nconst STATE_TEXT = \"STATE_TEXT\";\nconst STATE_TEXT_BREAK = \"STATE_TEXT_BREAK\";\nconst STATE_TAG = \"STATE_TAG\";\n\nconst DELIMITER_LEFT = 0;\nconst DELIMITER_RIGHT = 1;\n\nexport class Tokenizer {\n  constructor(src, opts = {}) {\n    this._extensions = opts.extensions || instantiateAll();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 1;\n    this._column = 1;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  getNextToken() {\n    if (this._tokens.length > 0) {\n      return this._tokens.shift();\n    }\n\n    let done = false;\n    let matched = false;\n    do {\n      //console.log(this._state, this._tokens);\n      if (this._error !== null) {\n        return null;\n      }\n\n      if (this._state !== STATE_NONE) {\n        matched = true;\n        this._markTokenStartLocation();\n      }\n\n      switch (this._state) {\n        case STATE_NONE:\n          this._read();\n          break;\n\n        case STATE_EOF:\n          this._handleEOF();\n          done = true;\n          break;\n\n        case STATE_TEXT:\n          this._handleText();\n          break;\n\n        case STATE_TEXT_BREAK:\n          this._handleTextBreak();\n          done = true;\n          break;\n\n        case STATE_TAG:\n          this._handleTag();\n          break;\n      }\n\n      if (matched && !this._error) {\n        this._markTokenEndLocation();\n        matched = false;\n      }\n\n      if (this._state === STATE_NONE) {\n        if (this._char === null) {\n          this._state = STATE_EOF;\n        } else if (this._char === \"\\n\") {\n          this._state = STATE_TEXT_BREAK;\n        } else if (this._isDelimiter(DELIMITER_LEFT)) {\n          this._state = STATE_TAG;\n        } else {\n          this._state = STATE_TEXT;\n        }\n      }\n    } while (!done);\n\n    return this._error === null ? this._tokens.shift() : null;\n  }\n\n  // Handlers\n\n  _handleEOF() {\n    this._handleStandaloneTag();\n    this._makeToken({\n      type: TokenType.EOF\n    });\n  }\n\n  _handleTag() {\n    const [left, right] = this._delimiters;\n    this._skip(left.length);\n    this._skipAllWhitespaces();\n\n    if (this._char === null) {\n      this._setError(\"Unclosed tag.\");\n    } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n      this._handleEmptyTag();\n    } else {\n      const tagTypeChar = this._char;\n      if (tagTypeChar === \"{\") {\n        this._handleVariableCurly();\n      } else {\n        let tagContentStart = this._index - 1;\n        //read content\n        while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n          this._read();\n        }\n\n        if (this._char === null) {\n          this._setError(\"Unclosed tag.\");\n        } else {\n          const content = this._src.slice(tagContentStart, this._index - 1);\n          switch (tagTypeChar) {\n            case \">\":\n              this._handleSimpleTag(TokenType.PARTIAL, content);\n              break;\n            case \"^\":\n              this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);\n              break;\n            case \"#\":\n              this._handleSimpleTag(TokenType.SECTION_OPEN, content);\n              break;\n            case \"/\":\n              this._handleSimpleTag(TokenType.SECTION_CLOSE, content);\n              break;\n\n            case \"!\":\n              this._handleComment(content.substr(1));\n              break;\n\n            case \"=\":\n              this._handleDelimiterChange(content);\n              break;\n            case \"&\":\n              this._handleVariable(content.substr(1), true);\n              break;\n            default:\n              this._handleVariable(content);\n              break;\n          }\n        }\n      }\n    }\n    if (this._error === null) {\n      //eat right\n      for (let i = 0; i < right.length; i++) {\n        this._read();\n      }\n    }\n\n    this._state = STATE_NONE;\n  }\n\n  _handleDelimiterChange(content) {\n    const newDelimiters = extractNewDelimiters(content);\n    if (newDelimiters === null) {\n      this._setError(\"Invalid change delimiter syntax.\");\n    } else {\n      const [left, right] = newDelimiters;\n      this._delimiters = newDelimiters;\n      this._makeToken({\n        type: TokenType.DELIMITER_CHANGE,\n        delimiters: [left, right]\n      });\n    }\n  }\n\n  _handleSimpleTag(type, content) {\n    this._makeToken({ type, name: content.substr(1).trim() });\n  }\n\n  _handleComment(content) {\n    this._makeToken({\n      type: TokenType.COMMENT,\n      content\n    });\n  }\n\n  _handleVariableCurly() {\n    this._read(); //eat '{'\n    const begin = this._index - 1;\n    const d = this._distance(\"}\");\n    if (d === -1) {\n      this._setError(\"Unclosed variable tag: missingright curly.\");\n    } else {\n      const content = this._src.slice(begin, begin + d);\n      this._skip(d + 1); //skip '}'\n      this._skipAllWhitespaces();\n      if (!this._isDelimiter(DELIMITER_RIGHT)) {\n        this._setError(\"Unclosed variable: missing right delimiter.\");\n      } else {\n        this._makeToken({\n          type: TokenType.UNESCAPED_VARIABLE,\n          name: content.trim()\n        });\n      }\n    }\n  }\n\n  _handleEmptyTag() {\n    this._makeToken({\n      type: TokenType.VARIABLE,\n      name: \"\"\n    });\n  }\n\n  _handleVariable(content, unescaped) {\n    this._makeToken({\n      type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n      name: content.trim()\n    });\n  }\n\n  _handleText() {\n    let done = false;\n    let index = this._index - 1;\n    let length = 0;\n    do {\n      const c = this._char;\n\n      if (c === null || c === \"\\n\" || this._isDelimiter(DELIMITER_LEFT)) {\n        done = true;\n      } else {\n        length++;\n      }\n\n      if (!done) {\n        this._read();\n      }\n    } while (!done);\n\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: this._src.slice(index, index + length)\n    });\n\n    this._state = STATE_NONE;\n  }\n\n  _handleTextBreak() {\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: \"\\n\"\n    });\n    this._read();\n    this._handleStandaloneTag();\n    this._state = STATE_NONE;\n  }\n\n  _handleStandaloneTag() {\n    this._tokens = trimStandaloneToken(this._tokens);\n  }\n\n  // Helpers\n  _dump(t = \"\") {\n    console.log(t + \">\" + this._src.slice(this._index - 1));\n  }\n\n  _read() {\n    if (this._index < this._src.length) {\n      if (this._char === \"\\n\") {\n        this._line++;\n        this._column = 0;\n      } else {\n        this._column++;\n      }\n\n      this._char = this._src[this._index];\n      this._index++;\n    } else {\n      this._char = null;\n    }\n  }\n\n  _peek() {\n    if (this._index < this._src.length - 1) {\n      return this._src[this._index];\n    } else {\n      return null;\n    }\n  }\n\n  _skip(n) {\n    for (let i = 0; i < n; i++) {\n      this._read();\n    }\n  }\n\n  _distance(c) {\n    for (let i = this._index; i < this._src.length; i++) {\n      if (this._src[i] === c) {\n        return i - this._index + 1;\n      }\n    }\n    return -1;\n  }\n\n  _skipAllWhitespaces() {\n    while (this._isWhitespace()) {\n      this._read();\n    }\n  }\n\n  _markTokenStartLocation() {\n    this._location.index = this._index - 1;\n    this._location.line = this._line;\n    this._location.column = this._column;\n  }\n\n  _markTokenEndLocation() {\n    const token = this._tokens[this._tokens.length - 1];\n    token.location.endIndex = this._index - 1;\n    token.location.endLine = this._line;\n    token.location.endColumn = this._column;\n  }\n\n  _isWhitespace() {\n    return /\\s/.test(this._char);\n  }\n\n  _isDelimiter(d, offset = 0) {\n    const delimiter = this._delimiters[d];\n    const pos = this._index - 1 + offset;\n    return this._src.slice(pos, pos + delimiter.length) === delimiter;\n  }\n\n  _makeToken(token) {\n    token.filename = this._filename;\n    const { index, line, column } = this._location;\n    token.location = {\n      filename: this._filename,\n      index,\n      line,\n      column\n    };\n    if (this._extensions.length) {\n      try {\n        this._extensions.forEach(ext => {\n          token = ext.transformToken(token);\n        });\n      } catch (e) {\n        this._setError(e.message);\n        return;\n      }\n    }\n    this._tokens.push(token);\n  }\n\n  _setError(message) {\n    const error = new Error(message);\n    error.filename = this._filename;\n    error.index = this._index - 1;\n    error.line = this._line;\n    error.column = this._column;\n    this._error = error;\n  }\n}\n\nconst R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  const matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tokenizer.js","// https://github.com/mustache/spec/pull/75\n\nimport { Extension, register } from \"../extension\";\nimport * as NodeType from \"../node\";\nimport * as TokenType from \"../token\";\n\nconst PARENT = \"Inheritance.PARENT\";\nconst BLOCK = \"Inheritance.BLOCK\";\nconst LEAVE_SCOPE = \"Inheritance.LEAVE_SCOPE\";\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nexport class Inheritance extends Extension {\n  constructor() {\n    super();\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  transformToken(token) {\n    const { type, name, location } = token;\n    switch (type) {\n      case TokenType.VARIABLE:\n        if (name) {\n          if (name[0] === \"<\") {\n            if (name.length === 1) {\n              throw new Error(\"Parent partial name expected\");\n            }\n            token = {\n              type: PARENT,\n              name: name.slice(1),\n              location\n            };\n          } else if (name[0] === \"$\") {\n            if (name.length === 1) {\n              throw new Error(\"Block name expected\");\n            }\n            token = {\n              type: BLOCK,\n              name: name.slice(1),\n              location\n            };\n          }\n        }\n        break;\n    }\n    return token;\n  }\n\n  handleToken(token, parserContext) {\n    let handled = false;\n    const { name, location, type } = token;\n    switch (type) {\n      case PARENT:\n        parserContext.pushParent({\n          type: PARENT,\n          name,\n          location\n        });\n        handled = true;\n        break;\n\n      case BLOCK:\n        this._pushBlock(\n          {\n            type: BLOCK,\n            content: \"\",\n            name,\n            location\n          },\n          parserContext\n        );\n        break;\n\n      case TokenType.SECTION_CLOSE:\n        const tagNode = parserContext.parentNode;\n        if (isInheritanceTagType(tagNode.type) && tagNode.name !== name) {\n          parserContext.throw(\n            `Unexpected tag close '${name}', current tag: '${tagNode.name}'`\n          );\n        }\n        if (isInheritanceTagType(tagNode.type)) {\n          if (tagNode.type === BLOCK) {\n            const content = parserContext.src.slice(\n              tagNode.location.endIndex,\n              location.index\n            );\n            tagNode.content = content;\n          }\n\n          parserContext.popParent();\n          tagNode.location.endIndex = location.endIndex;\n          tagNode.location.endLine = location.endLine;\n          parserContext.appendNode(tagNode);\n\n          //TODO move this to visit, handle whitespaces after Parent close tag.\n          const firstLine = tagNode.location.line;\n          const firstBlock = tagNode.children.find(c => c.type === BLOCK);\n          if (firstBlock && firstBlock.location.line === firstLine) {\n            for (let i = 0; i < firstBlock.children.length; i++) {\n              const blockNode = firstBlock.children[i];\n              if (\n                blockNode.type === NodeType.TEXT &&\n                /^\\s*$/.test(blockNode.text)\n              ) {\n                blockNode.text = \"\";\n              } else {\n                break;\n              }\n            }\n          }\n\n          handled = true;\n        }\n        break;\n    }\n    return handled;\n  }\n\n  handleNode(node, rendererContext) {\n    const top = rendererContext.top;\n    this._checkTop(top);\n\n    switch (node.type) {\n      case PARENT:\n        this._handleParent(node, rendererContext);\n        return true;\n\n      case BLOCK:\n        this._handleBlock(node, rendererContext);\n        return true;\n\n      case LEAVE_SCOPE:\n        this._blocks = null;\n        return true;\n    }\n  }\n\n  _pushBlock(node, parserContext) {\n    const parent = parserContext.findParentNode(\n      parent => parent.type === BLOCK && parent.name === node.name\n    );\n    if (parent) {\n      parserContext.throw(`Recursive block: '${node.name}'`);\n    }\n    parserContext.pushParent(node);\n  }\n\n  _handleParent(node, rendererContext) {\n    const { name, location } = node;\n    const top = rendererContext.top;\n\n    this._pushParent(name, top);\n\n    if (this._blocks === null) {\n      rendererContext.pushNodes([\n        {\n          type: LEAVE_SCOPE\n        }\n      ]);\n      this._blocks = {};\n    }\n\n    //find all blocks defined in parent\n    const blocks = {};\n    node.children.forEach(child => {\n      if (child.type === BLOCK) {\n        const blockName = child.name;\n        blocks[blockName] = child;\n      }\n    });\n    if (Object.keys(blocks).length) {\n      this._setDefaultBlocks(blocks);\n    }\n\n    rendererContext.pushNode({\n      type: TokenType.PARTIAL,\n      name,\n      location,\n      indent: node.indent\n    });\n  }\n\n  _handleBlock(node, rendererContext) {\n    const { name } = node;\n    const defaultBlock = this._getDefaultBlock(name);\n    if (defaultBlock) {\n      rendererContext.pushNodes(defaultBlock.children);\n    } else {\n      rendererContext.pushNodes(node.children);\n    }\n  }\n\n  _pushParent(name, top) {\n    return this._parentStack.push({\n      name,\n      blocks: {},\n      top\n    });\n  }\n\n  _checkTop(top) {\n    let pop = 0;\n    for (let i = this._parentStack.length - 1; i >= 0; i--) {\n      const frame = this._parentStack[i];\n      if (frame.top > top) {\n        pop++;\n      } else {\n        break;\n      }\n    }\n    if (pop > 0) {\n      this._parentStack = this._parentStack.slice(\n        0,\n        this._parentStack.length - pop\n      );\n    }\n  }\n\n  _popParent() {\n    return this._parentStack.pop();\n  }\n\n  _getDefaultBlock(name) {\n    for (let i = 0; i < this._parentStack.length; i++) {\n      const frame = this._parentStack[i];\n      if (name in frame.blocks) {\n        return frame.blocks[name];\n      }\n    }\n    return null;\n  }\n\n  _setDefaultBlocks(blocks) {\n    const topFrame = this._parentStack[this._parentStack.length - 1];\n    topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/extensions/inheritance.js","import * as nodeTypes from \"./node\";\nimport escapeHTML from \"escape-html\";\nimport { Parser } from \"./parser\";\nimport { walk, visit } from \"./helpers\";\nimport { instantiateAll } from \"./extension\";\n\nconst REPEATER_NODE_TYPE = \"_REPEATER\";\nconst MAX_PARTIAL_STACK = 100;\nconst MAX_LAMBDA_STACK = 255;\nconst MAX_NODE_COUNT = 30000;\n\nclass RenderContext {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n\n  get top() {\n    return this._renderer._stack.length;\n  }\n\n  get result() {\n    return this._renderer._out;\n  }\n\n  evaluate(name) {\n    return this._renderer._evaluate(name);\n  }\n\n  pushNodes(nodes) {\n    this._renderer._pushNodes(nodes);\n  }\n\n  pushNode(node) {\n    this._renderer._pushNode(node);\n  }\n\n  pushContext(ctx, sp) {\n    this._renderer._pushContext(ctx, sp);\n  }\n\n  appendText(text) {\n    this._renderer._out += text;\n  }\n\n  parse(src, opts) {\n    return this._renderer._parse(src, opts);\n  }\n\n  getParsedPartial(name) {\n    return this._renderer._getParsedPartial(name);\n  }\n\n  throw(message, location) {\n    return this._renderer._throw(message, location);\n  }\n}\n\nexport class Renderer {\n  constructor(src, opts = {}) {\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    this._filename = opts.filename;\n\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(k => {\n        this._partialCached[k] = this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = \"\";\n    this._transformNodeResult = (node, result, nodeResult) =>\n      this._extensions.reduce(\n        (r, e) => e.transformNodeResult(node, result, r),\n        nodeResult\n      );\n  }\n\n  render(context) {\n    this._out = \"\";\n    this._stack = [];\n    this._contextStack = [];\n    this._partialStack = [];\n    this._lambdaStack = [];\n\n    this._pushContext(context);\n\n    //push root nodes\n    const rootNode = this._parsed\n      ? this._src\n      : this._parse(this._src, { filename: this._filename });\n    this._stack = rootNode.children.slice(0).reverse();\n\n    let node_count = 0;\n\n    let newline = true;\n    while (this._stack.length > 0) {\n      const top = this._stack.length - 1;\n      const node = this._stack[top];\n\n      if (node.type !== nodeTypes.TEXT) {\n        node_count++;\n        if (node_count > MAX_NODE_COUNT) {\n          this._throw(\n            `Possible infinity loop detected: last node type is '${node.type}'`,\n            node.location\n          );\n        }\n      }\n\n      let handled = false;\n      if (this._extensions) {\n        this._extensions.forEach(ext => {\n          if (ext.handleNode(node, this._renderContext)) {\n            handled = true;\n          }\n        });\n      }\n\n      if (handled) {\n        this._stack.splice(top, 1);\n      } else {\n        const partial = this._partialStack.length\n          ? this._partialStack[this._partialStack.length - 1]\n          : null;\n\n        //insert indent\n        if (node.type in nodeTypes) {\n          if (newline && partial !== null && partial.indent.length > 0) {\n            this._out += partial.indent;\n          }\n        }\n\n        let value;\n        switch (node.type) {\n          case nodeTypes.VARIABLE:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              if (!!value) {\n                const result = node.unescaped ? value : escapeHTML(value);\n                this._out += this._transformNodeResult(node, this._out, result);\n              }\n              this._popNode();\n            }\n            break;\n\n          case nodeTypes.SECTION:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              let isList = Array.isArray(value);\n\n              if (isList && value.length === 0) {\n                //Empty lists should behave like falsey values.\n                value = false;\n                isList = false;\n              }\n\n              let testResult = !!value;\n              if (node.inverted) {\n                testResult = !testResult;\n              }\n\n              if (testResult) {\n                if (isList) {\n                  this._popNode();\n                  this._pushRepeaterNode(value.length, node.children, value);\n                } else {\n                  this._popNode();\n                  this._pushContext(value);\n                  this._pushNodes(node.children);\n                }\n              } else {\n                this._popNode();\n              }\n            }\n            break;\n\n          case nodeTypes.TEXT:\n            this._out += this._transformNodeResult(node, this._out, node.text);\n            this._popNode();\n            break;\n\n          case nodeTypes.COMMENT:\n            this._popNode();\n            break;\n\n          case nodeTypes.PARTIAL:\n            this._popNode();\n            this._expandPartial(node);\n            break;\n\n          case nodeTypes.DELIMITER_CHANGE:\n            this._popNode();\n            this._delimiters = node.delimiters.slice(0);\n            break;\n\n          case REPEATER_NODE_TYPE:\n            if (node.count < node.repeat) {\n              const repeatIndex = node.count;\n              if (repeatIndex === 0) {\n                node.contextIndex = this._pushContext(node.contexts[0]);\n              } else {\n                this._replaceContextAt(\n                  node.contextIndex,\n                  node.contexts[repeatIndex]\n                );\n              }\n              this._pushNodes(node.children);\n              node.count++;\n            } else {\n              this._popNode();\n            }\n            break;\n\n          default:\n            this._popNode();\n            break;\n        }\n      }\n      this._checkStacks();\n      newline =\n        this._out.length === 0 || this._out[this._out.length - 1] === \"\\n\";\n    }\n\n    return this._extensions.reduce(\n      (result, ext) => ext.transformResult(result),\n      this._out\n    );\n  }\n\n  _parse(src, opts = {}) {\n    opts.extensions = this._extensions;\n    const parser = new Parser(opts);\n    return parser.parse(src);\n  }\n\n  _pushNodes(list) {\n    for (let i = list.length - 1; i >= 0; i--) {\n      this._stack.push(list[i]);\n    }\n  }\n\n  _pushNode(node) {\n    this._stack.push(node);\n  }\n\n  _popNode() {\n    this._stack.pop();\n  }\n\n  _pushRepeaterNode(repeat, nodes, contexts) {\n    this._stack.push({\n      type: REPEATER_NODE_TYPE,\n      count: 0,\n      repeat,\n      children: nodes.slice(0),\n      contexts\n    });\n  }\n\n  _pushContext(context, sp = this._stack.length) {\n    if (this._contextStack.length) {\n      sp = Math.min(\n        Math.max(this._contextStack[this._contextStack.length - 1].sp, sp),\n        this._stack.length\n      );\n    }\n    return (\n      this._contextStack.push({\n        context,\n        sp\n      }) - 1\n    );\n  }\n\n  _replaceContextAt(index, context) {\n    if (index < 0 || index > this._contextStack.length - 1) {\n      throw new RangeError(\"Huz context index out of range.\");\n    }\n    this._contextStack[index].context = context;\n  }\n\n  _pushPartial({ name, indent, location }) {\n    this._partialStack.push({\n      name,\n      indent: indent || \"\",\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _pushLambda({ name, location }) {\n    this._lambdaStack.push({\n      name,\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _checkStacks() {\n    while (\n      this._stack.length < this._contextStack[this._contextStack.length - 1].sp\n    ) {\n      this._contextStack.pop();\n    }\n\n    if (\n      this._partialStack.length > 0 &&\n      this._stack.length ===\n        this._partialStack[this._partialStack.length - 1].sp\n    ) {\n      this._partialStack.pop();\n    }\n\n    if (\n      this._lambdaStack.length > 0 &&\n      this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp\n    ) {\n      this._lambdaStack.pop();\n    }\n  }\n\n  _evaluate(name) {\n    if (name === \".\") {\n      return this._contextStack[this._contextStack.length - 1].context;\n    }\n\n    const path = name.split(\".\");\n    for (let i = this._contextStack.length - 1; i >= 0; i--) {\n      const context = this._contextStack[i].context;\n      if (context === null || typeof context !== \"object\") {\n        continue;\n      }\n\n      let current = context;\n      let resolved = true;\n      for (let pi = 0; pi < path.length; pi++) {\n        const key = path[pi];\n        if (\n          typeof current === \"object\" &&\n          current !== null &&\n          current.hasOwnProperty(key)\n        ) {\n          current = current[key];\n        } else {\n          resolved = false;\n          break;\n        }\n      }\n\n      if (resolved) {\n        return current;\n      }\n    }\n    return \"\";\n  }\n\n  _getParsedPartial(name) {\n    if (this._partialCached.hasOwnProperty(name)) {\n      return this._partialCached[name];\n    } else {\n      if (!this._partials.hasOwnProperty(name)) {\n        return null;\n      }\n      const ast = this._parse(this._partials[name], { filename: name });\n      const nodes = (this._partialCached[name] = ast.children);\n      return nodes;\n    }\n  }\n\n  _expandPartial(node) {\n    const { name } = node;\n    const nodes = this._getParsedPartial(name);\n\n    if (nodes === null) {\n      //The empty string should be used when the named partial is not found.\n      return;\n    }\n\n    this._pushPartial(node);\n\n    if (this._partialStack.length > MAX_PARTIAL_STACK) {\n      this._throw(\n        \"Possible partial short circuit: \" +\n          this._partialStack\n            .map(f => `${f.name}@${f.location.filename}:${f.location.line + 1}`)\n            .concat([name])\n            .join(\" -> \"),\n        node.location\n      );\n    }\n\n    this._pushNodes(nodes);\n  }\n\n  _expandLambda(node, lambda) {\n    const { name } = node;\n\n    this._pushLambda(node);\n\n    if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n      this._throw(\n        \"Possible lambda short circuit: \" +\n          this._lambdaStack\n            .map(f => `${f.name}@${f.location.filename}:${f.location.line + 1}`)\n            .concat([name])\n            .join(\" -> \"),\n        node.location\n      );\n    }\n\n    let ast;\n    let skipped = false;\n    if (node.type === nodeTypes.VARIABLE) {\n      const code = lambda();\n      if (code) {\n        //A lambda's return value should parse with the default delimiters.\n        ast = this._parse(\"\" + code, { filename: \"[lambda]\" });\n        if (!node.unescaped) {\n          //Lambda results should be appropriately escaped.\n          walk(ast, node => {\n            if (node.type === nodeTypes.TEXT) {\n              node.text = escapeHTML(node.text);\n            }\n          });\n        }\n      } else {\n        skipped = true;\n      }\n    } else if (node.type === nodeTypes.SECTION) {\n      const code = lambda(node.raw);\n      if (code) {\n        //Lambdas used for inverted sections should be considered truthy.\n        //Lambdas used for sections should parse with the current delimiters.\n        ast = this._parse(\"\" + code, {\n          filename: \"[#lambda]\",\n          delimiters: this._delimiters.slice(0)\n        });\n      } else {\n        skipped = true;\n      }\n    }\n\n    if (!skipped) {\n      this._pushNodes(ast.children);\n    }\n  }\n\n  _throw(message, location) {\n    const e = new Error(message);\n    e.filename = location.filename;\n    e.location = location;\n    throw e;\n  }\n}\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == \"[object Function]\";\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderer.js","import { Parser } from \"./parser\";\nimport { Renderer } from \"./renderer\";\nimport * as TokenType from \"./token\";\nimport * as NodeType from \"./node\";\nimport * as Helpers from \"./helpers\";\nimport { register } from \"./extension\";\n\nexport { Tokenizer } from \"./tokenizer\";\nexport { Parser, Renderer, TokenType, NodeType };\n\nexport { Extension } from \"./extension\";\nimport { Inheritance } from \"./extensions/inheritance\";\n// import { Section } from \"./extensions/section\";\n\nregister(Inheritance);\n// register(Section);\n\nexport function parse(src, opts) {\n  const parser = new Parser(opts);\n  return parser.parse(src);\n}\n\nexport function compile(src, opts) {\n  return new Renderer(src, opts);\n}\n\nexport function render(src, context, opts) {\n  const r = compile(src, opts);\n  return r.render(context);\n}\n\nexport { register, Helpers };\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/escape-html/index.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}