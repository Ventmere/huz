{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///huz.js","webpack:///webpack/bootstrap 814741097d226d9c2486","webpack:///./src/index.js","webpack:///./src/extension.js","webpack:///./src/helpers.js","webpack:///./src/token.js","webpack:///./src/node.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js","webpack:///./src/extensions/inheritance.js","webpack:///./src/renderer.js","webpack:///./~/escape-html/index.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","parse","src","opts","parser","_parser","Parser","compile","_renderer","Renderer","render","context","r","defineProperty","value","_token","TokenType","_node","NodeType","_helpers","Helpers","_extension","_extensionsInheritance","_tokenizer","enumerable","get","Tokenizer","Extension","register","Inheritance","_classCallCheck","instance","Constructor","TypeError","instantiateAll","registry","map","ctor","constructor","push","_createClass","defineProperties","target","props","length","descriptor","configurable","writable","protoProps","staticProps","token","parserContext","node","renderContext","result","nodeResult","walk","modifier","stack","children","slice","reverse","pop","undefined","concat","visit","visitor","_parent","child","modified","trimStandaloneToken","tokens","count","open","inline","standalone","indentTokens","type","VARIABLE","UNESCAPED_VARIABLE","TEXT","isStringWhitespace","text","DELIMITER_CHANGE","COMMENT","SECTION_CLOSE","name","tailWSNodeCount","indent","forEach","t","str","test","EOF","PARTIAL","INVERTED_SECTION_OPEN","SECTION_OPEN","ROOT","SECTION","ParserContext","_appendNode","_pushParent","_popParent","message","_throw","_filename","_stack","arguments","_delimiters","delimiters","_extensions","extensions","filename","_parserContext","_lastToken","_src","rootNode","_parseNodes","_addNodeToken","location","JSON","stringify","beginLocation","endLocation","_clone","endIndex","endLine","initialStackSize","z","getNextToken","error","handled","ext","handleToken","_makeLocation","unescaped","_handleSectionOpen","_handleSectionClose","_handleComment","n","join","e","Error","inverted","section","raw","index","content","extractNewDelimiters","tagContent","matches","match","R_DELIMITER_CHANGE","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","Array","isArray","STATE_NONE","STATE_EOF","STATE_TEXT","STATE_TEXT_BREAK","STATE_TAG","DELIMITER_LEFT","DELIMITER_RIGHT","_index","_char","_tokens","_line","_column","_state","_error","_location","line","column","shift","matched","_markTokenStartLocation","_read","_handleEOF","_handleText","_handleTextBreak","_handleTag","_markTokenEndLocation","_isDelimiter","_handleStandaloneTag","_makeToken","left","right","_skip","_skipAllWhitespaces","_setError","_handleEmptyTag","tagTypeChar","_handleVariableCurly","tagContentStart","_handleSimpleTag","substr","_handleDelimiterChange","_handleVariable","newDelimiters","_newDelimiters","trim","begin","d","_distance","console","log","_isWhitespace","endColumn","offset","delimiter","pos","transformToken","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","isInheritanceTagType","PARENT","BLOCK","_get","_x","_x2","_x3","_again","object","property","receiver","desc","parent","getter","Function","getOwnPropertyDescriptor","getPrototypeOf","_token2","LEAVE_SCOPE","_Extension","_blocks","_parentStack","pushParent","tagNode","tailNode","popParent","appendNode","firstLine","firstBlock","find","blockNode","top","f","rendererContext","_checkTop","_handleParent","_handleBlock","pushNodes","blocks","blockName","keys","_setDefaultBlocks","pushNode","defaultBlock","_getDefaultBlock","frame","topFrame","assign","_interopRequireDefault","default","isFunction","x","toString","nodeTypes","_escapeHtml","_escapeHtml2","REPEATER_NODE_TYPE","MAX_PARTIAL_STACK","MAX_LAMBDA_STACK","RenderContext","renderer","_evaluate","nodes","_pushNodes","_pushNode","ctx","_pushContext","_out","_parse","_getParsedPartial","_this","_parsed","parsed","_partials","partials","_renderContext","_partialCached","k","_contextStack","_partialStack","_lambdaStack","_transformNodeResult","reduce","transformNodeResult","_this2","newline","_loop","handleNode","splice","partial","_popNode","_expandLambda","isList","testResult","_pushRepeaterNode","_expandPartial","repeat","repeatIndex","contextIndex","contexts","_replaceContextAt","_checkStacks","transformResult","list","sp","RangeError","_ref","_ref2","path","split","current","resolved","pi","ast","_pushPartial","lambda","_pushLambda","skipped","code","escapeHtml","string","matchHtmlRegExp","exec","escape","html","lastIndex","charCodeAt","substring"],"mappings":"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","file":"huz.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.parse = parse;\n\texports.compile = compile;\n\texports.render = render;\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tvar _parser = __webpack_require__(5);\n\t\n\tvar _renderer = __webpack_require__(8);\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar Helpers = _interopRequireWildcard(_helpers);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _extensionsInheritance = __webpack_require__(7);\n\t\n\tvar _tokenizer = __webpack_require__(6);\n\t\n\tObject.defineProperty(exports, 'Tokenizer', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _tokenizer.Tokenizer;\n\t  }\n\t});\n\texports.Parser = _parser.Parser;\n\texports.Renderer = _renderer.Renderer;\n\texports.TokenType = TokenType;\n\texports.NodeType = NodeType;\n\tObject.defineProperty(exports, 'Extension', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _extension.Extension;\n\t  }\n\t});\n\t\n\t(0, _extension.register)(_extensionsInheritance.Inheritance);\n\t\n\tfunction parse(src, opts) {\n\t  var parser = new _parser.Parser(opts);\n\t  return parser.parse(src);\n\t}\n\t\n\tfunction compile(src, opts) {\n\t  return new _renderer.Renderer(src, opts);\n\t}\n\t\n\tfunction render(src, context, opts) {\n\t  var r = compile(src, opts);\n\t  return r.render(context);\n\t}\n\t\n\texports.register = _extension.register;\n\texports.Helpers = Helpers;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\texports.instantiateAll = instantiateAll;\n\texports.register = register;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar registry = [];\n\t\n\tvar Extension = (function () {\n\t  function Extension() {\n\t    _classCallCheck(this, Extension);\n\t  }\n\t\n\t  _createClass(Extension, [{\n\t    key: \"transformToken\",\n\t\n\t    //called by tokenizer\n\t    value: function transformToken(token) {\n\t      return token;\n\t    }\n\t\n\t    //called by parser\n\t  }, {\n\t    key: \"handleToken\",\n\t    value: function handleToken(token, parserContext) {}\n\t  }, {\n\t    key: \"visit\",\n\t    value: function visit(root) {\n\t      return root;\n\t    }\n\t\n\t    //called by renderer\n\t  }, {\n\t    key: \"handleNode\",\n\t    value: function handleNode(node, renderContext) {}\n\t  }, {\n\t    key: \"transformNodeResult\",\n\t    value: function transformNodeResult(node, result, nodeResult) {\n\t      return nodeResult;\n\t    }\n\t  }, {\n\t    key: \"transformResult\",\n\t    value: function transformResult(result) {\n\t      return result;\n\t    }\n\t  }]);\n\t\n\t  return Extension;\n\t})();\n\t\n\texports.Extension = Extension;\n\t\n\tfunction instantiateAll(opts) {\n\t  return registry.map(function (ctor) {\n\t    return new ctor(opts);\n\t  });\n\t}\n\t\n\tfunction register(constructor) {\n\t  return registry.push(constructor);\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.walk = walk;\n\texports.visit = visit;\n\texports.trimStandaloneToken = trimStandaloneToken;\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tfunction walk(root, modifier) {\n\t  var stack = root.children.slice(0).reverse();\n\t  while (stack.length) {\n\t    var node = stack.pop();\n\t    modifier(node);\n\t    if (node.children !== undefined) {\n\t      stack = stack.concat(node.children.slice(0).reverse());\n\t    }\n\t  }\n\t}\n\t\n\tfunction visit(root, visitor) {\n\t  var stack = [root];\n\t  while (stack.length) {\n\t    var _parent = stack.pop();\n\t    for (var i = 0; i < _parent.children.length; i++) {\n\t      var child = _parent.children[i];\n\t      var modified = visitor.visit(child) || child;\n\t      if (modified !== child) {\n\t        _parent.children[i] = modified;\n\t      }\n\t      if (child.children && child.children.length) {\n\t        stack.push(child);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction trimStandaloneToken(tokens) {\n\t  var count = tokens.length;\n\t\n\t  if (count === 0) {\n\t    return tokens;\n\t  }\n\t\n\t  var open = null;\n\t  var inline = 0;\n\t  var standalone = true;\n\t  var indentTokens = [];\n\t  for (var i = 0; standalone && i < count; i++) {\n\t    var token = tokens[i];\n\t    switch (token.type) {\n\t      case TokenType.VARIABLE:\n\t      case TokenType.UNESCAPED_VARIABLE:\n\t        standalone = false;\n\t        break;\n\t      case TokenType.TEXT:\n\t        if (isStringWhitespace(token.text)) {\n\t          if (inline === 0) {\n\t            indentTokens.push(token);\n\t          }\n\t        } else {\n\t          standalone = false;\n\t        }\n\t        break;\n\t      case TokenType.DELIMITER_CHANGE:\n\t      case TokenType.COMMENT:\n\t        if (open !== null) {\n\t          open.push(token);\n\t        } else {\n\t          inline++;\n\t        }\n\t        break;\n\t      case TokenType.SECTION_CLOSE:\n\t        if (open) {\n\t          if (open[0].name === token.name) {\n\t            open = null;\n\t          } else {\n\t            standalone = false;\n\t          }\n\t        } else {\n\t          inline++;\n\t        }\n\t        break;\n\t      default:\n\t        //section-like tags\n\t        if (open === null) {\n\t          open = [token];\n\t          inline++;\n\t        } else {\n\t          standalone = false;\n\t        }\n\t        break;\n\t    }\n\t\n\t    if (inline > 1) {\n\t      standalone = false;\n\t    }\n\t  }\n\t\n\t  if (open && open.length > 1) {\n\t    standalone = false;\n\t  }\n\t\n\t  if (standalone) {\n\t    //all whitespace\n\t    if (indentTokens.length === count) {\n\t      return tokens;\n\t    }\n\t\n\t    var tailWSNodeCount = 0;\n\t    for (var i = count - 1; i >= 0; i--) {\n\t      var token = tokens[i];\n\t      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n\t        tailWSNodeCount++;\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n\t      //trim\n\t      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n\t      if (indentTokens.length) {\n\t        var indent = '';\n\t        indentTokens.forEach(function (t) {\n\t          indent += t.text;\n\t        });\n\t        tokens[0].indent = indent;\n\t      }\n\t    }\n\t  }\n\t  return tokens;\n\t}\n\t\n\tfunction isStringWhitespace(str) {\n\t  return (/^\\s*$/.test(str)\n\t  );\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar EOF = 'EOF';\n\texports.EOF = EOF;\n\tvar TEXT = 'TEXT';\n\texports.TEXT = TEXT;\n\tvar PARTIAL = 'PARTIAL';\n\texports.PARTIAL = PARTIAL;\n\tvar INVERTED_SECTION_OPEN = 'INVERTED_SECTION_OPEN';\n\texports.INVERTED_SECTION_OPEN = INVERTED_SECTION_OPEN;\n\tvar SECTION_OPEN = 'SECTION_OPEN';\n\texports.SECTION_OPEN = SECTION_OPEN;\n\tvar SECTION_CLOSE = 'SECTION_CLOSE';\n\texports.SECTION_CLOSE = SECTION_CLOSE;\n\tvar UNESCAPED_VARIABLE = 'UNESCAPED_VARIABLE';\n\texports.UNESCAPED_VARIABLE = UNESCAPED_VARIABLE;\n\tvar COMMENT = 'COMMENT';\n\texports.COMMENT = COMMENT;\n\tvar VARIABLE = 'VARIABLE';\n\texports.VARIABLE = VARIABLE;\n\tvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\texports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar ROOT = 'ROOT';\n\texports.ROOT = ROOT;\n\tvar VARIABLE = 'VARIABLE';\n\texports.VARIABLE = VARIABLE;\n\tvar SECTION = 'SECTION';\n\texports.SECTION = SECTION;\n\tvar TEXT = 'TEXT';\n\texports.TEXT = TEXT;\n\tvar COMMENT = 'COMMENT';\n\texports.COMMENT = COMMENT;\n\tvar PARTIAL = 'PARTIAL';\n\texports.PARTIAL = PARTIAL;\n\tvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\texports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _tokenizer = __webpack_require__(6);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar ParserContext = (function () {\n\t  function ParserContext(parser) {\n\t    _classCallCheck(this, ParserContext);\n\t\n\t    this._parser = parser;\n\t  }\n\t\n\t  _createClass(ParserContext, [{\n\t    key: 'appendNode',\n\t    value: function appendNode(node) {\n\t      this._parser._appendNode(node);\n\t    }\n\t  }, {\n\t    key: 'pushParent',\n\t    value: function pushParent(node) {\n\t      this._parser._pushParent(node);\n\t    }\n\t  }, {\n\t    key: 'popParent',\n\t    value: function popParent() {\n\t      return this._parser._popParent();\n\t    }\n\t  }, {\n\t    key: 'throw',\n\t    value: function _throw(message) {\n\t      return this._parser._throw(message);\n\t    }\n\t  }, {\n\t    key: 'filename',\n\t    get: function get() {\n\t      return this._parser._filename;\n\t    }\n\t  }, {\n\t    key: 'top',\n\t    get: function get() {\n\t      return this._parser._stack.length;\n\t    }\n\t  }, {\n\t    key: 'tailNode',\n\t    get: function get() {\n\t      return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n\t    }\n\t  }]);\n\t\n\t  return ParserContext;\n\t})();\n\t\n\tvar Parser = (function () {\n\t  function Parser() {\n\t    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t    _classCallCheck(this, Parser);\n\t\n\t    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n\t    this._filename = opts.filename || '';\n\t\n\t    if (this._extensions.length > 0) {\n\t      this._parserContext = new ParserContext(this);\n\t    }\n\t\n\t    this._stack = null;\n\t    this._lastToken = null;\n\t    this._src = null;\n\t  }\n\t\n\t  _createClass(Parser, [{\n\t    key: 'parse',\n\t    value: function parse(src) {\n\t      var rootNode = {\n\t        type: NodeType.ROOT,\n\t        children: []\n\t      };\n\t      this._src = src;\n\t      this._stack = [rootNode];\n\t      this._lastToken = null;\n\t      this._parseNodes(src);\n\t\n\t      if (this._extensions.length > 0) {\n\t        for (var i = 0; i < this._extensions.length; i++) {\n\t          this._extensions[i].visit(rootNode);\n\t        }\n\t      }\n\t\n\t      return rootNode;\n\t    }\n\t  }, {\n\t    key: '_addNodeToken',\n\t    value: function _addNodeToken(node) {\n\t      var token = this._lastToken;\n\t      if (node.tokens) {\n\t        node.tokens.push(token);\n\t      } else {\n\t        node.tokens = [token];\n\t      }\n\t    }\n\t  }, {\n\t    key: '_appendNode',\n\t    value: function _appendNode(node) {\n\t      this._addNodeToken(node);\n\t      node.location.filename = this._filename;\n\t      this._stack[this._stack.length - 1].children.push(node);\n\t      return node;\n\t    }\n\t  }, {\n\t    key: '_getTop',\n\t    value: function _getTop() {\n\t      return this._stack[this._stack.length - 1];\n\t    }\n\t  }, {\n\t    key: '_clone',\n\t    value: function _clone(obj) {\n\t      return JSON.parse(JSON.stringify(obj));\n\t    }\n\t  }, {\n\t    key: '_makeLocation',\n\t    value: function _makeLocation(beginLocation, endLocation) {\n\t      var location = this._clone(beginLocation);\n\t      if (endLocation) {\n\t        location.endIndex = endLocation.endIndex;\n\t        location.endLine = endLocation.endLine;\n\t      }\n\t      return location;\n\t    }\n\t  }, {\n\t    key: '_parseNodes',\n\t    value: function _parseNodes(src) {\n\t      var initialStackSize = this._stack.length;\n\t      var token = undefined;\n\t      var z = new _tokenizer.Tokenizer(src, {\n\t        delimiters: this._delimiters.slice(0),\n\t        extensions: this._extensions,\n\t        filename: this._filename\n\t      });\n\t\n\t      do {\n\t        token = z.getNextToken();\n\t\n\t        if (z.error !== null) {\n\t          throw z.error;\n\t        }\n\t\n\t        this._lastToken = token;\n\t\n\t        var handled = false;\n\t        if (this._extensions) {\n\t          for (var i = 0; i < this._extensions.length; i++) {\n\t            var ext = this._extensions[i];\n\t            if (ext.handleToken(token, this._parserContext) === true) {\n\t              handled = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (!handled) {\n\t          switch (token.type) {\n\t            case TokenType.TEXT:\n\t              this._appendNode({\n\t                type: NodeType.TEXT,\n\t                text: token.text,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.VARIABLE:\n\t            case TokenType.UNESCAPED_VARIABLE:\n\t              this._appendNode({\n\t                type: NodeType.VARIABLE,\n\t                name: token.name,\n\t                unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.SECTION_OPEN:\n\t              this._handleSectionOpen(token);\n\t              break;\n\t\n\t            case TokenType.INVERTED_SECTION_OPEN:\n\t              this._handleSectionOpen(token, true);\n\t              break;\n\t\n\t            case TokenType.SECTION_CLOSE:\n\t              this._handleSectionClose(token);\n\t              break;\n\t\n\t            case TokenType.PARTIAL:\n\t              this._appendNode({\n\t                type: NodeType.PARTIAL,\n\t                name: token.name,\n\t                indent: token.indent,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.COMMENT:\n\t              this._handleComment(token);\n\t              break;\n\t\n\t            case TokenType.DELIMITER_CHANGE:\n\t              this._appendNode({\n\t                type: NodeType.DELIMITER_CHANGE,\n\t                delimiters: token.delimiters,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t          }\n\t        }\n\t      } while (token.type !== TokenType.EOF);\n\t\n\t      if (this._stack.length > initialStackSize) {\n\t        this._throw('Unexpected EOF: sections not closed: ' + this._stack.slice(initialStackSize).map(function (n) {\n\t          return '\\'' + n.name + '\\'';\n\t        }).join(', '));\n\t      } else if (this._stack.length < initialStackSize) {\n\t        this._throw('Internal error.');\n\t      }\n\t    }\n\t  }, {\n\t    key: '_throw',\n\t    value: function _throw(message) {\n\t      var e = new Error(message);\n\t      e.filename = this._lastToken.filename;\n\t      e.location = this._lastToken.location;\n\t      throw e;\n\t    }\n\t  }, {\n\t    key: '_pushParent',\n\t    value: function _pushParent(node) {\n\t      this._addNodeToken(node);\n\t      node.children = [];\n\t      this._stack.push(node);\n\t    }\n\t  }, {\n\t    key: '_popParent',\n\t    value: function _popParent() {\n\t      return this._stack.pop();\n\t    }\n\t  }, {\n\t    key: '_handleSectionOpen',\n\t    value: function _handleSectionOpen(token) {\n\t      var inverted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t      var name = token.name;\n\t      var location = token.location;\n\t\n\t      this._pushParent({\n\t        type: NodeType.SECTION,\n\t        name: name,\n\t        inverted: inverted,\n\t        location: location\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleSectionClose',\n\t    value: function _handleSectionClose(token) {\n\t      var name = token.name;\n\t      var location = token.location;\n\t\n\t      var section = this._popParent();\n\t      if (section.type !== NodeType.SECTION) {\n\t        this._throw('Unexpected SECTION_CLOSE: \\'' + name + '\\'');\n\t      }\n\t\n\t      if (section.name !== name) {\n\t        this._throw('Unexpected SECTION_CLOSE: \\'' + name + '\\', current section: \\'' + section.name + '\\'');\n\t      }\n\t\n\t      section.raw = this._src.slice(section.location.endIndex, location.index);\n\t      section.location = this._makeLocation(section.location, token.location);\n\t\n\t      this._appendNode(section);\n\t    }\n\t  }, {\n\t    key: '_handleComment',\n\t    value: function _handleComment(token) {\n\t      var content = token.content;\n\t      var location = token.location;\n\t\n\t      this._appendNode({\n\t        type: NodeType.COMMENT,\n\t        content: content,\n\t        location: this._makeLocation(location)\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Parser;\n\t})();\n\n\texports.Parser = Parser;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar STATE_NONE = 'STATE_NONE';\n\tvar STATE_EOF = 'STATE_EOF';\n\tvar STATE_TEXT = 'STATE_TEXT';\n\tvar STATE_TEXT_BREAK = 'STATE_TEXT_BREAK';\n\tvar STATE_TAG = 'STATE_TAG';\n\t\n\tvar DELIMITER_LEFT = 0;\n\tvar DELIMITER_RIGHT = 1;\n\t\n\tvar Tokenizer = (function () {\n\t  function Tokenizer(src) {\n\t    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Tokenizer);\n\t\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n\t    this._src = src;\n\t    this._index = 0;\n\t    this._char = null;\n\t    this._tokens = [];\n\t    this._line = 0;\n\t    this._column = 0;\n\t    this._state = STATE_NONE;\n\t    this._error = null;\n\t    this._filename = opts.filename;\n\t    this._location = {\n\t      index: 0,\n\t      line: 0,\n\t      column: 0\n\t    };\n\t    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n\t  }\n\t\n\t  _createClass(Tokenizer, [{\n\t    key: 'getNextToken',\n\t    value: function getNextToken() {\n\t      if (this._tokens.length > 0) {\n\t        return this._tokens.shift();\n\t      }\n\t\n\t      var done = false;\n\t      var matched = false;\n\t      do {\n\t        //console.log(this._state, this._tokens);\n\t        if (this._error !== null) {\n\t          return null;\n\t        }\n\t\n\t        if (this._state !== STATE_NONE) {\n\t          matched = true;\n\t          this._markTokenStartLocation();\n\t        }\n\t\n\t        switch (this._state) {\n\t          case STATE_NONE:\n\t            this._read();\n\t            break;\n\t\n\t          case STATE_EOF:\n\t            this._handleEOF();\n\t            done = true;\n\t            break;\n\t\n\t          case STATE_TEXT:\n\t            this._handleText();\n\t            break;\n\t\n\t          case STATE_TEXT_BREAK:\n\t            this._handleTextBreak();\n\t            done = true;\n\t            break;\n\t\n\t          case STATE_TAG:\n\t            this._handleTag();\n\t            break;\n\t        }\n\t\n\t        if (matched && !this._error) {\n\t          this._markTokenEndLocation();\n\t          matched = false;\n\t        }\n\t\n\t        if (this._state === STATE_NONE) {\n\t          if (this._char === null) {\n\t            this._state = STATE_EOF;\n\t          } else if (this._char === '\\n') {\n\t            this._state = STATE_TEXT_BREAK;\n\t          } else if (this._isDelimiter(DELIMITER_LEFT)) {\n\t            this._state = STATE_TAG;\n\t          } else {\n\t            this._state = STATE_TEXT;\n\t          }\n\t        }\n\t      } while (!done);\n\t\n\t      return this._error === null ? this._tokens.shift() : null;\n\t    }\n\t\n\t    // Handlers\n\t\n\t  }, {\n\t    key: '_handleEOF',\n\t    value: function _handleEOF() {\n\t      this._handleStandaloneTag();\n\t      this._makeToken({\n\t        type: TokenType.EOF\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleTag',\n\t    value: function _handleTag() {\n\t      var _delimiters = _slicedToArray(this._delimiters, 2);\n\t\n\t      var left = _delimiters[0];\n\t      var right = _delimiters[1];\n\t\n\t      this._skip(left.length);\n\t      this._skipAllWhitespaces();\n\t\n\t      if (this._char === null) {\n\t        this._setError('Unclosed tag.');\n\t      } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n\t        this._handleEmptyTag();\n\t      } else {\n\t        var tagTypeChar = this._char;\n\t        if (tagTypeChar === '{') {\n\t          this._handleVariableCurly();\n\t        } else {\n\t          var tagContentStart = this._index - 1;\n\t          //read content\n\t          while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n\t            this._read();\n\t          }\n\t\n\t          if (this._char === null) {\n\t            this._setError('Unclosed tag.');\n\t          } else {\n\t            var content = this._src.slice(tagContentStart, this._index - 1);\n\t            switch (tagTypeChar) {\n\t              case '>':\n\t                this._handleSimpleTag(TokenType.PARTIAL, content);break;\n\t              case '^':\n\t                this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);break;\n\t              case '#':\n\t                this._handleSimpleTag(TokenType.SECTION_OPEN, content);break;\n\t              case '/':\n\t                this._handleSimpleTag(TokenType.SECTION_CLOSE, content);break;\n\t\n\t              case '!':\n\t                this._handleComment(content.substr(1));\n\t                break;\n\t\n\t              case '=':\n\t                this._handleDelimiterChange(content);\n\t                break;\n\t              case '&':\n\t                this._handleVariable(content.substr(1), true);\n\t                break;\n\t              default:\n\t                this._handleVariable(content);\n\t                break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      if (this._error === null) {\n\t        //eat right\n\t        for (var i = 0; i < right.length; i++) {\n\t          this._read();\n\t        }\n\t      }\n\t\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleDelimiterChange',\n\t    value: function _handleDelimiterChange(content) {\n\t      var newDelimiters = extractNewDelimiters(content);\n\t      if (newDelimiters === null) {\n\t        this._setError('Invalid change delimiter syntax.');\n\t      } else {\n\t        var _newDelimiters = _slicedToArray(newDelimiters, 2);\n\t\n\t        var left = _newDelimiters[0];\n\t        var right = _newDelimiters[1];\n\t\n\t        this._delimiters = newDelimiters;\n\t        this._makeToken({\n\t          type: TokenType.DELIMITER_CHANGE,\n\t          delimiters: [left, right]\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleSimpleTag',\n\t    value: function _handleSimpleTag(type, content) {\n\t      this._makeToken({ type: type, name: content.substr(1).trim() });\n\t    }\n\t  }, {\n\t    key: '_handleComment',\n\t    value: function _handleComment(content) {\n\t      this._makeToken({\n\t        type: TokenType.COMMENT,\n\t        content: content\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleVariableCurly',\n\t    value: function _handleVariableCurly() {\n\t      this._read(); //eat '{'\n\t      var begin = this._index - 1;\n\t      var d = this._distance('}');\n\t      if (d === -1) {\n\t        this._setError('Unclosed variable tag: missingright curly.');\n\t      } else {\n\t        var content = this._src.slice(begin, begin + d);\n\t        this._skip(d + 1); //skip '}'\n\t        this._skipAllWhitespaces();\n\t        if (!this._isDelimiter(DELIMITER_RIGHT)) {\n\t          this._setError('Unclosed variable: missing right delimiter.');\n\t        } else {\n\t          this._makeToken({\n\t            type: TokenType.UNESCAPED_VARIABLE,\n\t            name: content.trim()\n\t          });\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleEmptyTag',\n\t    value: function _handleEmptyTag() {\n\t      this._makeToken({\n\t        type: TokenType.VARIABLE,\n\t        name: ''\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleVariable',\n\t    value: function _handleVariable(content, unescaped) {\n\t      this._makeToken({\n\t        type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n\t        name: content.trim()\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleText',\n\t    value: function _handleText() {\n\t      var done = false;\n\t      var index = this._index - 1;\n\t      var length = 0;\n\t      do {\n\t        var c = this._char;\n\t\n\t        if (c === null || c === '\\n' || this._isDelimiter(DELIMITER_LEFT)) {\n\t          done = true;\n\t        } else {\n\t          length++;\n\t        }\n\t\n\t        if (!done) {\n\t          this._read();\n\t        }\n\t      } while (!done);\n\t\n\t      this._makeToken({\n\t        type: TokenType.TEXT,\n\t        text: this._src.slice(index, index + length)\n\t      });\n\t\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleTextBreak',\n\t    value: function _handleTextBreak() {\n\t      this._makeToken({\n\t        type: TokenType.TEXT,\n\t        text: '\\n'\n\t      });\n\t      this._read();\n\t      this._handleStandaloneTag();\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleStandaloneTag',\n\t    value: function _handleStandaloneTag() {\n\t      this._tokens = (0, _helpers.trimStandaloneToken)(this._tokens);\n\t    }\n\t\n\t    // Helpers\n\t  }, {\n\t    key: '_dump',\n\t    value: function _dump() {\n\t      var t = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\t\n\t      console.log(t + '>' + this._src.slice(this._index - 1));\n\t    }\n\t  }, {\n\t    key: '_read',\n\t    value: function _read() {\n\t      if (this._index < this._src.length) {\n\t        if (this._char === '\\n') {\n\t          this._line++;\n\t          this._column = 0;\n\t        } else {\n\t          this._column++;\n\t        }\n\t\n\t        this._char = this._src[this._index];\n\t        this._index++;\n\t      } else {\n\t        this._char = null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_peek',\n\t    value: function _peek() {\n\t      if (this._index < this._src.length - 1) {\n\t        return this._src[this._index];\n\t      } else {\n\t        return null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_skip',\n\t    value: function _skip(n) {\n\t      for (var i = 0; i < n; i++) {\n\t        this._read();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_distance',\n\t    value: function _distance(c) {\n\t      for (var i = this._index; i < this._src.length; i++) {\n\t        if (this._src[i] === c) {\n\t          return i - this._index + 1;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t  }, {\n\t    key: '_skipAllWhitespaces',\n\t    value: function _skipAllWhitespaces() {\n\t      while (this._isWhitespace()) {\n\t        this._read();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_markTokenStartLocation',\n\t    value: function _markTokenStartLocation() {\n\t      this._location.index = this._index - 1;\n\t      this._location.line = this._line;\n\t      this._location.column = this._column;\n\t    }\n\t  }, {\n\t    key: '_markTokenEndLocation',\n\t    value: function _markTokenEndLocation() {\n\t      var token = this._tokens[this._tokens.length - 1];\n\t      token.location.endIndex = this._index - 1;\n\t      token.location.endLine = this._line;\n\t      token.location.endColumn = this._column;\n\t    }\n\t  }, {\n\t    key: '_isWhitespace',\n\t    value: function _isWhitespace() {\n\t      return (/\\s/.test(this._char)\n\t      );\n\t    }\n\t  }, {\n\t    key: '_isDelimiter',\n\t    value: function _isDelimiter(d) {\n\t      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\t\n\t      var delimiter = this._delimiters[d];\n\t      var pos = this._index - 1 + offset;\n\t      return this._src.slice(pos, pos + delimiter.length) === delimiter;\n\t    }\n\t  }, {\n\t    key: '_makeToken',\n\t    value: function _makeToken(token) {\n\t      token.filename = this._filename;\n\t      var _location = this._location;\n\t      var index = _location.index;\n\t      var line = _location.line;\n\t      var column = _location.column;\n\t\n\t      token.location = {\n\t        index: index, line: line, column: column\n\t      };\n\t      if (this._extensions.length) {\n\t        try {\n\t          this._extensions.forEach(function (ext) {\n\t            token = ext.transformToken(token);\n\t          });\n\t        } catch (e) {\n\t          this._setError(e.message);\n\t          return;\n\t        }\n\t      }\n\t      this._tokens.push(token);\n\t    }\n\t  }, {\n\t    key: '_setError',\n\t    value: function _setError(message) {\n\t      var error = new Error(message);\n\t      error.filename = this._filename;\n\t      error.index = this._index - 1;\n\t      error.line = this._line;\n\t      error.column = this._column;\n\t      this._error = error;\n\t    }\n\t  }, {\n\t    key: 'error',\n\t    get: function get() {\n\t      return this._error;\n\t    }\n\t  }]);\n\t\n\t  return Tokenizer;\n\t})();\n\t\n\texports.Tokenizer = Tokenizer;\n\t\n\tvar R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\n\tfunction extractNewDelimiters(tagContent) {\n\t  var matches = tagContent.match(R_DELIMITER_CHANGE);\n\t  if (matches) {\n\t    return matches.slice(1);\n\t  } else {\n\t    return null;\n\t  }\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://github.com/mustache/spec/pull/75\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _token2 = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token2);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar PARENT = 'Inheritance.PARENT';\n\tvar BLOCK = 'Inheritance.BLOCK';\n\tvar LEAVE_SCOPE = 'Inheritance.LEAVE_SCOPE';\n\t\n\tfunction isInheritanceTagType(type) {\n\t  return type === PARENT || type === BLOCK;\n\t}\n\t\n\tvar Inheritance = (function (_Extension) {\n\t  _inherits(Inheritance, _Extension);\n\t\n\t  function Inheritance() {\n\t    _classCallCheck(this, Inheritance);\n\t\n\t    _get(Object.getPrototypeOf(Inheritance.prototype), 'constructor', this).call(this);\n\t\n\t    this._blocks = null;\n\t    this._parentStack = [];\n\t  }\n\t\n\t  _createClass(Inheritance, [{\n\t    key: 'transformToken',\n\t    value: function transformToken(token) {\n\t      var _token = token;\n\t      var type = _token.type;\n\t      var name = _token.name;\n\t      var location = _token.location;\n\t\n\t      switch (type) {\n\t        case TokenType.VARIABLE:\n\t          if (name) {\n\t            if (name[0] === '<') {\n\t              if (name.length === 1) {\n\t                throw new Error('Parent partial name expected');\n\t              }\n\t              token = {\n\t                type: PARENT,\n\t                name: name.slice(1),\n\t                location: location\n\t              };\n\t            } else if (name[0] === '$') {\n\t              if (name.length === 1) {\n\t                throw new Error('Block name expected');\n\t              }\n\t              token = {\n\t                type: BLOCK,\n\t                name: name.slice(1),\n\t                location: location\n\t              };\n\t            }\n\t          }\n\t          break;\n\t      }\n\t      return token;\n\t    }\n\t  }, {\n\t    key: 'handleToken',\n\t    value: function handleToken(token, parserContext) {\n\t      var handled = false;\n\t      var name = token.name;\n\t      var location = token.location;\n\t      var type = token.type;\n\t\n\t      switch (type) {\n\t        case PARENT:\n\t          parserContext.pushParent({\n\t            type: PARENT,\n\t            name: name,\n\t            location: location\n\t          });\n\t          handled = true;\n\t          break;\n\t\n\t        case BLOCK:\n\t          parserContext.pushParent({\n\t            type: BLOCK,\n\t            name: name,\n\t            location: location\n\t          });\n\t          break;\n\t\n\t        case TokenType.SECTION_CLOSE:\n\t          var tagNode = parserContext.tailNode;\n\t          if (tagNode === null) {\n\t            if (isInheritanceTagType(tagNode.type)) {\n\t              parserContext['throw']('Unexpected tag close');\n\t            }\n\t          } else {\n\t            if (tagNode.name !== name) {\n\t              parserContext['throw']('Unexpected tag close, current tag: ' + tagNode.name);\n\t            }\n\t            if (isInheritanceTagType(tagNode.type)) {\n\t              parserContext.popParent();\n\t              tagNode.location.endIndex = location.endIndex;\n\t              tagNode.location.endLine = location.endLine;\n\t              parserContext.appendNode(tagNode);\n\t\n\t              //TODO move this to visit, handle whitespaces after Parent close tag.\n\t              var firstLine = tagNode.location.line;\n\t              var firstBlock = tagNode.children.find(function (c) {\n\t                return c.type === BLOCK;\n\t              });\n\t              if (firstBlock && firstBlock.location.line === firstLine) {\n\t                for (var i = 0; i < firstBlock.children.length; i++) {\n\t                  var blockNode = firstBlock.children[i];\n\t                  if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n\t                    blockNode.text = '';\n\t                  } else {\n\t                    break;\n\t                  }\n\t                }\n\t              }\n\t\n\t              handled = true;\n\t            }\n\t          }\n\t          break;\n\t\n\t        case TokenType.EOF:\n\t          if (this.top > 0) {\n\t            parserContext['throw']('Unexpected EOF: tags not closed: ' + this.stack.map(function (f) {\n\t              return f.name;\n\t            }).join(', '));\n\t          }\n\t          break;\n\t      }\n\t      return handled;\n\t    }\n\t  }, {\n\t    key: 'handleNode',\n\t    value: function handleNode(node, rendererContext) {\n\t      var top = rendererContext.top;\n\t      this._checkTop(top);\n\t\n\t      switch (node.type) {\n\t        case PARENT:\n\t          this._handleParent(node, rendererContext);\n\t          return true;\n\t\n\t        case BLOCK:\n\t          this._handleBlock(node, rendererContext);\n\t          return true;\n\t\n\t        case LEAVE_SCOPE:\n\t          this._blocks = null;\n\t          return true;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleParent',\n\t    value: function _handleParent(node, rendererContext) {\n\t      var name = node.name;\n\t      var location = node.location;\n\t\n\t      var top = rendererContext.top;\n\t\n\t      this._pushParent(name, top);\n\t\n\t      if (this._blocks === null) {\n\t        rendererContext.pushNodes([{\n\t          type: LEAVE_SCOPE\n\t        }]);\n\t        this._blocks = {};\n\t      }\n\t\n\t      //find all blocks defined in parent\n\t      var blocks = {};\n\t      node.children.forEach(function (child) {\n\t        if (child.type === BLOCK) {\n\t          var blockName = child.name;\n\t          blocks[blockName] = child;\n\t        }\n\t      });\n\t      if (Object.keys(blocks).length) {\n\t        this._setDefaultBlocks(blocks);\n\t      }\n\t\n\t      rendererContext.pushNode({\n\t        type: TokenType.PARTIAL,\n\t        name: name, location: location,\n\t        indent: node.indent\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleBlock',\n\t    value: function _handleBlock(node, rendererContext) {\n\t      var name = node.name;\n\t\n\t      var defaultBlock = this._getDefaultBlock(name);\n\t      if (defaultBlock) {\n\t        rendererContext.pushNodes(defaultBlock.children);\n\t      } else {\n\t        rendererContext.pushNodes(node.children);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_pushParent',\n\t    value: function _pushParent(name, top) {\n\t      return this._parentStack.push({\n\t        name: name,\n\t        blocks: {},\n\t        top: top\n\t      });\n\t    }\n\t  }, {\n\t    key: '_checkTop',\n\t    value: function _checkTop(top) {\n\t      var pop = 0;\n\t      for (var i = this._parentStack.length - 1; i >= 0; i--) {\n\t        var frame = this._parentStack[i];\n\t        if (frame.top > top) {\n\t          pop++;\n\t        } else {\n\t          break;\n\t        }\n\t      }\n\t      if (pop > 0) {\n\t        this._parentStack = this._parentStack.slice(0, this._parentStack.length - pop);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_popParent',\n\t    value: function _popParent() {\n\t      return this._parentStack.pop();\n\t    }\n\t  }, {\n\t    key: '_getDefaultBlock',\n\t    value: function _getDefaultBlock(name) {\n\t      for (var i = 0; i < this._parentStack.length; i++) {\n\t        var frame = this._parentStack[i];\n\t        if (name in frame.blocks) {\n\t          return frame.blocks[name];\n\t        }\n\t      }\n\t      return null;\n\t    }\n\t  }, {\n\t    key: '_setDefaultBlocks',\n\t    value: function _setDefaultBlocks(blocks) {\n\t      var topFrame = this._parentStack[this._parentStack.length - 1];\n\t      topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n\t    }\n\t  }]);\n\t\n\t  return Inheritance;\n\t})(_extension.Extension);\n\n\texports.Inheritance = Inheritance;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar nodeTypes = _interopRequireWildcard(_node);\n\t\n\tvar _escapeHtml = __webpack_require__(9);\n\t\n\tvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\t\n\tvar _parser = __webpack_require__(5);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar REPEATER_NODE_TYPE = '_REPEATER';\n\tvar MAX_PARTIAL_STACK = 10;\n\tvar MAX_LAMBDA_STACK = 255;\n\t\n\tvar RenderContext = (function () {\n\t  function RenderContext(renderer) {\n\t    _classCallCheck(this, RenderContext);\n\t\n\t    this._renderer = renderer;\n\t  }\n\t\n\t  _createClass(RenderContext, [{\n\t    key: 'evaluate',\n\t    value: function evaluate(name) {\n\t      return this._renderer._evaluate(name);\n\t    }\n\t  }, {\n\t    key: 'pushNodes',\n\t    value: function pushNodes(nodes) {\n\t      this._renderer._pushNodes(nodes);\n\t    }\n\t  }, {\n\t    key: 'pushNode',\n\t    value: function pushNode(node) {\n\t      this._renderer._pushNode(node);\n\t    }\n\t  }, {\n\t    key: 'pushContext',\n\t    value: function pushContext(ctx) {\n\t      this._renderer._pushContext(ctx);\n\t    }\n\t  }, {\n\t    key: 'appendText',\n\t    value: function appendText(text) {\n\t      this._renderer._out += text;\n\t    }\n\t  }, {\n\t    key: 'parse',\n\t    value: function parse(src, opts) {\n\t      return this._renderer._parse(src, opts);\n\t    }\n\t  }, {\n\t    key: 'getParsedPartial',\n\t    value: function getParsedPartial(name) {\n\t      return this._renderer._getParsedPartial(name);\n\t    }\n\t  }, {\n\t    key: 'throw',\n\t    value: function _throw(message, location) {\n\t      return this._renderer._throw(message, location);\n\t    }\n\t  }, {\n\t    key: 'top',\n\t    get: function get() {\n\t      return this._renderer._stack.length;\n\t    }\n\t  }, {\n\t    key: 'result',\n\t    get: function get() {\n\t      return this._renderer._out;\n\t    }\n\t  }]);\n\t\n\t  return RenderContext;\n\t})();\n\t\n\tvar Renderer = (function () {\n\t  function Renderer(src) {\n\t    var _this = this;\n\t\n\t    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Renderer);\n\t\n\t    //if this is true, src and values in partials are parsed tree, not string\n\t    this._parsed = opts.parsed || false;\n\t\n\t    this._partials = opts.partials || {};\n\t    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n\t    if (this._extensions.length > 0) {\n\t      this._renderContext = new RenderContext(this);\n\t    }\n\t\n\t    this._partialCached = {};\n\t    if (this._parsed) {\n\t      Object.keys(this._partials).forEach(function (k) {\n\t        _this._partialCached[k] = _this._partials[k].children;\n\t      });\n\t    }\n\t\n\t    this._stack = null;\n\t    this._contextStack = null;\n\t    this._partialStack = null;\n\t    this._lambdaStack = null;\n\t    this._src = src;\n\t    this._out = '';\n\t    this._transformNodeResult = function (node, result, nodeResult) {\n\t      return _this._extensions.reduce(function (r, e) {\n\t        return e.transformNodeResult(node, result, r);\n\t      }, nodeResult);\n\t    };\n\t  }\n\t\n\t  _createClass(Renderer, [{\n\t    key: 'render',\n\t    value: function render(context) {\n\t      var _this2 = this;\n\t\n\t      this._out = '';\n\t      this._stack = [];\n\t      this._contextStack = [];\n\t      this._partialStack = [];\n\t      this._lambdaStack = [];\n\t\n\t      this._pushContext(context);\n\t\n\t      //push root nodes\n\t      var rootNode = this._parsed ? this._src : this._parse(this._src);\n\t      this._stack = rootNode.children.slice(0).reverse();\n\t\n\t      var newline = true;\n\t\n\t      var _loop = function () {\n\t        var top = _this2._stack.length - 1;\n\t        var node = _this2._stack[top];\n\t\n\t        var handled = false;\n\t        if (_this2._extensions) {\n\t          _this2._extensions.forEach(function (ext) {\n\t            if (ext.handleNode(node, _this2._renderContext)) {\n\t              handled = true;\n\t            }\n\t          });\n\t        }\n\t\n\t        if (handled) {\n\t          _this2._stack.splice(top, 1);\n\t        } else {\n\t          var partial = _this2._partialStack.length ? _this2._partialStack[_this2._partialStack.length - 1] : null;\n\t\n\t          //insert indent\n\t          if (node.type in nodeTypes) {\n\t            if (newline && partial !== null && partial.indent.length > 0) {\n\t              _this2._out += partial.indent;\n\t            }\n\t          }\n\t\n\t          var value = undefined;\n\t          switch (node.type) {\n\t            case nodeTypes.VARIABLE:\n\t              value = _this2._evaluate(node.name);\n\t              if (isFunction(value)) {\n\t                _this2._popNode();\n\t                _this2._expandLambda(node, value);\n\t              } else {\n\t                if (!!value) {\n\t                  var result = node.unescaped ? value : (0, _escapeHtml2['default'])(value);\n\t                  _this2._out += _this2._transformNodeResult(node, _this2._out, result);\n\t                }\n\t                _this2._popNode();\n\t              }\n\t              break;\n\t\n\t            case nodeTypes.SECTION:\n\t              value = _this2._evaluate(node.name);\n\t              if (isFunction(value)) {\n\t                _this2._popNode();\n\t                _this2._expandLambda(node, value);\n\t              } else {\n\t                var isList = Array.isArray(value);\n\t\n\t                if (isList && value.length === 0) {\n\t                  //Empty lists should behave like falsey values.\n\t                  value = false;\n\t                  isList = false;\n\t                }\n\t\n\t                var testResult = !!value;\n\t                if (node.inverted) {\n\t                  testResult = !testResult;\n\t                }\n\t\n\t                if (testResult) {\n\t                  if (isList) {\n\t                    _this2._popNode();\n\t                    _this2._pushRepeaterNode(value.length, node.children, value);\n\t                  } else {\n\t                    _this2._popNode();\n\t                    _this2._pushContext(value);\n\t                    _this2._pushNodes(node.children);\n\t                  }\n\t                } else {\n\t                  _this2._popNode();\n\t                }\n\t              }\n\t              break;\n\t\n\t            case nodeTypes.TEXT:\n\t              _this2._out += _this2._transformNodeResult(node, _this2._out, node.text);\n\t              _this2._popNode();\n\t              break;\n\t\n\t            case nodeTypes.COMMENT:\n\t              _this2._popNode();\n\t              break;\n\t\n\t            case nodeTypes.PARTIAL:\n\t              _this2._popNode();\n\t              _this2._expandPartial(node);\n\t              break;\n\t\n\t            case nodeTypes.DELIMITER_CHANGE:\n\t              _this2._popNode();\n\t              _this2._delimiters = node.delimiters.slice(0);\n\t              break;\n\t\n\t            case REPEATER_NODE_TYPE:\n\t              if (node.count < node.repeat) {\n\t                var repeatIndex = node.count;\n\t                if (repeatIndex === 0) {\n\t                  node.contextIndex = _this2._pushContext(node.contexts[0]);\n\t                } else {\n\t                  _this2._replaceContextAt(node.contextIndex, node.contexts[repeatIndex]);\n\t                }\n\t                _this2._pushNodes(node.children);\n\t                node.count++;\n\t              } else {\n\t                _this2._popNode();\n\t              }\n\t              break;\n\t\n\t            default:\n\t              _this2._popNode();\n\t              break;\n\t          }\n\t        }\n\t        _this2._checkStacks();\n\t        newline = _this2._out.length === 0 || _this2._out[_this2._out.length - 1] === '\\n';\n\t      };\n\t\n\t      while (this._stack.length > 0) {\n\t        _loop();\n\t      }\n\t\n\t      return this._extensions.reduce(function (result, ext) {\n\t        return ext.transformResult(result);\n\t      }, this._out);\n\t    }\n\t  }, {\n\t    key: '_parse',\n\t    value: function _parse(src) {\n\t      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t      opts.extensions = this._extensions;\n\t      var parser = new _parser.Parser(opts);\n\t      return parser.parse(src);\n\t    }\n\t  }, {\n\t    key: '_pushNodes',\n\t    value: function _pushNodes(list) {\n\t      for (var i = list.length - 1; i >= 0; i--) {\n\t        this._stack.push(list[i]);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_pushNode',\n\t    value: function _pushNode(node) {\n\t      this._stack.push(node);\n\t    }\n\t  }, {\n\t    key: '_popNode',\n\t    value: function _popNode() {\n\t      this._stack.pop();\n\t    }\n\t  }, {\n\t    key: '_pushRepeaterNode',\n\t    value: function _pushRepeaterNode(repeat, nodes, contexts) {\n\t      this._stack.push({\n\t        type: REPEATER_NODE_TYPE,\n\t        count: 0,\n\t        repeat: repeat,\n\t        children: nodes.slice(0),\n\t        contexts: contexts\n\t      });\n\t    }\n\t  }, {\n\t    key: '_pushContext',\n\t    value: function _pushContext(context) {\n\t      return this._contextStack.push({\n\t        context: context,\n\t        sp: this._stack.length\n\t      }) - 1;\n\t    }\n\t  }, {\n\t    key: '_replaceContextAt',\n\t    value: function _replaceContextAt(index, context) {\n\t      if (index < 0 || index > this._contextStack.length - 1) {\n\t        throw new RangeError('Huz context index out of range.');\n\t      }\n\t      this._contextStack[index].context = context;\n\t    }\n\t  }, {\n\t    key: '_pushPartial',\n\t    value: function _pushPartial(_ref) {\n\t      var name = _ref.name;\n\t      var indent = _ref.indent;\n\t      var location = _ref.location;\n\t\n\t      this._partialStack.push({\n\t        name: name,\n\t        indent: indent || '',\n\t        location: location,\n\t        sp: this._stack.length\n\t      });\n\t    }\n\t  }, {\n\t    key: '_pushLambda',\n\t    value: function _pushLambda(_ref2) {\n\t      var name = _ref2.name;\n\t      var location = _ref2.location;\n\t\n\t      this._lambdaStack.push({\n\t        name: name,\n\t        location: location,\n\t        sp: this._stack.length\n\t      });\n\t    }\n\t  }, {\n\t    key: '_checkStacks',\n\t    value: function _checkStacks() {\n\t      if (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n\t        this._contextStack.pop();\n\t      }\n\t\n\t      if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n\t        this._partialStack.pop();\n\t      }\n\t\n\t      if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n\t        this._lambdaStack.pop();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_evaluate',\n\t    value: function _evaluate(name) {\n\t      if (name === '.') {\n\t        return this._contextStack[this._contextStack.length - 1].context;\n\t      }\n\t\n\t      var path = name.split('.');\n\t      for (var i = this._contextStack.length - 1; i >= 0; i--) {\n\t        var context = this._contextStack[i].context;\n\t        if (context === null || typeof context !== 'object') {\n\t          continue;\n\t        }\n\t\n\t        var current = context;\n\t        var resolved = true;\n\t        for (var pi = 0; pi < path.length; pi++) {\n\t          var key = path[pi];\n\t          if (typeof current === 'object' && current !== null && current.hasOwnProperty(key)) {\n\t            current = current[key];\n\t          } else {\n\t            resolved = false;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (resolved) {\n\t          return current;\n\t        }\n\t      }\n\t      return '';\n\t    }\n\t  }, {\n\t    key: '_getParsedPartial',\n\t    value: function _getParsedPartial(name) {\n\t      if (this._partialCached.hasOwnProperty(name)) {\n\t        return this._partialCached[name];\n\t      } else {\n\t        if (!this._partials.hasOwnProperty(name)) {\n\t          return null;\n\t        }\n\t        var ast = this._parse(this._partials[name], { filename: name });\n\t        var nodes = this._partialCached[name] = ast.children;\n\t        return nodes;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_expandPartial',\n\t    value: function _expandPartial(node) {\n\t      var name = node.name;\n\t\n\t      var nodes = this._getParsedPartial(name);\n\t\n\t      if (nodes === null) {\n\t        //The empty string should be used when the named partial is not found.\n\t        return;\n\t      }\n\t\n\t      this._pushPartial(node);\n\t\n\t      if (this._partialStack.length > MAX_PARTIAL_STACK) {\n\t        this._throw('Possible partial short circuit: ' + this._partialStack.map(function (f) {\n\t          return f.name + '@' + f.location.filename + ':' + (f.location.line + 1);\n\t        }).concat([name]).join(' -> '), node.location);\n\t      }\n\t\n\t      this._pushNodes(nodes);\n\t    }\n\t  }, {\n\t    key: '_expandLambda',\n\t    value: function _expandLambda(node, lambda) {\n\t      var name = node.name;\n\t\n\t      this._pushLambda(node);\n\t\n\t      if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n\t        this._throw('Possible lambda short circuit: ' + this._lambdaStack.map(function (f) {\n\t          return f.name + '@' + f.location.filename + ':' + (f.location.line + 1);\n\t        }).concat([name]).join(' -> '), node.location);\n\t      }\n\t\n\t      var ast = undefined;\n\t      var skipped = false;\n\t      if (node.type === nodeTypes.VARIABLE) {\n\t        var code = lambda();\n\t        if (code) {\n\t          //A lambda's return value should parse with the default delimiters.\n\t          ast = this._parse('' + code, { filename: '[lambda]' });\n\t          if (!node.unescaped) {\n\t            //Lambda results should be appropriately escaped.\n\t            (0, _helpers.walk)(ast, function (node) {\n\t              if (node.type === nodeTypes.TEXT) {\n\t                node.text = (0, _escapeHtml2['default'])(node.text);\n\t              }\n\t            });\n\t          }\n\t        } else {\n\t          skipped = true;\n\t        }\n\t      } else if (node.type === nodeTypes.SECTION) {\n\t        var code = lambda(node.raw);\n\t        if (code) {\n\t          //Lambdas used for inverted sections should be considered truthy.\n\t          //Lambdas used for sections should parse with the current delimiters.\n\t          ast = this._parse('' + code, {\n\t            filename: '[#lambda]',\n\t            delimiters: this._delimiters.slice(0)\n\t          });\n\t        } else {\n\t          skipped = true;\n\t        }\n\t      }\n\t\n\t      if (!skipped) {\n\t        this._pushNodes(ast.children);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_throw',\n\t    value: function _throw(message, location) {\n\t      var e = new Error(message);\n\t      e.location = location;\n\t      throw e;\n\t    }\n\t  }]);\n\t\n\t  return Renderer;\n\t})();\n\t\n\texports.Renderer = Renderer;\n\t\n\tfunction isFunction(x) {\n\t  return Object.prototype.toString.call(x) == '[object Function]';\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * escape-html\n\t * Copyright(c) 2012-2013 TJ Holowaychuk\n\t * Copyright(c) 2015 Andreas Lubbe\n\t * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n\t * MIT Licensed\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Module variables.\n\t * @private\n\t */\n\t\n\tvar matchHtmlRegExp = /[\"'&<>]/;\n\t\n\t/**\n\t * Module exports.\n\t * @public\n\t */\n\t\n\tmodule.exports = escapeHtml;\n\t\n\t/**\n\t * Escape special characters in the given string of html.\n\t *\n\t * @param  {string} string The string to escape for inserting into HTML\n\t * @return {string}\n\t * @public\n\t */\n\t\n\tfunction escapeHtml(string) {\n\t  var str = '' + string;\n\t  var match = matchHtmlRegExp.exec(str);\n\t\n\t  if (!match) {\n\t    return str;\n\t  }\n\t\n\t  var escape;\n\t  var html = '';\n\t  var index = 0;\n\t  var lastIndex = 0;\n\t\n\t  for (index = match.index; index < str.length; index++) {\n\t    switch (str.charCodeAt(index)) {\n\t      case 34: // \"\n\t        escape = '&quot;';\n\t        break;\n\t      case 38: // &\n\t        escape = '&amp;';\n\t        break;\n\t      case 39: // '\n\t        escape = '&#39;';\n\t        break;\n\t      case 60: // <\n\t        escape = '&lt;';\n\t        break;\n\t      case 62: // >\n\t        escape = '&gt;';\n\t        break;\n\t      default:\n\t        continue;\n\t    }\n\t\n\t    if (lastIndex !== index) {\n\t      html += str.substring(lastIndex, index);\n\t    }\n\t\n\t    lastIndex = index + 1;\n\t    html += escape;\n\t  }\n\t\n\t  return lastIndex !== index\n\t    ? html + str.substring(lastIndex, index)\n\t    : html;\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** huz.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 814741097d226d9c2486\n **/","import { Parser } from './parser';\nimport { Renderer } from './renderer';\nimport * as TokenType from './token';\nimport * as NodeType from './node';\nimport * as Helpers from './helpers';\nimport { register } from './extension';\n\nexport { Tokenizer } from './tokenizer';\nexport { Parser, Renderer, TokenType, NodeType };\n\nexport { Extension } from './extension';\nimport { Inheritance } from './extensions/inheritance';\n\nregister(Inheritance);\n\nexport function parse(src, opts) {\n  const parser = new Parser(opts);\n  return parser.parse(src);\n}\n\nexport function compile(src, opts) {\n  return new Renderer(src, opts);\n}\n\nexport function render(src, context, opts) {\n  const r = compile(src, opts);\n  return r.render(context);\n}\n\nexport { register, Helpers };\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","const registry = [];\n\nexport class Extension {\n  //called by tokenizer\n  transformToken(token) { return token; }\n\n  //called by parser\n  handleToken(token, parserContext) { }\n  visit(root) { return root; }\n  \n  //called by renderer\n  handleNode(node, renderContext) { }\n  transformNodeResult(node, result, nodeResult) { return nodeResult; }\n  transformResult(result) { return result; }\n}\n\nexport function instantiateAll(opts) {\n  return registry.map(ctor => {\n    return new ctor(opts);\n  });\n}\n\nexport function register(constructor) {\n  return registry.push(constructor);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/extension.js\n **/","import * as TokenType from './token';\n\nexport function walk(root, modifier) {\n  let stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    const node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nexport function visit(root, visitor) {\n  let stack = [root];\n  while (stack.length) {\n    const parent = stack.pop();\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      const modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nexport function trimStandaloneToken(tokens) {\n  const count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  let open = null;\n  let inline = 0;\n  let standalone = true;\n  let indentTokens = [];\n  for (let i = 0; standalone && i < count; i++) {\n    const token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline ++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline ++;\n        }\n        break;\n      default: //section-like tags\n        if (open === null) {\n          open = [token];\n          inline ++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n  \n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    let tailWSNodeCount = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount ++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        let indent = '';\n        indentTokens.forEach(t => { indent += t.text });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return /^\\s*$/.test(str);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/helpers.js\n **/","export const EOF                    = 'EOF';\nexport const TEXT                   = 'TEXT';\nexport const PARTIAL                = 'PARTIAL';\nexport const INVERTED_SECTION_OPEN  = 'INVERTED_SECTION_OPEN';\nexport const SECTION_OPEN           = 'SECTION_OPEN';\nexport const SECTION_CLOSE          = 'SECTION_CLOSE';\nexport const UNESCAPED_VARIABLE     = 'UNESCAPED_VARIABLE';\nexport const COMMENT                = 'COMMENT';\nexport const VARIABLE               = 'VARIABLE';\nexport const DELIMITER_CHANGE \t\t\t= 'DELIMITER_CHANGE';\n\n\n/** WEBPACK FOOTER **\n ** ./src/token.js\n **/","export const ROOT             = 'ROOT';\nexport const VARIABLE         = 'VARIABLE';\nexport const SECTION          = 'SECTION';\nexport const TEXT             = 'TEXT';\nexport const COMMENT          = 'COMMENT';\nexport const PARTIAL          = 'PARTIAL';\nexport const DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\n\n/** WEBPACK FOOTER **\n ** ./src/node.js\n **/","import * as TokenType from './token';\nimport * as NodeType from './node';\nimport { Tokenizer } from './tokenizer';\nimport { visit } from './helpers';\nimport { instantiateAll } from './extension';\n\nclass ParserContext {\n  constructor(parser) {\n    this._parser = parser;\n  }\n\n  appendNode(node) {\n    this._parser._appendNode(node);\n  }\n\n  pushParent(node) {\n    this._parser._pushParent(node);\n  }\n\n  popParent() {\n    return this._parser._popParent();\n  }\n\n  get filename() {\n    return this._parser._filename;\n  }\n\n  get top() {\n    return this._parser._stack.length;\n  }\n\n  get tailNode() {\n    return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n  }\n\n  throw(message) {\n    return this._parser._throw(message);\n  }\n}\n\nexport class Parser {\n  constructor(opts = {}) {\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    this._filename = opts.filename || '';\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  parse(src) {\n    const rootNode = { \n      type: NodeType.ROOT, \n      children: []\n    };\n    this._src = src;\n    this._stack = [rootNode];\n    this._lastToken = null;\n    this._parseNodes(src);\n\n    if (this._extensions.length > 0) {\n      for (let i = 0; i < this._extensions.length; i++) {\n        this._extensions[i].visit(rootNode);\n      }\n    }\n\n    return rootNode;\n  }\n\n  _addNodeToken(node) {\n    const token = this._lastToken;\n    if (node.tokens) {\n      node.tokens.push(token);\n    } else {\n      node.tokens = [token];\n    }\n  }\n\n  _appendNode(node) {\n    this._addNodeToken(node);\n    node.location.filename = this._filename;\n    this._stack[this._stack.length - 1].children.push(node);\n    return node;\n  }\n\n  _getTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  _clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  _makeLocation(beginLocation, endLocation) {\n    const location = this._clone(beginLocation);\n    if (endLocation) {\n      location.endIndex = endLocation.endIndex;\n      location.endLine = endLocation.endLine;\n    }\n    return location;\n  }\n\n  _parseNodes(src) {\n    let initialStackSize = this._stack.length;\n    let token;\n    const z = new Tokenizer(src, { \n      delimiters: this._delimiters.slice(0),\n      extensions: this._extensions,\n      filename: this._filename\n    });\n\n    do {\n      token = z.getNextToken();\n\n      if (z.error !== null) {\n        throw z.error;\n      }\n\n      this._lastToken = token;\n\n      let handled = false;\n      if (this._extensions) {\n        for (let i = 0; i < this._extensions.length; i++) {\n          const ext = this._extensions[i];\n          if (ext.handleToken(token, this._parserContext) === true) {\n            handled = true;\n            break;\n          }\n        }\n      }\n\n      if (!handled) {\n        switch (token.type) {\n          case TokenType.TEXT:\n            this._appendNode({\n              type: NodeType.TEXT,\n              text: token.text,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.VARIABLE:\n          case TokenType.UNESCAPED_VARIABLE:\n            this._appendNode({\n              type: NodeType.VARIABLE,\n              name: token.name,\n              unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.SECTION_OPEN:\n            this._handleSectionOpen(token);\n            break;\n\n          case TokenType.INVERTED_SECTION_OPEN:\n            this._handleSectionOpen(token, true);\n            break;\n\n          case TokenType.SECTION_CLOSE:\n            this._handleSectionClose(token);\n            break;\n\n          case TokenType.PARTIAL:\n            this._appendNode({\n              type: NodeType.PARTIAL,\n              name: token.name,\n              indent: token.indent,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.COMMENT:\n            this._handleComment(token);\n            break;\n\n          case TokenType.DELIMITER_CHANGE:\n            this._appendNode({\n              type: NodeType.DELIMITER_CHANGE,\n              delimiters: token.delimiters,\n              location: this._makeLocation(token.location)\n            });\n            break;\n        }\n      }\n    } while (token.type !== TokenType.EOF);\n\n    if (this._stack.length > initialStackSize) {\n      this._throw('Unexpected EOF: sections not closed: ' + \n        this._stack.slice(initialStackSize).map(n => `'${n.name}'`).join(', '));\n    } else if (this._stack.length < initialStackSize) {\n      this._throw('Internal error.');\n    }\n  }\n\n  _throw(message) {\n    const e = new Error(message);\n    e.filename = this._lastToken.filename;\n    e.location = this._lastToken.location;\n    throw e;\n  }\n\n  _pushParent(node) {\n    this._addNodeToken(node);\n    node.children = [];\n    this._stack.push(node);\n  }\n\n  _popParent() {\n    return this._stack.pop();\n  }\n\n  _handleSectionOpen(token, inverted = false) {\n    const { name, location } = token;\n    this._pushParent({\n      type: NodeType.SECTION,\n      name,\n      inverted,\n      location\n    });\n  }\n\n  _handleSectionClose(token) {\n    const { name, location } = token;\n    const section = this._popParent();\n    if (section.type !== NodeType.SECTION) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}'`);\n    }\n\n    if (section.name !== name) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}', current section: '${section.name}'`);\n    }\n\n    section.raw = this._src.slice(section.location.endIndex, location.index);\n    section.location = this._makeLocation(section.location, token.location);\n\n    this._appendNode(section);\n  }\n\n  _handleComment(token) {\n    const { content, location } = token;\n    this._appendNode({\n      type: NodeType.COMMENT,\n      content,\n      location: this._makeLocation(location)\n    });\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parser.js\n **/","import * as TokenType from './token';\nimport { instantiateAll } from './extension';\nimport { trimStandaloneToken } from './helpers';\n\nconst STATE_NONE        = 'STATE_NONE';\nconst STATE_EOF         = 'STATE_EOF';\nconst STATE_TEXT        = 'STATE_TEXT';\nconst STATE_TEXT_BREAK  = 'STATE_TEXT_BREAK';\nconst STATE_TAG         = 'STATE_TAG';\n\nconst DELIMITER_LEFT  = 0;\nconst DELIMITER_RIGHT = 1;\n\nexport class Tokenizer {\n  constructor(src, opts = {}) {\n    this._extensions = opts.extensions || instantiateAll();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 0;\n    this._column = 0;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  getNextToken() {\n    if (this._tokens.length > 0) {\n      return this._tokens.shift();\n    }\n\n    let done = false;\n    let matched = false;\n    do {\n      //console.log(this._state, this._tokens);\n      if (this._error !== null) {\n        return null;\n      }\n\n      if (this._state !== STATE_NONE) {\n        matched = true;\n        this._markTokenStartLocation();\n      }\n\n      switch (this._state) {\n        case STATE_NONE:\n          this._read();\n          break;\n\n        case STATE_EOF:\n          this._handleEOF();\n          done = true;\n          break;\n\n        case STATE_TEXT:\n          this._handleText();\n          break;\n\n        case STATE_TEXT_BREAK:\n          this._handleTextBreak();\n          done = true;\n          break;\n\n        case STATE_TAG:\n          this._handleTag();\n          break;\n      }\n\n      if (matched && !this._error) {\n        this._markTokenEndLocation();\n        matched = false;\n      }\n\n      if (this._state === STATE_NONE) {\n        if (this._char === null) {\n          this._state = STATE_EOF;\n        } else if (this._char === '\\n') {\n          this._state = STATE_TEXT_BREAK;\n        } else if (this._isDelimiter(DELIMITER_LEFT)) {\n          this._state = STATE_TAG;\n        } else {\n          this._state = STATE_TEXT;\n        }\n      }\n\n    } while (!done);\n\n    return this._error === null ? this._tokens.shift() : null;\n  }\n\n  // Handlers\n\n  _handleEOF() {\n    this._handleStandaloneTag();\n    this._makeToken({ \n      type: TokenType.EOF\n    });\n  }\n\n  _handleTag() {\n    const [ left, right ] = this._delimiters;\n    this._skip(left.length);\n    this._skipAllWhitespaces();\n\n    if (this._char === null) {\n      this._setError('Unclosed tag.');\n    }\n    else if (this._isDelimiter(DELIMITER_RIGHT)) {\n      this._handleEmptyTag();\n    } else {\n      const tagTypeChar = this._char;\n      if (tagTypeChar === '{') {\n        this._handleVariableCurly();\n      } else {\n        let tagContentStart = this._index - 1;\n        //read content\n        while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n          this._read();\n        }\n\n        if (this._char === null) {\n          this._setError('Unclosed tag.');\n        } else {\n          const content = this._src.slice(tagContentStart, this._index - 1);\n          switch (tagTypeChar) {\n            case '>': this._handleSimpleTag(TokenType.PARTIAL, content); break;\n            case '^': this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content); break;\n            case '#': this._handleSimpleTag(TokenType.SECTION_OPEN, content); break;\n            case '/': this._handleSimpleTag(TokenType.SECTION_CLOSE, content); break;\n\n            case '!':\n              this._handleComment(content.substr(1));\n              break;\n\n            case '=':\n              this._handleDelimiterChange(content);\n              break;\n            case '&':\n              this._handleVariable(content.substr(1), true);\n              break;\n            default:\n              this._handleVariable(content);\n              break;\n          }\n        }\n      }\n    }\n    if (this._error === null) {\n      //eat right\n      for (let i = 0; i < right.length; i++) {\n        this._read();\n      }\n    }\n\n    this._state = STATE_NONE;\n  }\n\n  _handleDelimiterChange(content) {\n    const newDelimiters = extractNewDelimiters(content);\n    if (newDelimiters === null) {\n      this._setError('Invalid change delimiter syntax.');\n    } else {\n      const [ left, right ] = newDelimiters;\n      this._delimiters = newDelimiters;\n      this._makeToken({\n        type: TokenType.DELIMITER_CHANGE,\n        delimiters: [ left, right ]\n      });\n    }\n  }\n\n  _handleSimpleTag(type, content) {\n    this._makeToken({ type, name: content.substr(1).trim() });\n  }\n\n  _handleComment(content) {\n    this._makeToken({\n      type: TokenType.COMMENT,\n      content\n    });\n  }\n\n  _handleVariableCurly() {\n    this._read(); //eat '{'\n    const begin = this._index - 1;\n    const d = this._distance('}');\n    if (d === -1) {\n      this._setError('Unclosed variable tag: missingright curly.');\n    } else {\n      const content = this._src.slice(begin, begin + d);\n      this._skip(d + 1); //skip '}'\n      this._skipAllWhitespaces();\n      if (!this._isDelimiter(DELIMITER_RIGHT)) {\n        this._setError('Unclosed variable: missing right delimiter.');\n      } else {\n        this._makeToken({\n          type: TokenType.UNESCAPED_VARIABLE,\n          name: content.trim()\n        });\n      }\n    }\n  }\n\n  _handleEmptyTag() {\n    this._makeToken({\n      type: TokenType.VARIABLE,\n      name: ''\n    });\n  }\n\n  _handleVariable(content, unescaped) {\n    this._makeToken({\n      type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n      name: content.trim()\n    });\n  }\n\n  _handleText() {\n    let done = false;\n    let index = this._index - 1;\n    let length = 0;\n    do {\n      const c = this._char;\n\n      if (c === null || c === '\\n' || this._isDelimiter(DELIMITER_LEFT)) {\n        done = true;\n      } else {\n        length ++;\n      }\n\n      if (!done) {\n        this._read();\n      }\n    } while (!done);\n\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: this._src.slice(index, index + length)\n    });\n\n    this._state = STATE_NONE;\n  }\n\n  _handleTextBreak() {\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: '\\n'\n    });\n    this._read();\n    this._handleStandaloneTag();\n    this._state = STATE_NONE;\n  }\n\n  _handleStandaloneTag() {\n    this._tokens = trimStandaloneToken(this._tokens);\n  }\n\n  // Helpers\n  _dump(t = '') {\n    console.log(t +'>'+this._src.slice(this._index - 1));\n  }\n\n  _read() {\n    if (this._index < this._src.length) {\n      if (this._char === '\\n') {\n        this._line ++;\n        this._column = 0;\n      } else {\n        this._column ++;\n      }\n\n      this._char = this._src[this._index];\n      this._index ++;\n    } else {\n      this._char = null;\n    }\n  }\n\n  _peek() {\n    if (this._index < this._src.length - 1) {\n      return this._src[this._index];\n    } else {\n      return null;\n    }\n  }\n\n  _skip(n) {\n    for (let i = 0; i < n; i ++) {\n      this._read();\n    }\n  }\n\n  _distance(c) {\n    for (let i = this._index; i < this._src.length; i++) {\n      if (this._src[i] === c) {\n        return i - this._index + 1;\n      }\n    }\n    return -1;\n  }\n\n  _skipAllWhitespaces() {\n    while (this._isWhitespace()) {\n      this._read();\n    }\n  }\n\n  _markTokenStartLocation() {\n    this._location.index = this._index - 1;\n    this._location.line = this._line;\n    this._location.column = this._column;\n  }\n\n  _markTokenEndLocation() {\n    const token = this._tokens[this._tokens.length - 1];\n    token.location.endIndex = this._index - 1;\n    token.location.endLine = this._line;\n    token.location.endColumn = this._column;\n  }\n\n  _isWhitespace() {\n    return /\\s/.test(this._char);\n  }\n\n  _isDelimiter(d, offset = 0) {\n    const delimiter = this._delimiters[d];\n    const pos = this._index - 1 + offset;\n    return this._src.slice(pos, pos + delimiter.length) === delimiter;\n  }\n\n  _makeToken(token) {\n    token.filename = this._filename;\n    const { index, line, column } = this._location;\n    token.location = {\n      index, line, column\n    };\n    if (this._extensions.length) {\n      try {\n        this._extensions.forEach(ext => {\n          token = ext.transformToken(token);\n        });\n      } catch (e) {\n        this._setError(e.message);\n        return;\n      }\n    }\n    this._tokens.push(token);\n  }\n\n  _setError(message) {\n    const error = new Error(message);\n    error.filename = this._filename;\n    error.index = this._index - 1;\n    error.line = this._line;\n    error.column = this._column;\n    this._error = error;\n  }\n}\n\nconst R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  const matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/tokenizer.js\n **/","// https://github.com/mustache/spec/pull/75\n\nimport { Extension, register } from '../extension';\nimport * as NodeType from '../node';\nimport * as TokenType from '../token';\nimport { walk } from '../helpers';\n\nconst PARENT = 'Inheritance.PARENT';\nconst BLOCK = 'Inheritance.BLOCK';\nconst LEAVE_SCOPE = 'Inheritance.LEAVE_SCOPE';\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nexport class Inheritance extends Extension {\n  constructor() {\n    super();\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  transformToken(token) {\n    const { type, name, location } = token;\n    switch (type) {\n      case TokenType.VARIABLE:\n        if (name) {\n          if (name[0] === '<') {\n            if (name.length === 1) {\n              throw new Error('Parent partial name expected');\n            }\n            token = {\n              type: PARENT,\n              name: name.slice(1),\n              location\n            };\n          } else if (name[0] === '$') {\n            if (name.length === 1) {\n              throw new Error('Block name expected');\n            }\n            token = {\n              type: BLOCK,\n              name: name.slice(1),\n              location\n            };\n          }\n        }\n        break;\n    }\n    return token;\n  }\n\n  handleToken(token, parserContext) {\n    let handled = false;\n    const { name, location, type } = token;\n    switch (type) {\n      case PARENT:\n        parserContext.pushParent({\n          type: PARENT,\n          name,\n          location\n        });\n        handled = true;\n        break;\n\n      case BLOCK:\n        parserContext.pushParent({\n          type: BLOCK,\n          name,\n          location\n        });\n        break;\n\n      case TokenType.SECTION_CLOSE:\n        const tagNode = parserContext.tailNode;\n        if (tagNode === null) {\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.throw('Unexpected tag close');\n          }\n        } else {\n          if (tagNode.name !== name) {\n            parserContext.throw(`Unexpected tag close, current tag: ${tagNode.name}`);\n          }\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.popParent();\n            tagNode.location.endIndex = location.endIndex;\n            tagNode.location.endLine = location.endLine;\n            parserContext.appendNode(tagNode);\n\n            //TODO move this to visit, handle whitespaces after Parent close tag.\n            const firstLine = tagNode.location.line;\n            const firstBlock = tagNode.children.find(c => c.type === BLOCK);\n            if (firstBlock && firstBlock.location.line === firstLine) {\n              for (let i = 0; i < firstBlock.children.length; i++) {\n                const blockNode = firstBlock.children[i];\n                if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n                  blockNode.text = '';\n                } else {\n                  break;\n                }\n              }\n            }\n\n            handled = true;\n          }\n        }\n        break;\n\n      case TokenType.EOF:\n        if (this.top > 0) {\n          parserContext.throw('Unexpected EOF: tags not closed: ' + \n            this.stack.map(f => f.name).join(', '));\n        }\n        break;\n    }\n    return handled;\n  }\n\n  handleNode(node, rendererContext) {\n    const top = rendererContext.top;\n    this._checkTop(top);\n\n    switch (node.type) {\n      case PARENT:\n        this._handleParent(node, rendererContext);\n        return true;\n\n      case BLOCK:\n        this._handleBlock(node, rendererContext);\n        return true;\n\n      case LEAVE_SCOPE:\n        this._blocks = null;\n        return true;\n    }\n  }\n\n  _handleParent(node, rendererContext) {\n    const { name, location } = node;\n    const top = rendererContext.top;\n\n    this._pushParent(name, top);\n\n    if (this._blocks === null) {\n      rendererContext.pushNodes([\n        {\n          type: LEAVE_SCOPE\n        }\n      ]);\n      this._blocks = {};\n    }\n\n    //find all blocks defined in parent\n    const blocks = {};\n    node.children.forEach(child => {\n      if (child.type === BLOCK) {\n        const blockName = child.name;\n        blocks[blockName] = child;\n      }\n    });\n    if (Object.keys(blocks).length) {\n      this._setDefaultBlocks(blocks);\n    }\n\n    rendererContext.pushNode({\n      type: TokenType.PARTIAL,\n      name, location,\n      indent: node.indent,\n    });\n  }\n\n  _handleBlock(node, rendererContext) {\n    const { name } = node;\n    const defaultBlock = this._getDefaultBlock(name);\n    if (defaultBlock) {\n      rendererContext.pushNodes(defaultBlock.children);\n    } else {\n      rendererContext.pushNodes(node.children);\n    }\n  }\n\n  _pushParent(name, top) {\n    return this._parentStack.push({\n      name,\n      blocks: {},\n      top\n    });\n  }\n\n  _checkTop(top) {\n    let pop = 0;\n    for (let i = this._parentStack.length - 1; i >= 0; i--) {\n      const frame = this._parentStack[i];\n      if (frame.top > top) {\n        pop ++;\n      } else {\n        break;\n      }\n    }\n    if (pop > 0) {\n      this._parentStack = this._parentStack.slice(0, this._parentStack.length - pop);\n    }\n  }\n\n  _popParent() {\n    return this._parentStack.pop();\n  }\n\n  _getDefaultBlock(name) {\n    for (let i = 0; i < this._parentStack.length; i++) {\n      const frame = this._parentStack[i];\n      if (name in frame.blocks) {\n        return frame.blocks[name];\n      } \n    }\n    return null;\n  }\n\n  _setDefaultBlocks(blocks) {\n    const topFrame = this._parentStack[this._parentStack.length - 1];\n    topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/extensions/inheritance.js\n **/","import * as nodeTypes from './node';\nimport escapeHTML from 'escape-html';\nimport { Parser } from './parser';\nimport { walk, visit } from './helpers';\nimport { instantiateAll } from './extension';\n\nconst REPEATER_NODE_TYPE  = '_REPEATER';\nconst MAX_PARTIAL_STACK = 10;\nconst MAX_LAMBDA_STACK = 255;\n\nclass RenderContext {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n\n  get top() {\n    return this._renderer._stack.length;\n  }\n\n  get result() {\n    return this._renderer._out;\n  }\n\n  evaluate(name) {\n    return this._renderer._evaluate(name);\n  }\n\n  pushNodes(nodes) {\n    this._renderer._pushNodes(nodes);\n  }\n\n  pushNode(node) {\n    this._renderer._pushNode(node);\n  }\n\n  pushContext(ctx) {\n    this._renderer._pushContext(ctx);\n  }\n\n  appendText(text) {\n    this._renderer._out += text;\n  }\n\n  parse(src, opts) {\n    return this._renderer._parse(src, opts);\n  }\n\n  getParsedPartial(name) {\n    return this._renderer._getParsedPartial(name);\n  }\n\n  throw(message, location) {\n    return this._renderer._throw(message, location);\n  }\n}\n\nexport class Renderer {\n  constructor(src, opts = {}) {\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    \n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(k => {\n        this._partialCached[k] = this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = '';\n    this._transformNodeResult = (node, result, nodeResult) =>\n      this._extensions.reduce((r, e) => e.transformNodeResult(node, result, r), nodeResult);\n  }\n\n  render(context) {\n    this._out = '';\n    this._stack = [];\n    this._contextStack = [];\n    this._partialStack = [];\n    this._lambdaStack = [];\n\n    this._pushContext(context);\n\n    //push root nodes\n    const rootNode = this._parsed ? this._src : this._parse(this._src);\n    this._stack = rootNode.children.slice(0).reverse();\n\n    let newline = true;\n    while (this._stack.length > 0) {\n      const top = this._stack.length - 1;\n      const node = this._stack[top];\n\n      let handled = false;\n      if (this._extensions) {\n        this._extensions.forEach(ext => {\n          if (ext.handleNode(node, this._renderContext)) {\n            handled = true;\n          }\n        });\n      }\n\n      if (handled) {\n        this._stack.splice(top, 1);\n      } else {\n        const partial = this._partialStack.length ? this._partialStack[this._partialStack.length - 1] : null;\n\n        //insert indent\n        if (node.type in nodeTypes) {\n          if (newline && partial !== null && partial.indent.length > 0) {\n            this._out += partial.indent;\n          }\n        }\n\n        let value;\n        switch (node.type) {\n          case nodeTypes.VARIABLE:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              if (!!value) {\n                const result = node.unescaped ? value : escapeHTML(value);\n                this._out += this._transformNodeResult(node, this._out, result);\n              }\n              this._popNode();\n            }\n            break;\n\n          case nodeTypes.SECTION:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              let isList = Array.isArray(value);\n\n              if (isList && value.length === 0) {\n                //Empty lists should behave like falsey values.\n                value = false;\n                isList = false;\n              }\n\n              let testResult = !!value;\n              if (node.inverted) {\n                testResult = !testResult;\n              }\n\n              if (testResult) {\n                if (isList) {\n                  this._popNode();\n                  this._pushRepeaterNode(value.length, node.children, value);\n                } else {\n                  this._popNode()\n                  this._pushContext(value);\n                  this._pushNodes(node.children);\n                }\n              } else {\n                this._popNode();\n              }\n            }\n            break;\n\n          case nodeTypes.TEXT:\n            this._out += this._transformNodeResult(node, this._out, node.text);\n            this._popNode()\n            break;\n\n          case nodeTypes.COMMENT:\n            this._popNode();\n            break;\n\n          case nodeTypes.PARTIAL:\n            this._popNode();\n            this._expandPartial(node);\n            break;\n\n          case nodeTypes.DELIMITER_CHANGE:\n            this._popNode();\n            this._delimiters = node.delimiters.slice(0);\n            break;\n\n          case REPEATER_NODE_TYPE:\n            if (node.count < node.repeat) {\n              const repeatIndex = node.count;\n              if (repeatIndex === 0) {\n                node.contextIndex = this._pushContext(node.contexts[0]);\n              } else {\n                this._replaceContextAt(node.contextIndex, node.contexts[repeatIndex]);\n              }\n              this._pushNodes(node.children);\n              node.count ++;\n            } else {\n              this._popNode();\n            }\n            break;\n\n          default:\n            this._popNode();\n            break;\n        }\n      }\n      this._checkStacks();\n      newline = this._out.length === 0 || (this._out[this._out.length -1 ] === '\\n');\n    }\n\n    return this._extensions.reduce((result, ext) => ext.transformResult(result), this._out);\n  }\n\n  _parse(src, opts = {}) {\n    opts.extensions = this._extensions;\n    const parser = new Parser(opts);\n    return parser.parse(src);\n  }\n\n  _pushNodes(list) {\n    for (let i = list.length - 1; i >= 0; i --) {\n      this._stack.push(list[i]);\n    }\n  }\n\n  _pushNode(node) {\n    this._stack.push(node);\n  }\n\n  _popNode() {\n    this._stack.pop();\n  }\n\n  _pushRepeaterNode(repeat, nodes, contexts) {\n    this._stack.push({\n      type: REPEATER_NODE_TYPE,\n      count: 0,\n      repeat,\n      children: nodes.slice(0),\n      contexts\n    });\n  }\n\n  _pushContext(context) {\n    return this._contextStack.push({\n      context,\n      sp: this._stack.length\n    }) - 1;\n  }\n\n  _replaceContextAt(index, context) {\n    if (index < 0 || index > this._contextStack.length - 1) {\n      throw new RangeError('Huz context index out of range.');\n    }\n    this._contextStack[index].context = context;\n  }\n\n  _pushPartial({ name, indent, location }) {\n    this._partialStack.push({\n      name,\n      indent: indent || '',\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _pushLambda({ name, location }) {\n    this._lambdaStack.push({\n      name,\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _checkStacks() {\n    if (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n      this._contextStack.pop();\n    }\n\n    if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n      this._partialStack.pop();\n    }\n\n    if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n      this._lambdaStack.pop();\n    }\n  }\n\n  _evaluate(name) {\n    if (name === '.') {\n      return this._contextStack[this._contextStack.length - 1].context;\n    }\n\n    const path = name.split('.');\n    for (let i = this._contextStack.length - 1; i >= 0; i--) {\n      const context = this._contextStack[i].context;\n      if (context === null || typeof context !== 'object') {\n        continue;\n      }\n\n      let current = context;\n      let resolved = true;\n      for (let pi = 0; pi < path.length; pi++) {\n        const key = path[pi];\n        if (typeof current === 'object' && current !== null && current.hasOwnProperty(key)) {\n          current = current[key];\n        } else {\n          resolved = false;\n          break;\n        }\n      }\n\n      if (resolved) {\n        return current;\n      }\n    }\n    return '';\n  }\n\n  _getParsedPartial(name) {\n    if (this._partialCached.hasOwnProperty(name)) {\n      return this._partialCached[name];\n    } else {\n      if (!this._partials.hasOwnProperty(name)) {\n        return null;\n      }\n      const ast = this._parse(this._partials[name], { filename: name });\n      const nodes = this._partialCached[name] = ast.children;\n      return nodes;\n    }\n  }\n\n  _expandPartial(node) {\n    const { name } = node;\n    const nodes = this._getParsedPartial(name);\n\n    if (nodes === null) {\n      //The empty string should be used when the named partial is not found.\n      return;\n    }\n\n    this._pushPartial(node);\n\n    if (this._partialStack.length > MAX_PARTIAL_STACK) {\n      this._throw(\n        'Possible partial short circuit: ' +\n          this._partialStack.map(f => `${f.name}@${f.location.filename}:${f.location.line+1}`).concat([name]).join(' -> '),\n        node.location\n      );\n    }\n\n    this._pushNodes(nodes);\n  }\n\n  _expandLambda(node, lambda) {\n    const { name } = node;\n\n    this._pushLambda(node);\n\n    if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n      this._throw(\n        'Possible lambda short circuit: ' +\n          this._lambdaStack.map(f => `${f.name}@${f.location.filename}:${f.location.line+1}`).concat([name]).join(' -> '),\n        node.location\n      );\n    }\n\n    let ast;\n    let skipped = false;\n    if (node.type === nodeTypes.VARIABLE) {\n      const code = lambda();\n      if (code) {\n        //A lambda's return value should parse with the default delimiters.\n        ast = this._parse('' + code, { filename: '[lambda]' });\n        if (!node.unescaped) {\n          //Lambda results should be appropriately escaped.\n          walk(ast, node => {\n            if (node.type === nodeTypes.TEXT) {\n              node.text = escapeHTML(node.text);\n            }\n          });\n        }\n      } else {\n        skipped = true;\n      }\n    } else if (node.type === nodeTypes.SECTION) {\n      const code = lambda(node.raw);\n      if (code) {\n        //Lambdas used for inverted sections should be considered truthy.\n        //Lambdas used for sections should parse with the current delimiters.\n        ast = this._parse('' + code, {\n          filename: '[#lambda]',\n          delimiters: this._delimiters.slice(0)\n        });\n      } else {\n        skipped = true;\n      }\n    }\n\n    if (!skipped) {\n      this._pushNodes(ast.children);\n    }\n  }\n\n  _throw(message, location) {\n    const e = new Error(message);\n    e.location = location;\n    throw e;\n  }\n}\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == '[object Function]';\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/renderer.js\n **/","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escape-html/index.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}