{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///huz.js","webpack:///webpack/bootstrap 6d3aa36ad276daf73657","webpack:///./src/extension.js","webpack:///./src/token.js","webpack:///./src/helpers.js","webpack:///./src/node.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js","webpack:///./src/extensions/inheritance.js","webpack:///./src/renderer.js","webpack:///./src/index.js","webpack:///./~/escape-html/index.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","instantiateAll","opts","registry","map","ctor","register","constructor","push","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Extension","token","parserContext","node","renderContext","result","nodeResult","EOF","TEXT","PARTIAL","INVERTED_SECTION_OPEN","SECTION_OPEN","SECTION_CLOSE","UNESCAPED_VARIABLE","COMMENT","VARIABLE","DELIMITER_CHANGE","walk","modifier","stack","children","slice","reverse","pop","undefined","concat","visit","visitor","_parent","child","modified","trimStandaloneToken","tokens","count","open","inline","standalone","indentTokens","type","TokenType","isStringWhitespace","text","tailWSNodeCount","indent","forEach","t","str","test","_token","obj","newObj","ROOT","SECTION","_interopRequireWildcard","_node","NodeType","_tokenizer","_extension","ParserContext","parser","_parser","_appendNode","_pushParent","_popParent","f","_stack","item","message","_throw","_filename","Parser","arguments","_delimiters","delimiters","_extensions","extensions","filename","_parserContext","_lastToken","_src","src","rootNode","_parseNodes","_addNodeToken","location","JSON","parse","stringify","beginLocation","endLocation","_clone","endIndex","endLine","initialStackSize","z","Tokenizer","getNextToken","error","handled","ext","handleToken","_makeLocation","unescaped","_handleSectionOpen","_handleSectionClose","_handleComment","join","e","Error","inverted","section","raw","index","content","extractNewDelimiters","tagContent","matches","match","R_DELIMITER_CHANGE","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","Array","isArray","_helpers","STATE_NONE","_index","_char","_tokens","_line","_column","_state","_error","_location","line","column","shift","matched","_markTokenStartLocation","_read","_handleEOF","_handleText","_handleTextBreak","_handleTag","_markTokenEndLocation","_isDelimiter","_handleStandaloneTag","_makeToken","left","right","_skip","_skipAllWhitespaces","_setError","_handleEmptyTag","tagTypeChar","_handleVariableCurly","tagContentStart","_handleSimpleTag","substr","_handleDelimiterChange","_handleVariable","newDelimiters","_newDelimiters","trim","begin","_distance","console","log","_isWhitespace","endColumn","offset","delimiter","pos","transformToken","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","isInheritanceTagType","PARENT","BLOCK","_get","_x","_x2","_x3","_again","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_token2","Inheritance","_Extension","_blocks","_parentStack","pushParent","_pushBlock","tagNode","tailNode","popParent","appendNode","firstLine","firstBlock","find","blockNode","top","rendererContext","_checkTop","_handleParent","_handleBlock","findParentNode","pushNodes","blocks","blockName","keys","_setDefaultBlocks","pushNode","defaultBlock","_getDefaultBlock","frame","topFrame","assign","isFunction","x","toString","nodeTypes","_escapeHtml","_escapeHtml2","default","RenderContext","renderer","_renderer","_evaluate","nodes","_pushNodes","_pushNode","ctx","_pushContext","_out","_parse","_getParsedPartial","Renderer","_this","_parsed","parsed","_partials","partials","_renderContext","_partialCached","k","_contextStack","_partialStack","_lambdaStack","_transformNodeResult","reduce","r","transformNodeResult","context","_this2","node_count","newline","handleNode","splice","partial","_popNode","_expandLambda","isList","testResult","_pushRepeaterNode","_expandPartial","repeat","repeatIndex","contextIndex","contexts","_replaceContextAt","_checkStacks","transformResult","list","sp","RangeError","_ref","_ref2","path","split","current","resolved","pi","ast","_pushPartial","lambda","_pushLambda","skipped","code","compile","render","Helpers","_extensionsInheritance","escapeHtml","string","matchHtmlRegExp","exec","escape","html","lastIndex","charCodeAt","substring"],"mappings":"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","file":"huz.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.instantiateAll = instantiateAll;\nexports.register = register;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar registry = [];\n\nvar Extension = (function () {\n  function Extension() {\n    _classCallCheck(this, Extension);\n  }\n\n  _createClass(Extension, [{\n    key: \"transformToken\",\n\n    //called by tokenizer\n    value: function transformToken(token) {\n      return token;\n    }\n\n    //called by parser\n  }, {\n    key: \"handleToken\",\n    value: function handleToken(token, parserContext) {}\n  }, {\n    key: \"visit\",\n    value: function visit(root) {\n      return root;\n    }\n\n    //called by renderer\n  }, {\n    key: \"handleNode\",\n    value: function handleNode(node, renderContext) {}\n  }, {\n    key: \"transformNodeResult\",\n    value: function transformNodeResult(node, result, nodeResult) {\n      return nodeResult;\n    }\n  }, {\n    key: \"transformResult\",\n    value: function transformResult(result) {\n      return result;\n    }\n  }]);\n\n  return Extension;\n})();\n\nexports.Extension = Extension;\n\nfunction instantiateAll(opts) {\n  return registry.map(function (ctor) {\n    return new ctor(opts);\n  });\n}\n\nfunction register(constructor) {\n  return registry.push(constructor);\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar EOF = 'EOF';\nexports.EOF = EOF;\nvar TEXT = 'TEXT';\nexports.TEXT = TEXT;\nvar PARTIAL = 'PARTIAL';\nexports.PARTIAL = PARTIAL;\nvar INVERTED_SECTION_OPEN = 'INVERTED_SECTION_OPEN';\nexports.INVERTED_SECTION_OPEN = INVERTED_SECTION_OPEN;\nvar SECTION_OPEN = 'SECTION_OPEN';\nexports.SECTION_OPEN = SECTION_OPEN;\nvar SECTION_CLOSE = 'SECTION_CLOSE';\nexports.SECTION_CLOSE = SECTION_CLOSE;\nvar UNESCAPED_VARIABLE = 'UNESCAPED_VARIABLE';\nexports.UNESCAPED_VARIABLE = UNESCAPED_VARIABLE;\nvar COMMENT = 'COMMENT';\nexports.COMMENT = COMMENT;\nvar VARIABLE = 'VARIABLE';\nexports.VARIABLE = VARIABLE;\nvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\nexports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.walk = walk;\nexports.visit = visit;\nexports.trimStandaloneToken = trimStandaloneToken;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nfunction walk(root, modifier) {\n  var stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    var node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nfunction visit(root, visitor) {\n  var stack = [root];\n  while (stack.length) {\n    var _parent = stack.pop();\n    for (var i = 0; i < _parent.children.length; i++) {\n      var child = _parent.children[i];\n      var modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        _parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nfunction trimStandaloneToken(tokens) {\n  var count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  var open = null;\n  var inline = 0;\n  var standalone = true;\n  var indentTokens = [];\n  for (var i = 0; standalone && i < count; i++) {\n    var token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline++;\n        }\n        break;\n      default:\n        //section-like tags\n        if (open === null) {\n          open = [token];\n          inline++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n\n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    var tailWSNodeCount = 0;\n    for (var i = count - 1; i >= 0; i--) {\n      var token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        var indent = '';\n        indentTokens.forEach(function (t) {\n          indent += t.text;\n        });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return (/^\\s*$/.test(str)\n  );\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar ROOT = 'ROOT';\nexports.ROOT = ROOT;\nvar VARIABLE = 'VARIABLE';\nexports.VARIABLE = VARIABLE;\nvar SECTION = 'SECTION';\nexports.SECTION = SECTION;\nvar TEXT = 'TEXT';\nexports.TEXT = TEXT;\nvar COMMENT = 'COMMENT';\nexports.COMMENT = COMMENT;\nvar PARTIAL = 'PARTIAL';\nexports.PARTIAL = PARTIAL;\nvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\nexports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _tokenizer = __webpack_require__(5);\n\nvar _helpers = __webpack_require__(2);\n\nvar _extension = __webpack_require__(0);\n\nvar ParserContext = (function () {\n  function ParserContext(parser) {\n    _classCallCheck(this, ParserContext);\n\n    this._parser = parser;\n  }\n\n  _createClass(ParserContext, [{\n    key: \"appendNode\",\n    value: function appendNode(node) {\n      this._parser._appendNode(node);\n    }\n  }, {\n    key: \"pushParent\",\n    value: function pushParent(node) {\n      this._parser._pushParent(node);\n    }\n  }, {\n    key: \"popParent\",\n    value: function popParent() {\n      return this._parser._popParent();\n    }\n  }, {\n    key: \"findParentNode\",\n    value: function findParentNode(f) {\n      for (var i = this._parser._stack.length - 1; i >= 0; i--) {\n        var item = this._parser._stack[i];\n        if (f(item)) {\n          return item;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(message) {\n      return this._parser._throw(message);\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._parser._filename;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._parser._stack.length;\n    }\n  }, {\n    key: \"tailNode\",\n    get: function get() {\n      return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n    }\n  }]);\n\n  return ParserContext;\n})();\n\nvar Parser = (function () {\n  function Parser() {\n    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, Parser);\n\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n    this._filename = opts.filename || \"\";\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(src) {\n      var rootNode = {\n        type: NodeType.ROOT,\n        children: []\n      };\n      this._src = src;\n      this._stack = [rootNode];\n      this._lastToken = null;\n      this._parseNodes(src);\n\n      if (this._extensions.length > 0) {\n        for (var i = 0; i < this._extensions.length; i++) {\n          this._extensions[i].visit(rootNode);\n        }\n      }\n\n      return rootNode;\n    }\n  }, {\n    key: \"_addNodeToken\",\n    value: function _addNodeToken(node) {\n      var token = this._lastToken;\n      if (node.tokens) {\n        node.tokens.push(token);\n      } else {\n        node.tokens = [token];\n      }\n    }\n  }, {\n    key: \"_appendNode\",\n    value: function _appendNode(node) {\n      this._addNodeToken(node);\n      node.location.filename = this._filename;\n      this._stack[this._stack.length - 1].children.push(node);\n      return node;\n    }\n  }, {\n    key: \"_getTop\",\n    value: function _getTop() {\n      return this._stack[this._stack.length - 1];\n    }\n  }, {\n    key: \"_clone\",\n    value: function _clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  }, {\n    key: \"_makeLocation\",\n    value: function _makeLocation(beginLocation, endLocation) {\n      var location = this._clone(beginLocation);\n      if (endLocation) {\n        location.endIndex = endLocation.endIndex;\n        location.endLine = endLocation.endLine;\n      }\n      return location;\n    }\n  }, {\n    key: \"_parseNodes\",\n    value: function _parseNodes(src) {\n      var initialStackSize = this._stack.length;\n      var token = undefined;\n      var z = new _tokenizer.Tokenizer(src, {\n        delimiters: this._delimiters.slice(0),\n        extensions: this._extensions,\n        filename: this._filename\n      });\n\n      do {\n        token = z.getNextToken();\n\n        if (z.error !== null) {\n          throw z.error;\n        }\n\n        this._lastToken = token;\n\n        var handled = false;\n        if (this._extensions) {\n          for (var i = 0; i < this._extensions.length; i++) {\n            var ext = this._extensions[i];\n            if (ext.handleToken(token, this._parserContext) === true) {\n              handled = true;\n              break;\n            }\n          }\n        }\n\n        if (!handled) {\n          switch (token.type) {\n            case TokenType.TEXT:\n              this._appendNode({\n                type: NodeType.TEXT,\n                text: token.text,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.VARIABLE:\n            case TokenType.UNESCAPED_VARIABLE:\n              this._appendNode({\n                type: NodeType.VARIABLE,\n                name: token.name,\n                unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.SECTION_OPEN:\n              this._handleSectionOpen(token);\n              break;\n\n            case TokenType.INVERTED_SECTION_OPEN:\n              this._handleSectionOpen(token, true);\n              break;\n\n            case TokenType.SECTION_CLOSE:\n              this._handleSectionClose(token);\n              break;\n\n            case TokenType.PARTIAL:\n              this._appendNode({\n                type: NodeType.PARTIAL,\n                name: token.name,\n                indent: token.indent,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.COMMENT:\n              this._handleComment(token);\n              break;\n\n            case TokenType.DELIMITER_CHANGE:\n              this._appendNode({\n                type: NodeType.DELIMITER_CHANGE,\n                delimiters: token.delimiters,\n                location: this._makeLocation(token.location)\n              });\n              break;\n          }\n        }\n      } while (token.type !== TokenType.EOF);\n\n      if (this._stack.length > initialStackSize) {\n        this._throw(\"Unexpected EOF: sections not closed: \" + this._stack.slice(initialStackSize).map(function (n) {\n          return \"'\" + n.name + \"'\";\n        }).join(\", \"));\n      } else if (this._stack.length < initialStackSize) {\n        this._throw(\"Internal error.\");\n      }\n    }\n  }, {\n    key: \"_throw\",\n    value: function _throw(message) {\n      var e = new Error(message);\n      e.filename = this._lastToken.location.filename;\n      e.location = this._lastToken.location;\n      throw e;\n    }\n  }, {\n    key: \"_pushParent\",\n    value: function _pushParent(node) {\n      this._addNodeToken(node);\n      node.children = [];\n      this._stack.push(node);\n    }\n  }, {\n    key: \"_popParent\",\n    value: function _popParent() {\n      return this._stack.pop();\n    }\n  }, {\n    key: \"_handleSectionOpen\",\n    value: function _handleSectionOpen(token) {\n      var inverted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n      var name = token.name;\n      var location = token.location;\n\n      this._pushParent({\n        type: NodeType.SECTION,\n        name: name,\n        inverted: inverted,\n        location: location\n      });\n    }\n  }, {\n    key: \"_handleSectionClose\",\n    value: function _handleSectionClose(token) {\n      var name = token.name;\n      var location = token.location;\n\n      var section = this._popParent();\n      if (section.type !== NodeType.SECTION) {\n        this._throw(\"Unexpected SECTION_CLOSE: '\" + name + \"'\");\n      }\n\n      if (section.name !== name) {\n        this._throw(\"Unexpected SECTION_CLOSE: '\" + name + \"', current section: '\" + section.name + \"'\");\n      }\n\n      section.raw = this._src.slice(section.location.endIndex, location.index);\n      section.location = this._makeLocation(section.location, token.location);\n\n      this._appendNode(section);\n    }\n  }, {\n    key: \"_handleComment\",\n    value: function _handleComment(token) {\n      var content = token.content;\n      var location = token.location;\n\n      this._appendNode({\n        type: NodeType.COMMENT,\n        content: content,\n        location: this._makeLocation(location)\n      });\n    }\n  }]);\n\n  return Parser;\n})();\n\nexports.Parser = Parser;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; })();\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _extension = __webpack_require__(0);\n\nvar _helpers = __webpack_require__(2);\n\nvar STATE_NONE = \"STATE_NONE\";\nvar STATE_EOF = \"STATE_EOF\";\nvar STATE_TEXT = \"STATE_TEXT\";\nvar STATE_TEXT_BREAK = \"STATE_TEXT_BREAK\";\nvar STATE_TAG = \"STATE_TAG\";\n\nvar DELIMITER_LEFT = 0;\nvar DELIMITER_RIGHT = 1;\n\nvar Tokenizer = (function () {\n  function Tokenizer(src) {\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Tokenizer);\n\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 0;\n    this._column = 0;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n  }\n\n  _createClass(Tokenizer, [{\n    key: \"getNextToken\",\n    value: function getNextToken() {\n      if (this._tokens.length > 0) {\n        return this._tokens.shift();\n      }\n\n      var done = false;\n      var matched = false;\n      do {\n        //console.log(this._state, this._tokens);\n        if (this._error !== null) {\n          return null;\n        }\n\n        if (this._state !== STATE_NONE) {\n          matched = true;\n          this._markTokenStartLocation();\n        }\n\n        switch (this._state) {\n          case STATE_NONE:\n            this._read();\n            break;\n\n          case STATE_EOF:\n            this._handleEOF();\n            done = true;\n            break;\n\n          case STATE_TEXT:\n            this._handleText();\n            break;\n\n          case STATE_TEXT_BREAK:\n            this._handleTextBreak();\n            done = true;\n            break;\n\n          case STATE_TAG:\n            this._handleTag();\n            break;\n        }\n\n        if (matched && !this._error) {\n          this._markTokenEndLocation();\n          matched = false;\n        }\n\n        if (this._state === STATE_NONE) {\n          if (this._char === null) {\n            this._state = STATE_EOF;\n          } else if (this._char === \"\\n\") {\n            this._state = STATE_TEXT_BREAK;\n          } else if (this._isDelimiter(DELIMITER_LEFT)) {\n            this._state = STATE_TAG;\n          } else {\n            this._state = STATE_TEXT;\n          }\n        }\n      } while (!done);\n\n      return this._error === null ? this._tokens.shift() : null;\n    }\n\n    // Handlers\n\n  }, {\n    key: \"_handleEOF\",\n    value: function _handleEOF() {\n      this._handleStandaloneTag();\n      this._makeToken({\n        type: TokenType.EOF\n      });\n    }\n  }, {\n    key: \"_handleTag\",\n    value: function _handleTag() {\n      var _delimiters = _slicedToArray(this._delimiters, 2);\n\n      var left = _delimiters[0];\n      var right = _delimiters[1];\n\n      this._skip(left.length);\n      this._skipAllWhitespaces();\n\n      if (this._char === null) {\n        this._setError(\"Unclosed tag.\");\n      } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n        this._handleEmptyTag();\n      } else {\n        var tagTypeChar = this._char;\n        if (tagTypeChar === \"{\") {\n          this._handleVariableCurly();\n        } else {\n          var tagContentStart = this._index - 1;\n          //read content\n          while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n            this._read();\n          }\n\n          if (this._char === null) {\n            this._setError(\"Unclosed tag.\");\n          } else {\n            var content = this._src.slice(tagContentStart, this._index - 1);\n            switch (tagTypeChar) {\n              case \">\":\n                this._handleSimpleTag(TokenType.PARTIAL, content);\n                break;\n              case \"^\":\n                this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);\n                break;\n              case \"#\":\n                this._handleSimpleTag(TokenType.SECTION_OPEN, content);\n                break;\n              case \"/\":\n                this._handleSimpleTag(TokenType.SECTION_CLOSE, content);\n                break;\n\n              case \"!\":\n                this._handleComment(content.substr(1));\n                break;\n\n              case \"=\":\n                this._handleDelimiterChange(content);\n                break;\n              case \"&\":\n                this._handleVariable(content.substr(1), true);\n                break;\n              default:\n                this._handleVariable(content);\n                break;\n            }\n          }\n        }\n      }\n      if (this._error === null) {\n        //eat right\n        for (var i = 0; i < right.length; i++) {\n          this._read();\n        }\n      }\n\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleDelimiterChange\",\n    value: function _handleDelimiterChange(content) {\n      var newDelimiters = extractNewDelimiters(content);\n      if (newDelimiters === null) {\n        this._setError(\"Invalid change delimiter syntax.\");\n      } else {\n        var _newDelimiters = _slicedToArray(newDelimiters, 2);\n\n        var left = _newDelimiters[0];\n        var right = _newDelimiters[1];\n\n        this._delimiters = newDelimiters;\n        this._makeToken({\n          type: TokenType.DELIMITER_CHANGE,\n          delimiters: [left, right]\n        });\n      }\n    }\n  }, {\n    key: \"_handleSimpleTag\",\n    value: function _handleSimpleTag(type, content) {\n      this._makeToken({ type: type, name: content.substr(1).trim() });\n    }\n  }, {\n    key: \"_handleComment\",\n    value: function _handleComment(content) {\n      this._makeToken({\n        type: TokenType.COMMENT,\n        content: content\n      });\n    }\n  }, {\n    key: \"_handleVariableCurly\",\n    value: function _handleVariableCurly() {\n      this._read(); //eat '{'\n      var begin = this._index - 1;\n      var d = this._distance(\"}\");\n      if (d === -1) {\n        this._setError(\"Unclosed variable tag: missingright curly.\");\n      } else {\n        var content = this._src.slice(begin, begin + d);\n        this._skip(d + 1); //skip '}'\n        this._skipAllWhitespaces();\n        if (!this._isDelimiter(DELIMITER_RIGHT)) {\n          this._setError(\"Unclosed variable: missing right delimiter.\");\n        } else {\n          this._makeToken({\n            type: TokenType.UNESCAPED_VARIABLE,\n            name: content.trim()\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_handleEmptyTag\",\n    value: function _handleEmptyTag() {\n      this._makeToken({\n        type: TokenType.VARIABLE,\n        name: \"\"\n      });\n    }\n  }, {\n    key: \"_handleVariable\",\n    value: function _handleVariable(content, unescaped) {\n      this._makeToken({\n        type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n        name: content.trim()\n      });\n    }\n  }, {\n    key: \"_handleText\",\n    value: function _handleText() {\n      var done = false;\n      var index = this._index - 1;\n      var length = 0;\n      do {\n        var c = this._char;\n\n        if (c === null || c === \"\\n\" || this._isDelimiter(DELIMITER_LEFT)) {\n          done = true;\n        } else {\n          length++;\n        }\n\n        if (!done) {\n          this._read();\n        }\n      } while (!done);\n\n      this._makeToken({\n        type: TokenType.TEXT,\n        text: this._src.slice(index, index + length)\n      });\n\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleTextBreak\",\n    value: function _handleTextBreak() {\n      this._makeToken({\n        type: TokenType.TEXT,\n        text: \"\\n\"\n      });\n      this._read();\n      this._handleStandaloneTag();\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleStandaloneTag\",\n    value: function _handleStandaloneTag() {\n      this._tokens = (0, _helpers.trimStandaloneToken)(this._tokens);\n    }\n\n    // Helpers\n  }, {\n    key: \"_dump\",\n    value: function _dump() {\n      var t = arguments.length <= 0 || arguments[0] === undefined ? \"\" : arguments[0];\n\n      console.log(t + \">\" + this._src.slice(this._index - 1));\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      if (this._index < this._src.length) {\n        if (this._char === \"\\n\") {\n          this._line++;\n          this._column = 0;\n        } else {\n          this._column++;\n        }\n\n        this._char = this._src[this._index];\n        this._index++;\n      } else {\n        this._char = null;\n      }\n    }\n  }, {\n    key: \"_peek\",\n    value: function _peek() {\n      if (this._index < this._src.length - 1) {\n        return this._src[this._index];\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_skip\",\n    value: function _skip(n) {\n      for (var i = 0; i < n; i++) {\n        this._read();\n      }\n    }\n  }, {\n    key: \"_distance\",\n    value: function _distance(c) {\n      for (var i = this._index; i < this._src.length; i++) {\n        if (this._src[i] === c) {\n          return i - this._index + 1;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"_skipAllWhitespaces\",\n    value: function _skipAllWhitespaces() {\n      while (this._isWhitespace()) {\n        this._read();\n      }\n    }\n  }, {\n    key: \"_markTokenStartLocation\",\n    value: function _markTokenStartLocation() {\n      this._location.index = this._index - 1;\n      this._location.line = this._line;\n      this._location.column = this._column;\n    }\n  }, {\n    key: \"_markTokenEndLocation\",\n    value: function _markTokenEndLocation() {\n      var token = this._tokens[this._tokens.length - 1];\n      token.location.endIndex = this._index - 1;\n      token.location.endLine = this._line;\n      token.location.endColumn = this._column;\n    }\n  }, {\n    key: \"_isWhitespace\",\n    value: function _isWhitespace() {\n      return (/\\s/.test(this._char)\n      );\n    }\n  }, {\n    key: \"_isDelimiter\",\n    value: function _isDelimiter(d) {\n      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      var delimiter = this._delimiters[d];\n      var pos = this._index - 1 + offset;\n      return this._src.slice(pos, pos + delimiter.length) === delimiter;\n    }\n  }, {\n    key: \"_makeToken\",\n    value: function _makeToken(token) {\n      token.filename = this._filename;\n      var _location = this._location;\n      var index = _location.index;\n      var line = _location.line;\n      var column = _location.column;\n\n      token.location = {\n        filename: this._filename,\n        index: index,\n        line: line,\n        column: column\n      };\n      if (this._extensions.length) {\n        try {\n          this._extensions.forEach(function (ext) {\n            token = ext.transformToken(token);\n          });\n        } catch (e) {\n          this._setError(e.message);\n          return;\n        }\n      }\n      this._tokens.push(token);\n    }\n  }, {\n    key: \"_setError\",\n    value: function _setError(message) {\n      var error = new Error(message);\n      error.filename = this._filename;\n      error.index = this._index - 1;\n      error.line = this._line;\n      error.column = this._column;\n      this._error = error;\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      return this._error;\n    }\n  }]);\n\n  return Tokenizer;\n})();\n\nexports.Tokenizer = Tokenizer;\n\nvar R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  var matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// https://github.com/mustache/spec/pull/75\n\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _extension = __webpack_require__(0);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _token2 = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token2);\n\nvar PARENT = \"Inheritance.PARENT\";\nvar BLOCK = \"Inheritance.BLOCK\";\nvar LEAVE_SCOPE = \"Inheritance.LEAVE_SCOPE\";\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nvar Inheritance = (function (_Extension) {\n  _inherits(Inheritance, _Extension);\n\n  function Inheritance() {\n    _classCallCheck(this, Inheritance);\n\n    _get(Object.getPrototypeOf(Inheritance.prototype), \"constructor\", this).call(this);\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  _createClass(Inheritance, [{\n    key: \"transformToken\",\n    value: function transformToken(token) {\n      var _token = token;\n      var type = _token.type;\n      var name = _token.name;\n      var location = _token.location;\n\n      switch (type) {\n        case TokenType.VARIABLE:\n          if (name) {\n            if (name[0] === \"<\") {\n              if (name.length === 1) {\n                throw new Error(\"Parent partial name expected\");\n              }\n              token = {\n                type: PARENT,\n                name: name.slice(1),\n                location: location\n              };\n            } else if (name[0] === \"$\") {\n              if (name.length === 1) {\n                throw new Error(\"Block name expected\");\n              }\n              token = {\n                type: BLOCK,\n                name: name.slice(1),\n                location: location\n              };\n            }\n          }\n          break;\n      }\n      return token;\n    }\n  }, {\n    key: \"handleToken\",\n    value: function handleToken(token, parserContext) {\n      var handled = false;\n      var name = token.name;\n      var location = token.location;\n      var type = token.type;\n\n      switch (type) {\n        case PARENT:\n          parserContext.pushParent({\n            type: PARENT,\n            name: name,\n            location: location\n          });\n          handled = true;\n          break;\n\n        case BLOCK:\n          this._pushBlock({\n            type: BLOCK,\n            name: name,\n            location: location\n          }, parserContext);\n          break;\n\n        case TokenType.SECTION_CLOSE:\n          var tagNode = parserContext.tailNode;\n          if (tagNode === null) {\n            if (isInheritanceTagType(tagNode.type)) {\n              parserContext[\"throw\"](\"Unexpected tag close\");\n            }\n          } else {\n            if (tagNode.name !== name) {\n              parserContext[\"throw\"](\"Unexpected tag close, current tag: \" + tagNode.name);\n            }\n            if (isInheritanceTagType(tagNode.type)) {\n              parserContext.popParent();\n              tagNode.location.endIndex = location.endIndex;\n              tagNode.location.endLine = location.endLine;\n              parserContext.appendNode(tagNode);\n\n              //TODO move this to visit, handle whitespaces after Parent close tag.\n              var firstLine = tagNode.location.line;\n              var firstBlock = tagNode.children.find(function (c) {\n                return c.type === BLOCK;\n              });\n              if (firstBlock && firstBlock.location.line === firstLine) {\n                for (var i = 0; i < firstBlock.children.length; i++) {\n                  var blockNode = firstBlock.children[i];\n                  if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n                    blockNode.text = \"\";\n                  } else {\n                    break;\n                  }\n                }\n              }\n\n              handled = true;\n            }\n          }\n          break;\n\n        case TokenType.EOF:\n          if (this.top > 0) {\n            parserContext[\"throw\"](\"Unexpected EOF: tags not closed: \" + this.stack.map(function (f) {\n              return f.name;\n            }).join(\", \"));\n          }\n          break;\n      }\n      return handled;\n    }\n  }, {\n    key: \"handleNode\",\n    value: function handleNode(node, rendererContext) {\n      var top = rendererContext.top;\n      this._checkTop(top);\n\n      switch (node.type) {\n        case PARENT:\n          this._handleParent(node, rendererContext);\n          return true;\n\n        case BLOCK:\n          this._handleBlock(node, rendererContext);\n          return true;\n\n        case LEAVE_SCOPE:\n          this._blocks = null;\n          return true;\n      }\n    }\n  }, {\n    key: \"_pushBlock\",\n    value: function _pushBlock(node, parserContext) {\n      var parent = parserContext.findParentNode(function (parent) {\n        return parent.type === BLOCK && parent.name === node.name;\n      });\n      if (parent) {\n        parserContext[\"throw\"](\"Recursive block: '\" + node.name + \"'\");\n      }\n      parserContext.pushParent(node);\n    }\n  }, {\n    key: \"_handleParent\",\n    value: function _handleParent(node, rendererContext) {\n      var name = node.name;\n      var location = node.location;\n\n      var top = rendererContext.top;\n\n      this._pushParent(name, top);\n\n      if (this._blocks === null) {\n        rendererContext.pushNodes([{\n          type: LEAVE_SCOPE\n        }]);\n        this._blocks = {};\n      }\n\n      //find all blocks defined in parent\n      var blocks = {};\n      node.children.forEach(function (child) {\n        if (child.type === BLOCK) {\n          var blockName = child.name;\n          blocks[blockName] = child;\n        }\n      });\n      if (Object.keys(blocks).length) {\n        this._setDefaultBlocks(blocks);\n      }\n\n      rendererContext.pushNode({\n        type: TokenType.PARTIAL,\n        name: name,\n        location: location,\n        indent: node.indent\n      });\n    }\n  }, {\n    key: \"_handleBlock\",\n    value: function _handleBlock(node, rendererContext) {\n      var name = node.name;\n\n      var defaultBlock = this._getDefaultBlock(name);\n      if (defaultBlock) {\n        rendererContext.pushNodes(defaultBlock.children);\n      } else {\n        rendererContext.pushNodes(node.children);\n      }\n    }\n  }, {\n    key: \"_pushParent\",\n    value: function _pushParent(name, top) {\n      return this._parentStack.push({\n        name: name,\n        blocks: {},\n        top: top\n      });\n    }\n  }, {\n    key: \"_checkTop\",\n    value: function _checkTop(top) {\n      var pop = 0;\n      for (var i = this._parentStack.length - 1; i >= 0; i--) {\n        var frame = this._parentStack[i];\n        if (frame.top > top) {\n          pop++;\n        } else {\n          break;\n        }\n      }\n      if (pop > 0) {\n        this._parentStack = this._parentStack.slice(0, this._parentStack.length - pop);\n      }\n    }\n  }, {\n    key: \"_popParent\",\n    value: function _popParent() {\n      return this._parentStack.pop();\n    }\n  }, {\n    key: \"_getDefaultBlock\",\n    value: function _getDefaultBlock(name) {\n      for (var i = 0; i < this._parentStack.length; i++) {\n        var frame = this._parentStack[i];\n        if (name in frame.blocks) {\n          return frame.blocks[name];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_setDefaultBlocks\",\n    value: function _setDefaultBlocks(blocks) {\n      var topFrame = this._parentStack[this._parentStack.length - 1];\n      topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n    }\n  }]);\n\n  return Inheritance;\n})(_extension.Extension);\n\nexports.Inheritance = Inheritance;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _node = __webpack_require__(3);\n\nvar nodeTypes = _interopRequireWildcard(_node);\n\nvar _escapeHtml = __webpack_require__(9);\n\nvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\nvar _parser = __webpack_require__(4);\n\nvar _helpers = __webpack_require__(2);\n\nvar _extension = __webpack_require__(0);\n\nvar REPEATER_NODE_TYPE = \"_REPEATER\";\nvar MAX_PARTIAL_STACK = 10;\nvar MAX_LAMBDA_STACK = 255;\nvar MAX_NODE_COUNT = 3000;\n\nvar RenderContext = (function () {\n  function RenderContext(renderer) {\n    _classCallCheck(this, RenderContext);\n\n    this._renderer = renderer;\n  }\n\n  _createClass(RenderContext, [{\n    key: \"evaluate\",\n    value: function evaluate(name) {\n      return this._renderer._evaluate(name);\n    }\n  }, {\n    key: \"pushNodes\",\n    value: function pushNodes(nodes) {\n      this._renderer._pushNodes(nodes);\n    }\n  }, {\n    key: \"pushNode\",\n    value: function pushNode(node) {\n      this._renderer._pushNode(node);\n    }\n  }, {\n    key: \"pushContext\",\n    value: function pushContext(ctx) {\n      this._renderer._pushContext(ctx);\n    }\n  }, {\n    key: \"appendText\",\n    value: function appendText(text) {\n      this._renderer._out += text;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(src, opts) {\n      return this._renderer._parse(src, opts);\n    }\n  }, {\n    key: \"getParsedPartial\",\n    value: function getParsedPartial(name) {\n      return this._renderer._getParsedPartial(name);\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(message, location) {\n      return this._renderer._throw(message, location);\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._renderer._stack.length;\n    }\n  }, {\n    key: \"result\",\n    get: function get() {\n      return this._renderer._out;\n    }\n  }]);\n\n  return RenderContext;\n})();\n\nvar Renderer = (function () {\n  function Renderer(src) {\n    var _this = this;\n\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Renderer);\n\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    this._filename = opts.filename;\n\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(function (k) {\n        _this._partialCached[k] = _this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = \"\";\n    this._transformNodeResult = function (node, result, nodeResult) {\n      return _this._extensions.reduce(function (r, e) {\n        return e.transformNodeResult(node, result, r);\n      }, nodeResult);\n    };\n  }\n\n  _createClass(Renderer, [{\n    key: \"render\",\n    value: function render(context) {\n      var _this2 = this;\n\n      this._out = \"\";\n      this._stack = [];\n      this._contextStack = [];\n      this._partialStack = [];\n      this._lambdaStack = [];\n\n      this._pushContext(context);\n\n      //push root nodes\n      var rootNode = this._parsed ? this._src : this._parse(this._src, { filename: this._filename });\n      this._stack = rootNode.children.slice(0).reverse();\n\n      var node_count = 0;\n\n      var newline = true;\n\n      var _loop = function () {\n        var top = _this2._stack.length - 1;\n        var node = _this2._stack[top];\n\n        if (node.type !== nodeTypes.TEXT) {\n          node_count++;\n          if (node_count > MAX_NODE_COUNT) {\n            _this2._throw(\"Possible infinity loop detected: last node type is '\" + node.type + \"'\", node.location);\n          }\n        }\n\n        var handled = false;\n        if (_this2._extensions) {\n          _this2._extensions.forEach(function (ext) {\n            if (ext.handleNode(node, _this2._renderContext)) {\n              handled = true;\n            }\n          });\n        }\n\n        if (handled) {\n          _this2._stack.splice(top, 1);\n        } else {\n          var partial = _this2._partialStack.length ? _this2._partialStack[_this2._partialStack.length - 1] : null;\n\n          //insert indent\n          if (node.type in nodeTypes) {\n            if (newline && partial !== null && partial.indent.length > 0) {\n              _this2._out += partial.indent;\n            }\n          }\n\n          var value = undefined;\n          switch (node.type) {\n            case nodeTypes.VARIABLE:\n              value = _this2._evaluate(node.name);\n              if (isFunction(value)) {\n                _this2._popNode();\n                _this2._expandLambda(node, value);\n              } else {\n                if (!!value) {\n                  var result = node.unescaped ? value : (0, _escapeHtml2[\"default\"])(value);\n                  _this2._out += _this2._transformNodeResult(node, _this2._out, result);\n                }\n                _this2._popNode();\n              }\n              break;\n\n            case nodeTypes.SECTION:\n              value = _this2._evaluate(node.name);\n              if (isFunction(value)) {\n                _this2._popNode();\n                _this2._expandLambda(node, value);\n              } else {\n                var isList = Array.isArray(value);\n\n                if (isList && value.length === 0) {\n                  //Empty lists should behave like falsey values.\n                  value = false;\n                  isList = false;\n                }\n\n                var testResult = !!value;\n                if (node.inverted) {\n                  testResult = !testResult;\n                }\n\n                if (testResult) {\n                  if (isList) {\n                    _this2._popNode();\n                    _this2._pushRepeaterNode(value.length, node.children, value);\n                  } else {\n                    _this2._popNode();\n                    _this2._pushContext(value);\n                    _this2._pushNodes(node.children);\n                  }\n                } else {\n                  _this2._popNode();\n                }\n              }\n              break;\n\n            case nodeTypes.TEXT:\n              _this2._out += _this2._transformNodeResult(node, _this2._out, node.text);\n              _this2._popNode();\n              break;\n\n            case nodeTypes.COMMENT:\n              _this2._popNode();\n              break;\n\n            case nodeTypes.PARTIAL:\n              _this2._popNode();\n              _this2._expandPartial(node);\n              break;\n\n            case nodeTypes.DELIMITER_CHANGE:\n              _this2._popNode();\n              _this2._delimiters = node.delimiters.slice(0);\n              break;\n\n            case REPEATER_NODE_TYPE:\n              if (node.count < node.repeat) {\n                var repeatIndex = node.count;\n                if (repeatIndex === 0) {\n                  node.contextIndex = _this2._pushContext(node.contexts[0]);\n                } else {\n                  _this2._replaceContextAt(node.contextIndex, node.contexts[repeatIndex]);\n                }\n                _this2._pushNodes(node.children);\n                node.count++;\n              } else {\n                _this2._popNode();\n              }\n              break;\n\n            default:\n              _this2._popNode();\n              break;\n          }\n        }\n        _this2._checkStacks();\n        newline = _this2._out.length === 0 || _this2._out[_this2._out.length - 1] === \"\\n\";\n      };\n\n      while (this._stack.length > 0) {\n        _loop();\n      }\n\n      return this._extensions.reduce(function (result, ext) {\n        return ext.transformResult(result);\n      }, this._out);\n    }\n  }, {\n    key: \"_parse\",\n    value: function _parse(src) {\n      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      opts.extensions = this._extensions;\n      var parser = new _parser.Parser(opts);\n      return parser.parse(src);\n    }\n  }, {\n    key: \"_pushNodes\",\n    value: function _pushNodes(list) {\n      for (var i = list.length - 1; i >= 0; i--) {\n        this._stack.push(list[i]);\n      }\n    }\n  }, {\n    key: \"_pushNode\",\n    value: function _pushNode(node) {\n      this._stack.push(node);\n    }\n  }, {\n    key: \"_popNode\",\n    value: function _popNode() {\n      this._stack.pop();\n    }\n  }, {\n    key: \"_pushRepeaterNode\",\n    value: function _pushRepeaterNode(repeat, nodes, contexts) {\n      this._stack.push({\n        type: REPEATER_NODE_TYPE,\n        count: 0,\n        repeat: repeat,\n        children: nodes.slice(0),\n        contexts: contexts\n      });\n    }\n  }, {\n    key: \"_pushContext\",\n    value: function _pushContext(context) {\n      return this._contextStack.push({\n        context: context,\n        sp: this._stack.length\n      }) - 1;\n    }\n  }, {\n    key: \"_replaceContextAt\",\n    value: function _replaceContextAt(index, context) {\n      if (index < 0 || index > this._contextStack.length - 1) {\n        throw new RangeError(\"Huz context index out of range.\");\n      }\n      this._contextStack[index].context = context;\n    }\n  }, {\n    key: \"_pushPartial\",\n    value: function _pushPartial(_ref) {\n      var name = _ref.name;\n      var indent = _ref.indent;\n      var location = _ref.location;\n\n      this._partialStack.push({\n        name: name,\n        indent: indent || \"\",\n        location: location,\n        sp: this._stack.length\n      });\n    }\n  }, {\n    key: \"_pushLambda\",\n    value: function _pushLambda(_ref2) {\n      var name = _ref2.name;\n      var location = _ref2.location;\n\n      this._lambdaStack.push({\n        name: name,\n        location: location,\n        sp: this._stack.length\n      });\n    }\n  }, {\n    key: \"_checkStacks\",\n    value: function _checkStacks() {\n      if (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n        this._contextStack.pop();\n      }\n\n      if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n        this._partialStack.pop();\n      }\n\n      if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n        this._lambdaStack.pop();\n      }\n    }\n  }, {\n    key: \"_evaluate\",\n    value: function _evaluate(name) {\n      if (name === \".\") {\n        return this._contextStack[this._contextStack.length - 1].context;\n      }\n\n      var path = name.split(\".\");\n      for (var i = this._contextStack.length - 1; i >= 0; i--) {\n        var context = this._contextStack[i].context;\n        if (context === null || typeof context !== \"object\") {\n          continue;\n        }\n\n        var current = context;\n        var resolved = true;\n        for (var pi = 0; pi < path.length; pi++) {\n          var key = path[pi];\n          if (typeof current === \"object\" && current !== null && current.hasOwnProperty(key)) {\n            current = current[key];\n          } else {\n            resolved = false;\n            break;\n          }\n        }\n\n        if (resolved) {\n          return current;\n        }\n      }\n      return \"\";\n    }\n  }, {\n    key: \"_getParsedPartial\",\n    value: function _getParsedPartial(name) {\n      if (this._partialCached.hasOwnProperty(name)) {\n        return this._partialCached[name];\n      } else {\n        if (!this._partials.hasOwnProperty(name)) {\n          return null;\n        }\n        var ast = this._parse(this._partials[name], { filename: name });\n        var nodes = this._partialCached[name] = ast.children;\n        return nodes;\n      }\n    }\n  }, {\n    key: \"_expandPartial\",\n    value: function _expandPartial(node) {\n      var name = node.name;\n\n      var nodes = this._getParsedPartial(name);\n\n      if (nodes === null) {\n        //The empty string should be used when the named partial is not found.\n        return;\n      }\n\n      this._pushPartial(node);\n\n      if (this._partialStack.length > MAX_PARTIAL_STACK) {\n        this._throw(\"Possible partial short circuit: \" + this._partialStack.map(function (f) {\n          return f.name + \"@\" + f.location.filename + \":\" + (f.location.line + 1);\n        }).concat([name]).join(\" -> \"), node.location);\n      }\n\n      this._pushNodes(nodes);\n    }\n  }, {\n    key: \"_expandLambda\",\n    value: function _expandLambda(node, lambda) {\n      var name = node.name;\n\n      this._pushLambda(node);\n\n      if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n        this._throw(\"Possible lambda short circuit: \" + this._lambdaStack.map(function (f) {\n          return f.name + \"@\" + f.location.filename + \":\" + (f.location.line + 1);\n        }).concat([name]).join(\" -> \"), node.location);\n      }\n\n      var ast = undefined;\n      var skipped = false;\n      if (node.type === nodeTypes.VARIABLE) {\n        var code = lambda();\n        if (code) {\n          //A lambda's return value should parse with the default delimiters.\n          ast = this._parse(\"\" + code, { filename: \"[lambda]\" });\n          if (!node.unescaped) {\n            //Lambda results should be appropriately escaped.\n            (0, _helpers.walk)(ast, function (node) {\n              if (node.type === nodeTypes.TEXT) {\n                node.text = (0, _escapeHtml2[\"default\"])(node.text);\n              }\n            });\n          }\n        } else {\n          skipped = true;\n        }\n      } else if (node.type === nodeTypes.SECTION) {\n        var code = lambda(node.raw);\n        if (code) {\n          //Lambdas used for inverted sections should be considered truthy.\n          //Lambdas used for sections should parse with the current delimiters.\n          ast = this._parse(\"\" + code, {\n            filename: \"[#lambda]\",\n            delimiters: this._delimiters.slice(0)\n          });\n        } else {\n          skipped = true;\n        }\n      }\n\n      if (!skipped) {\n        this._pushNodes(ast.children);\n      }\n    }\n  }, {\n    key: \"_throw\",\n    value: function _throw(message, location) {\n      var e = new Error(message);\n      e.filename = location.filename;\n      e.location = location;\n      throw e;\n    }\n  }]);\n\n  return Renderer;\n})();\n\nexports.Renderer = Renderer;\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == \"[object Function]\";\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.compile = compile;\nexports.render = render;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _parser = __webpack_require__(4);\n\nvar _renderer = __webpack_require__(7);\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _helpers = __webpack_require__(2);\n\nvar Helpers = _interopRequireWildcard(_helpers);\n\nvar _extension = __webpack_require__(0);\n\nvar _extensionsInheritance = __webpack_require__(6);\n\nvar _tokenizer = __webpack_require__(5);\n\nObject.defineProperty(exports, \"Tokenizer\", {\n  enumerable: true,\n  get: function get() {\n    return _tokenizer.Tokenizer;\n  }\n});\nexports.Parser = _parser.Parser;\nexports.Renderer = _renderer.Renderer;\nexports.TokenType = TokenType;\nexports.NodeType = NodeType;\nObject.defineProperty(exports, \"Extension\", {\n  enumerable: true,\n  get: function get() {\n    return _extension.Extension;\n  }\n});\n\n(0, _extension.register)(_extensionsInheritance.Inheritance);\n\nfunction parse(src, opts) {\n  var parser = new _parser.Parser(opts);\n  return parser.parse(src);\n}\n\nfunction compile(src, opts) {\n  return new _renderer.Renderer(src, opts);\n}\n\nfunction render(src, context, opts) {\n  var r = compile(src, opts);\n  return r.render(context);\n}\n\nexports.register = _extension.register;\nexports.Helpers = Helpers;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// huz.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6d3aa36ad276daf73657","const registry = [];\n\nexport class Extension {\n  //called by tokenizer\n  transformToken(token) { return token; }\n\n  //called by parser\n  handleToken(token, parserContext) { }\n  visit(root) { return root; }\n  \n  //called by renderer\n  handleNode(node, renderContext) { }\n  transformNodeResult(node, result, nodeResult) { return nodeResult; }\n  transformResult(result) { return result; }\n}\n\nexport function instantiateAll(opts) {\n  return registry.map(ctor => {\n    return new ctor(opts);\n  });\n}\n\nexport function register(constructor) {\n  return registry.push(constructor);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/extension.js","export const EOF                    = 'EOF';\nexport const TEXT                   = 'TEXT';\nexport const PARTIAL                = 'PARTIAL';\nexport const INVERTED_SECTION_OPEN  = 'INVERTED_SECTION_OPEN';\nexport const SECTION_OPEN           = 'SECTION_OPEN';\nexport const SECTION_CLOSE          = 'SECTION_CLOSE';\nexport const UNESCAPED_VARIABLE     = 'UNESCAPED_VARIABLE';\nexport const COMMENT                = 'COMMENT';\nexport const VARIABLE               = 'VARIABLE';\nexport const DELIMITER_CHANGE \t\t\t= 'DELIMITER_CHANGE';\n\n\n// WEBPACK FOOTER //\n// ./src/token.js","import * as TokenType from './token';\n\nexport function walk(root, modifier) {\n  let stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    const node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nexport function visit(root, visitor) {\n  let stack = [root];\n  while (stack.length) {\n    const parent = stack.pop();\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      const modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nexport function trimStandaloneToken(tokens) {\n  const count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  let open = null;\n  let inline = 0;\n  let standalone = true;\n  let indentTokens = [];\n  for (let i = 0; standalone && i < count; i++) {\n    const token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline ++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline ++;\n        }\n        break;\n      default: //section-like tags\n        if (open === null) {\n          open = [token];\n          inline ++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n  \n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    let tailWSNodeCount = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount ++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        let indent = '';\n        indentTokens.forEach(t => { indent += t.text });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return /^\\s*$/.test(str);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/helpers.js","export const ROOT             = 'ROOT';\nexport const VARIABLE         = 'VARIABLE';\nexport const SECTION          = 'SECTION';\nexport const TEXT             = 'TEXT';\nexport const COMMENT          = 'COMMENT';\nexport const PARTIAL          = 'PARTIAL';\nexport const DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\n\n// WEBPACK FOOTER //\n// ./src/node.js","import * as TokenType from \"./token\";\nimport * as NodeType from \"./node\";\nimport { Tokenizer } from \"./tokenizer\";\nimport { visit } from \"./helpers\";\nimport { instantiateAll } from \"./extension\";\n\nclass ParserContext {\n  constructor(parser) {\n    this._parser = parser;\n  }\n\n  appendNode(node) {\n    this._parser._appendNode(node);\n  }\n\n  pushParent(node) {\n    this._parser._pushParent(node);\n  }\n\n  popParent() {\n    return this._parser._popParent();\n  }\n\n  get filename() {\n    return this._parser._filename;\n  }\n\n  get top() {\n    return this._parser._stack.length;\n  }\n\n  get tailNode() {\n    return this._parser._stack.length > 0\n      ? this._parser._stack[this._parser._stack.length - 1]\n      : null;\n  }\n\n  findParentNode(f) {\n    for (let i = this._parser._stack.length - 1; i >= 0; i--) {\n      const item = this._parser._stack[i];\n      if (f(item)) {\n        return item;\n      }\n    }\n    return null;\n  }\n\n  throw(message) {\n    return this._parser._throw(message);\n  }\n}\n\nexport class Parser {\n  constructor(opts = {}) {\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    this._filename = opts.filename || \"\";\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  parse(src) {\n    const rootNode = {\n      type: NodeType.ROOT,\n      children: []\n    };\n    this._src = src;\n    this._stack = [rootNode];\n    this._lastToken = null;\n    this._parseNodes(src);\n\n    if (this._extensions.length > 0) {\n      for (let i = 0; i < this._extensions.length; i++) {\n        this._extensions[i].visit(rootNode);\n      }\n    }\n\n    return rootNode;\n  }\n\n  _addNodeToken(node) {\n    const token = this._lastToken;\n    if (node.tokens) {\n      node.tokens.push(token);\n    } else {\n      node.tokens = [token];\n    }\n  }\n\n  _appendNode(node) {\n    this._addNodeToken(node);\n    node.location.filename = this._filename;\n    this._stack[this._stack.length - 1].children.push(node);\n    return node;\n  }\n\n  _getTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  _clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  _makeLocation(beginLocation, endLocation) {\n    const location = this._clone(beginLocation);\n    if (endLocation) {\n      location.endIndex = endLocation.endIndex;\n      location.endLine = endLocation.endLine;\n    }\n    return location;\n  }\n\n  _parseNodes(src) {\n    let initialStackSize = this._stack.length;\n    let token;\n    const z = new Tokenizer(src, {\n      delimiters: this._delimiters.slice(0),\n      extensions: this._extensions,\n      filename: this._filename\n    });\n\n    do {\n      token = z.getNextToken();\n\n      if (z.error !== null) {\n        throw z.error;\n      }\n\n      this._lastToken = token;\n\n      let handled = false;\n      if (this._extensions) {\n        for (let i = 0; i < this._extensions.length; i++) {\n          const ext = this._extensions[i];\n          if (ext.handleToken(token, this._parserContext) === true) {\n            handled = true;\n            break;\n          }\n        }\n      }\n\n      if (!handled) {\n        switch (token.type) {\n          case TokenType.TEXT:\n            this._appendNode({\n              type: NodeType.TEXT,\n              text: token.text,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.VARIABLE:\n          case TokenType.UNESCAPED_VARIABLE:\n            this._appendNode({\n              type: NodeType.VARIABLE,\n              name: token.name,\n              unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.SECTION_OPEN:\n            this._handleSectionOpen(token);\n            break;\n\n          case TokenType.INVERTED_SECTION_OPEN:\n            this._handleSectionOpen(token, true);\n            break;\n\n          case TokenType.SECTION_CLOSE:\n            this._handleSectionClose(token);\n            break;\n\n          case TokenType.PARTIAL:\n            this._appendNode({\n              type: NodeType.PARTIAL,\n              name: token.name,\n              indent: token.indent,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.COMMENT:\n            this._handleComment(token);\n            break;\n\n          case TokenType.DELIMITER_CHANGE:\n            this._appendNode({\n              type: NodeType.DELIMITER_CHANGE,\n              delimiters: token.delimiters,\n              location: this._makeLocation(token.location)\n            });\n            break;\n        }\n      }\n    } while (token.type !== TokenType.EOF);\n\n    if (this._stack.length > initialStackSize) {\n      this._throw(\n        \"Unexpected EOF: sections not closed: \" +\n          this._stack\n            .slice(initialStackSize)\n            .map(n => `'${n.name}'`)\n            .join(\", \")\n      );\n    } else if (this._stack.length < initialStackSize) {\n      this._throw(\"Internal error.\");\n    }\n  }\n\n  _throw(message) {\n    const e = new Error(message);\n    e.filename = this._lastToken.location.filename;\n    e.location = this._lastToken.location;\n    throw e;\n  }\n\n  _pushParent(node) {\n    this._addNodeToken(node);\n    node.children = [];\n    this._stack.push(node);\n  }\n\n  _popParent() {\n    return this._stack.pop();\n  }\n\n  _handleSectionOpen(token, inverted = false) {\n    const { name, location } = token;\n    this._pushParent({\n      type: NodeType.SECTION,\n      name,\n      inverted,\n      location\n    });\n  }\n\n  _handleSectionClose(token) {\n    const { name, location } = token;\n    const section = this._popParent();\n    if (section.type !== NodeType.SECTION) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}'`);\n    }\n\n    if (section.name !== name) {\n      this._throw(\n        `Unexpected SECTION_CLOSE: '${name}', current section: '${\n          section.name\n        }'`\n      );\n    }\n\n    section.raw = this._src.slice(section.location.endIndex, location.index);\n    section.location = this._makeLocation(section.location, token.location);\n\n    this._appendNode(section);\n  }\n\n  _handleComment(token) {\n    const { content, location } = token;\n    this._appendNode({\n      type: NodeType.COMMENT,\n      content,\n      location: this._makeLocation(location)\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/parser.js","import * as TokenType from \"./token\";\nimport { instantiateAll } from \"./extension\";\nimport { trimStandaloneToken } from \"./helpers\";\n\nconst STATE_NONE = \"STATE_NONE\";\nconst STATE_EOF = \"STATE_EOF\";\nconst STATE_TEXT = \"STATE_TEXT\";\nconst STATE_TEXT_BREAK = \"STATE_TEXT_BREAK\";\nconst STATE_TAG = \"STATE_TAG\";\n\nconst DELIMITER_LEFT = 0;\nconst DELIMITER_RIGHT = 1;\n\nexport class Tokenizer {\n  constructor(src, opts = {}) {\n    this._extensions = opts.extensions || instantiateAll();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 0;\n    this._column = 0;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  getNextToken() {\n    if (this._tokens.length > 0) {\n      return this._tokens.shift();\n    }\n\n    let done = false;\n    let matched = false;\n    do {\n      //console.log(this._state, this._tokens);\n      if (this._error !== null) {\n        return null;\n      }\n\n      if (this._state !== STATE_NONE) {\n        matched = true;\n        this._markTokenStartLocation();\n      }\n\n      switch (this._state) {\n        case STATE_NONE:\n          this._read();\n          break;\n\n        case STATE_EOF:\n          this._handleEOF();\n          done = true;\n          break;\n\n        case STATE_TEXT:\n          this._handleText();\n          break;\n\n        case STATE_TEXT_BREAK:\n          this._handleTextBreak();\n          done = true;\n          break;\n\n        case STATE_TAG:\n          this._handleTag();\n          break;\n      }\n\n      if (matched && !this._error) {\n        this._markTokenEndLocation();\n        matched = false;\n      }\n\n      if (this._state === STATE_NONE) {\n        if (this._char === null) {\n          this._state = STATE_EOF;\n        } else if (this._char === \"\\n\") {\n          this._state = STATE_TEXT_BREAK;\n        } else if (this._isDelimiter(DELIMITER_LEFT)) {\n          this._state = STATE_TAG;\n        } else {\n          this._state = STATE_TEXT;\n        }\n      }\n    } while (!done);\n\n    return this._error === null ? this._tokens.shift() : null;\n  }\n\n  // Handlers\n\n  _handleEOF() {\n    this._handleStandaloneTag();\n    this._makeToken({\n      type: TokenType.EOF\n    });\n  }\n\n  _handleTag() {\n    const [left, right] = this._delimiters;\n    this._skip(left.length);\n    this._skipAllWhitespaces();\n\n    if (this._char === null) {\n      this._setError(\"Unclosed tag.\");\n    } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n      this._handleEmptyTag();\n    } else {\n      const tagTypeChar = this._char;\n      if (tagTypeChar === \"{\") {\n        this._handleVariableCurly();\n      } else {\n        let tagContentStart = this._index - 1;\n        //read content\n        while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n          this._read();\n        }\n\n        if (this._char === null) {\n          this._setError(\"Unclosed tag.\");\n        } else {\n          const content = this._src.slice(tagContentStart, this._index - 1);\n          switch (tagTypeChar) {\n            case \">\":\n              this._handleSimpleTag(TokenType.PARTIAL, content);\n              break;\n            case \"^\":\n              this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);\n              break;\n            case \"#\":\n              this._handleSimpleTag(TokenType.SECTION_OPEN, content);\n              break;\n            case \"/\":\n              this._handleSimpleTag(TokenType.SECTION_CLOSE, content);\n              break;\n\n            case \"!\":\n              this._handleComment(content.substr(1));\n              break;\n\n            case \"=\":\n              this._handleDelimiterChange(content);\n              break;\n            case \"&\":\n              this._handleVariable(content.substr(1), true);\n              break;\n            default:\n              this._handleVariable(content);\n              break;\n          }\n        }\n      }\n    }\n    if (this._error === null) {\n      //eat right\n      for (let i = 0; i < right.length; i++) {\n        this._read();\n      }\n    }\n\n    this._state = STATE_NONE;\n  }\n\n  _handleDelimiterChange(content) {\n    const newDelimiters = extractNewDelimiters(content);\n    if (newDelimiters === null) {\n      this._setError(\"Invalid change delimiter syntax.\");\n    } else {\n      const [left, right] = newDelimiters;\n      this._delimiters = newDelimiters;\n      this._makeToken({\n        type: TokenType.DELIMITER_CHANGE,\n        delimiters: [left, right]\n      });\n    }\n  }\n\n  _handleSimpleTag(type, content) {\n    this._makeToken({ type, name: content.substr(1).trim() });\n  }\n\n  _handleComment(content) {\n    this._makeToken({\n      type: TokenType.COMMENT,\n      content\n    });\n  }\n\n  _handleVariableCurly() {\n    this._read(); //eat '{'\n    const begin = this._index - 1;\n    const d = this._distance(\"}\");\n    if (d === -1) {\n      this._setError(\"Unclosed variable tag: missingright curly.\");\n    } else {\n      const content = this._src.slice(begin, begin + d);\n      this._skip(d + 1); //skip '}'\n      this._skipAllWhitespaces();\n      if (!this._isDelimiter(DELIMITER_RIGHT)) {\n        this._setError(\"Unclosed variable: missing right delimiter.\");\n      } else {\n        this._makeToken({\n          type: TokenType.UNESCAPED_VARIABLE,\n          name: content.trim()\n        });\n      }\n    }\n  }\n\n  _handleEmptyTag() {\n    this._makeToken({\n      type: TokenType.VARIABLE,\n      name: \"\"\n    });\n  }\n\n  _handleVariable(content, unescaped) {\n    this._makeToken({\n      type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n      name: content.trim()\n    });\n  }\n\n  _handleText() {\n    let done = false;\n    let index = this._index - 1;\n    let length = 0;\n    do {\n      const c = this._char;\n\n      if (c === null || c === \"\\n\" || this._isDelimiter(DELIMITER_LEFT)) {\n        done = true;\n      } else {\n        length++;\n      }\n\n      if (!done) {\n        this._read();\n      }\n    } while (!done);\n\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: this._src.slice(index, index + length)\n    });\n\n    this._state = STATE_NONE;\n  }\n\n  _handleTextBreak() {\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: \"\\n\"\n    });\n    this._read();\n    this._handleStandaloneTag();\n    this._state = STATE_NONE;\n  }\n\n  _handleStandaloneTag() {\n    this._tokens = trimStandaloneToken(this._tokens);\n  }\n\n  // Helpers\n  _dump(t = \"\") {\n    console.log(t + \">\" + this._src.slice(this._index - 1));\n  }\n\n  _read() {\n    if (this._index < this._src.length) {\n      if (this._char === \"\\n\") {\n        this._line++;\n        this._column = 0;\n      } else {\n        this._column++;\n      }\n\n      this._char = this._src[this._index];\n      this._index++;\n    } else {\n      this._char = null;\n    }\n  }\n\n  _peek() {\n    if (this._index < this._src.length - 1) {\n      return this._src[this._index];\n    } else {\n      return null;\n    }\n  }\n\n  _skip(n) {\n    for (let i = 0; i < n; i++) {\n      this._read();\n    }\n  }\n\n  _distance(c) {\n    for (let i = this._index; i < this._src.length; i++) {\n      if (this._src[i] === c) {\n        return i - this._index + 1;\n      }\n    }\n    return -1;\n  }\n\n  _skipAllWhitespaces() {\n    while (this._isWhitespace()) {\n      this._read();\n    }\n  }\n\n  _markTokenStartLocation() {\n    this._location.index = this._index - 1;\n    this._location.line = this._line;\n    this._location.column = this._column;\n  }\n\n  _markTokenEndLocation() {\n    const token = this._tokens[this._tokens.length - 1];\n    token.location.endIndex = this._index - 1;\n    token.location.endLine = this._line;\n    token.location.endColumn = this._column;\n  }\n\n  _isWhitespace() {\n    return /\\s/.test(this._char);\n  }\n\n  _isDelimiter(d, offset = 0) {\n    const delimiter = this._delimiters[d];\n    const pos = this._index - 1 + offset;\n    return this._src.slice(pos, pos + delimiter.length) === delimiter;\n  }\n\n  _makeToken(token) {\n    token.filename = this._filename;\n    const { index, line, column } = this._location;\n    token.location = {\n      filename: this._filename,\n      index,\n      line,\n      column\n    };\n    if (this._extensions.length) {\n      try {\n        this._extensions.forEach(ext => {\n          token = ext.transformToken(token);\n        });\n      } catch (e) {\n        this._setError(e.message);\n        return;\n      }\n    }\n    this._tokens.push(token);\n  }\n\n  _setError(message) {\n    const error = new Error(message);\n    error.filename = this._filename;\n    error.index = this._index - 1;\n    error.line = this._line;\n    error.column = this._column;\n    this._error = error;\n  }\n}\n\nconst R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  const matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tokenizer.js","// https://github.com/mustache/spec/pull/75\n\nimport { Extension, register } from \"../extension\";\nimport * as NodeType from \"../node\";\nimport * as TokenType from \"../token\";\n\nconst PARENT = \"Inheritance.PARENT\";\nconst BLOCK = \"Inheritance.BLOCK\";\nconst LEAVE_SCOPE = \"Inheritance.LEAVE_SCOPE\";\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nexport class Inheritance extends Extension {\n  constructor() {\n    super();\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  transformToken(token) {\n    const { type, name, location } = token;\n    switch (type) {\n      case TokenType.VARIABLE:\n        if (name) {\n          if (name[0] === \"<\") {\n            if (name.length === 1) {\n              throw new Error(\"Parent partial name expected\");\n            }\n            token = {\n              type: PARENT,\n              name: name.slice(1),\n              location\n            };\n          } else if (name[0] === \"$\") {\n            if (name.length === 1) {\n              throw new Error(\"Block name expected\");\n            }\n            token = {\n              type: BLOCK,\n              name: name.slice(1),\n              location\n            };\n          }\n        }\n        break;\n    }\n    return token;\n  }\n\n  handleToken(token, parserContext) {\n    let handled = false;\n    const { name, location, type } = token;\n    switch (type) {\n      case PARENT:\n        parserContext.pushParent({\n          type: PARENT,\n          name,\n          location\n        });\n        handled = true;\n        break;\n\n      case BLOCK:\n        this._pushBlock(\n          {\n            type: BLOCK,\n            name,\n            location\n          },\n          parserContext\n        );\n        break;\n\n      case TokenType.SECTION_CLOSE:\n        const tagNode = parserContext.tailNode;\n        if (tagNode === null) {\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.throw(\"Unexpected tag close\");\n          }\n        } else {\n          if (tagNode.name !== name) {\n            parserContext.throw(\n              `Unexpected tag close, current tag: ${tagNode.name}`\n            );\n          }\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.popParent();\n            tagNode.location.endIndex = location.endIndex;\n            tagNode.location.endLine = location.endLine;\n            parserContext.appendNode(tagNode);\n\n            //TODO move this to visit, handle whitespaces after Parent close tag.\n            const firstLine = tagNode.location.line;\n            const firstBlock = tagNode.children.find(c => c.type === BLOCK);\n            if (firstBlock && firstBlock.location.line === firstLine) {\n              for (let i = 0; i < firstBlock.children.length; i++) {\n                const blockNode = firstBlock.children[i];\n                if (\n                  blockNode.type === NodeType.TEXT &&\n                  /^\\s*$/.test(blockNode.text)\n                ) {\n                  blockNode.text = \"\";\n                } else {\n                  break;\n                }\n              }\n            }\n\n            handled = true;\n          }\n        }\n        break;\n\n      case TokenType.EOF:\n        if (this.top > 0) {\n          parserContext.throw(\n            \"Unexpected EOF: tags not closed: \" +\n              this.stack.map(f => f.name).join(\", \")\n          );\n        }\n        break;\n    }\n    return handled;\n  }\n\n  handleNode(node, rendererContext) {\n    const top = rendererContext.top;\n    this._checkTop(top);\n\n    switch (node.type) {\n      case PARENT:\n        this._handleParent(node, rendererContext);\n        return true;\n\n      case BLOCK:\n        this._handleBlock(node, rendererContext);\n        return true;\n\n      case LEAVE_SCOPE:\n        this._blocks = null;\n        return true;\n    }\n  }\n\n  _pushBlock(node, parserContext) {\n    const parent = parserContext.findParentNode(\n      parent => parent.type === BLOCK && parent.name === node.name\n    );\n    if (parent) {\n      parserContext.throw(`Recursive block: '${node.name}'`);\n    }\n    parserContext.pushParent(node);\n  }\n\n  _handleParent(node, rendererContext) {\n    const { name, location } = node;\n    const top = rendererContext.top;\n\n    this._pushParent(name, top);\n\n    if (this._blocks === null) {\n      rendererContext.pushNodes([\n        {\n          type: LEAVE_SCOPE\n        }\n      ]);\n      this._blocks = {};\n    }\n\n    //find all blocks defined in parent\n    const blocks = {};\n    node.children.forEach(child => {\n      if (child.type === BLOCK) {\n        const blockName = child.name;\n        blocks[blockName] = child;\n      }\n    });\n    if (Object.keys(blocks).length) {\n      this._setDefaultBlocks(blocks);\n    }\n\n    rendererContext.pushNode({\n      type: TokenType.PARTIAL,\n      name,\n      location,\n      indent: node.indent\n    });\n  }\n\n  _handleBlock(node, rendererContext) {\n    const { name } = node;\n    const defaultBlock = this._getDefaultBlock(name);\n    if (defaultBlock) {\n      rendererContext.pushNodes(defaultBlock.children);\n    } else {\n      rendererContext.pushNodes(node.children);\n    }\n  }\n\n  _pushParent(name, top) {\n    return this._parentStack.push({\n      name,\n      blocks: {},\n      top\n    });\n  }\n\n  _checkTop(top) {\n    let pop = 0;\n    for (let i = this._parentStack.length - 1; i >= 0; i--) {\n      const frame = this._parentStack[i];\n      if (frame.top > top) {\n        pop++;\n      } else {\n        break;\n      }\n    }\n    if (pop > 0) {\n      this._parentStack = this._parentStack.slice(\n        0,\n        this._parentStack.length - pop\n      );\n    }\n  }\n\n  _popParent() {\n    return this._parentStack.pop();\n  }\n\n  _getDefaultBlock(name) {\n    for (let i = 0; i < this._parentStack.length; i++) {\n      const frame = this._parentStack[i];\n      if (name in frame.blocks) {\n        return frame.blocks[name];\n      }\n    }\n    return null;\n  }\n\n  _setDefaultBlocks(blocks) {\n    const topFrame = this._parentStack[this._parentStack.length - 1];\n    topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/extensions/inheritance.js","import * as nodeTypes from \"./node\";\nimport escapeHTML from \"escape-html\";\nimport { Parser } from \"./parser\";\nimport { walk, visit } from \"./helpers\";\nimport { instantiateAll } from \"./extension\";\n\nconst REPEATER_NODE_TYPE = \"_REPEATER\";\nconst MAX_PARTIAL_STACK = 10;\nconst MAX_LAMBDA_STACK = 255;\nconst MAX_NODE_COUNT = 3000;\n\nclass RenderContext {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n\n  get top() {\n    return this._renderer._stack.length;\n  }\n\n  get result() {\n    return this._renderer._out;\n  }\n\n  evaluate(name) {\n    return this._renderer._evaluate(name);\n  }\n\n  pushNodes(nodes) {\n    this._renderer._pushNodes(nodes);\n  }\n\n  pushNode(node) {\n    this._renderer._pushNode(node);\n  }\n\n  pushContext(ctx) {\n    this._renderer._pushContext(ctx);\n  }\n\n  appendText(text) {\n    this._renderer._out += text;\n  }\n\n  parse(src, opts) {\n    return this._renderer._parse(src, opts);\n  }\n\n  getParsedPartial(name) {\n    return this._renderer._getParsedPartial(name);\n  }\n\n  throw(message, location) {\n    return this._renderer._throw(message, location);\n  }\n}\n\nexport class Renderer {\n  constructor(src, opts = {}) {\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    this._filename = opts.filename;\n\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(k => {\n        this._partialCached[k] = this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = \"\";\n    this._transformNodeResult = (node, result, nodeResult) =>\n      this._extensions.reduce(\n        (r, e) => e.transformNodeResult(node, result, r),\n        nodeResult\n      );\n  }\n\n  render(context) {\n    this._out = \"\";\n    this._stack = [];\n    this._contextStack = [];\n    this._partialStack = [];\n    this._lambdaStack = [];\n\n    this._pushContext(context);\n\n    //push root nodes\n    const rootNode = this._parsed\n      ? this._src\n      : this._parse(this._src, { filename: this._filename });\n    this._stack = rootNode.children.slice(0).reverse();\n\n    let node_count = 0;\n\n    let newline = true;\n    while (this._stack.length > 0) {\n      const top = this._stack.length - 1;\n      const node = this._stack[top];\n\n      if (node.type !== nodeTypes.TEXT) {\n        node_count++;\n        if (node_count > MAX_NODE_COUNT) {\n          this._throw(\n            `Possible infinity loop detected: last node type is '${node.type}'`,\n            node.location\n          );\n        }\n      }\n\n      let handled = false;\n      if (this._extensions) {\n        this._extensions.forEach(ext => {\n          if (ext.handleNode(node, this._renderContext)) {\n            handled = true;\n          }\n        });\n      }\n\n      if (handled) {\n        this._stack.splice(top, 1);\n      } else {\n        const partial = this._partialStack.length\n          ? this._partialStack[this._partialStack.length - 1]\n          : null;\n\n        //insert indent\n        if (node.type in nodeTypes) {\n          if (newline && partial !== null && partial.indent.length > 0) {\n            this._out += partial.indent;\n          }\n        }\n\n        let value;\n        switch (node.type) {\n          case nodeTypes.VARIABLE:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              if (!!value) {\n                const result = node.unescaped ? value : escapeHTML(value);\n                this._out += this._transformNodeResult(node, this._out, result);\n              }\n              this._popNode();\n            }\n            break;\n\n          case nodeTypes.SECTION:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              let isList = Array.isArray(value);\n\n              if (isList && value.length === 0) {\n                //Empty lists should behave like falsey values.\n                value = false;\n                isList = false;\n              }\n\n              let testResult = !!value;\n              if (node.inverted) {\n                testResult = !testResult;\n              }\n\n              if (testResult) {\n                if (isList) {\n                  this._popNode();\n                  this._pushRepeaterNode(value.length, node.children, value);\n                } else {\n                  this._popNode();\n                  this._pushContext(value);\n                  this._pushNodes(node.children);\n                }\n              } else {\n                this._popNode();\n              }\n            }\n            break;\n\n          case nodeTypes.TEXT:\n            this._out += this._transformNodeResult(node, this._out, node.text);\n            this._popNode();\n            break;\n\n          case nodeTypes.COMMENT:\n            this._popNode();\n            break;\n\n          case nodeTypes.PARTIAL:\n            this._popNode();\n            this._expandPartial(node);\n            break;\n\n          case nodeTypes.DELIMITER_CHANGE:\n            this._popNode();\n            this._delimiters = node.delimiters.slice(0);\n            break;\n\n          case REPEATER_NODE_TYPE:\n            if (node.count < node.repeat) {\n              const repeatIndex = node.count;\n              if (repeatIndex === 0) {\n                node.contextIndex = this._pushContext(node.contexts[0]);\n              } else {\n                this._replaceContextAt(\n                  node.contextIndex,\n                  node.contexts[repeatIndex]\n                );\n              }\n              this._pushNodes(node.children);\n              node.count++;\n            } else {\n              this._popNode();\n            }\n            break;\n\n          default:\n            this._popNode();\n            break;\n        }\n      }\n      this._checkStacks();\n      newline =\n        this._out.length === 0 || this._out[this._out.length - 1] === \"\\n\";\n    }\n\n    return this._extensions.reduce(\n      (result, ext) => ext.transformResult(result),\n      this._out\n    );\n  }\n\n  _parse(src, opts = {}) {\n    opts.extensions = this._extensions;\n    const parser = new Parser(opts);\n    return parser.parse(src);\n  }\n\n  _pushNodes(list) {\n    for (let i = list.length - 1; i >= 0; i--) {\n      this._stack.push(list[i]);\n    }\n  }\n\n  _pushNode(node) {\n    this._stack.push(node);\n  }\n\n  _popNode() {\n    this._stack.pop();\n  }\n\n  _pushRepeaterNode(repeat, nodes, contexts) {\n    this._stack.push({\n      type: REPEATER_NODE_TYPE,\n      count: 0,\n      repeat,\n      children: nodes.slice(0),\n      contexts\n    });\n  }\n\n  _pushContext(context) {\n    return (\n      this._contextStack.push({\n        context,\n        sp: this._stack.length\n      }) - 1\n    );\n  }\n\n  _replaceContextAt(index, context) {\n    if (index < 0 || index > this._contextStack.length - 1) {\n      throw new RangeError(\"Huz context index out of range.\");\n    }\n    this._contextStack[index].context = context;\n  }\n\n  _pushPartial({ name, indent, location }) {\n    this._partialStack.push({\n      name,\n      indent: indent || \"\",\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _pushLambda({ name, location }) {\n    this._lambdaStack.push({\n      name,\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _checkStacks() {\n    if (\n      this._stack.length < this._contextStack[this._contextStack.length - 1].sp\n    ) {\n      this._contextStack.pop();\n    }\n\n    if (\n      this._partialStack.length > 0 &&\n      this._stack.length ===\n        this._partialStack[this._partialStack.length - 1].sp\n    ) {\n      this._partialStack.pop();\n    }\n\n    if (\n      this._lambdaStack.length > 0 &&\n      this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp\n    ) {\n      this._lambdaStack.pop();\n    }\n  }\n\n  _evaluate(name) {\n    if (name === \".\") {\n      return this._contextStack[this._contextStack.length - 1].context;\n    }\n\n    const path = name.split(\".\");\n    for (let i = this._contextStack.length - 1; i >= 0; i--) {\n      const context = this._contextStack[i].context;\n      if (context === null || typeof context !== \"object\") {\n        continue;\n      }\n\n      let current = context;\n      let resolved = true;\n      for (let pi = 0; pi < path.length; pi++) {\n        const key = path[pi];\n        if (\n          typeof current === \"object\" &&\n          current !== null &&\n          current.hasOwnProperty(key)\n        ) {\n          current = current[key];\n        } else {\n          resolved = false;\n          break;\n        }\n      }\n\n      if (resolved) {\n        return current;\n      }\n    }\n    return \"\";\n  }\n\n  _getParsedPartial(name) {\n    if (this._partialCached.hasOwnProperty(name)) {\n      return this._partialCached[name];\n    } else {\n      if (!this._partials.hasOwnProperty(name)) {\n        return null;\n      }\n      const ast = this._parse(this._partials[name], { filename: name });\n      const nodes = (this._partialCached[name] = ast.children);\n      return nodes;\n    }\n  }\n\n  _expandPartial(node) {\n    const { name } = node;\n    const nodes = this._getParsedPartial(name);\n\n    if (nodes === null) {\n      //The empty string should be used when the named partial is not found.\n      return;\n    }\n\n    this._pushPartial(node);\n\n    if (this._partialStack.length > MAX_PARTIAL_STACK) {\n      this._throw(\n        \"Possible partial short circuit: \" +\n          this._partialStack\n            .map(f => `${f.name}@${f.location.filename}:${f.location.line + 1}`)\n            .concat([name])\n            .join(\" -> \"),\n        node.location\n      );\n    }\n\n    this._pushNodes(nodes);\n  }\n\n  _expandLambda(node, lambda) {\n    const { name } = node;\n\n    this._pushLambda(node);\n\n    if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n      this._throw(\n        \"Possible lambda short circuit: \" +\n          this._lambdaStack\n            .map(f => `${f.name}@${f.location.filename}:${f.location.line + 1}`)\n            .concat([name])\n            .join(\" -> \"),\n        node.location\n      );\n    }\n\n    let ast;\n    let skipped = false;\n    if (node.type === nodeTypes.VARIABLE) {\n      const code = lambda();\n      if (code) {\n        //A lambda's return value should parse with the default delimiters.\n        ast = this._parse(\"\" + code, { filename: \"[lambda]\" });\n        if (!node.unescaped) {\n          //Lambda results should be appropriately escaped.\n          walk(ast, node => {\n            if (node.type === nodeTypes.TEXT) {\n              node.text = escapeHTML(node.text);\n            }\n          });\n        }\n      } else {\n        skipped = true;\n      }\n    } else if (node.type === nodeTypes.SECTION) {\n      const code = lambda(node.raw);\n      if (code) {\n        //Lambdas used for inverted sections should be considered truthy.\n        //Lambdas used for sections should parse with the current delimiters.\n        ast = this._parse(\"\" + code, {\n          filename: \"[#lambda]\",\n          delimiters: this._delimiters.slice(0)\n        });\n      } else {\n        skipped = true;\n      }\n    }\n\n    if (!skipped) {\n      this._pushNodes(ast.children);\n    }\n  }\n\n  _throw(message, location) {\n    const e = new Error(message);\n    e.filename = location.filename;\n    e.location = location;\n    throw e;\n  }\n}\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == \"[object Function]\";\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderer.js","import { Parser } from \"./parser\";\nimport { Renderer } from \"./renderer\";\nimport * as TokenType from \"./token\";\nimport * as NodeType from \"./node\";\nimport * as Helpers from \"./helpers\";\nimport { register } from \"./extension\";\n\nexport { Tokenizer } from \"./tokenizer\";\nexport { Parser, Renderer, TokenType, NodeType };\n\nexport { Extension } from \"./extension\";\nimport { Inheritance } from \"./extensions/inheritance\";\n\nregister(Inheritance);\n\nexport function parse(src, opts) {\n  const parser = new Parser(opts);\n  return parser.parse(src);\n}\n\nexport function compile(src, opts) {\n  return new Renderer(src, opts);\n}\n\nexport function render(src, context, opts) {\n  const r = compile(src, opts);\n  return r.render(context);\n}\n\nexport { register, Helpers };\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/escape-html/index.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}