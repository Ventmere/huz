{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///huz.js","webpack:///webpack/bootstrap 624f5411a1ec63c1d8b2","webpack:///./src/extension.js","webpack:///./src/token.js","webpack:///./src/helpers.js","webpack:///./src/node.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js","webpack:///./src/extensions/inheritance.js","webpack:///./src/renderer.js","webpack:///./src/index.js","webpack:///./~/escape-html/index.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","instantiateAll","opts","registry","map","ctor","register","constructor","push","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Extension","token","parserContext","node","renderContext","result","nodeResult","EOF","TEXT","PARTIAL","INVERTED_SECTION_OPEN","SECTION_OPEN","SECTION_CLOSE","UNESCAPED_VARIABLE","COMMENT","VARIABLE","DELIMITER_CHANGE","walk","modifier","stack","children","slice","reverse","pop","undefined","concat","visit","visitor","_parent","child","modified","trimStandaloneToken","tokens","count","open","inline","standalone","indentTokens","type","TokenType","isStringWhitespace","text","tailWSNodeCount","indent","forEach","t","str","test","_token","obj","newObj","ROOT","SECTION","_interopRequireWildcard","_node","NodeType","_tokenizer","_extension","ParserContext","parser","_parser","_appendNode","_pushParent","_popParent","f","_stack","item","message","location","_throw","_filename","parentNode","_src","Parser","arguments","_delimiters","delimiters","_extensions","extensions","filename","_parserContext","_lastToken","src","rootNode","_parseNodes","_addNodeToken","JSON","parse","stringify","beginLocation","endLocation","_clone","endIndex","endLine","initialStackSize","z","Tokenizer","getNextToken","error","handled","ext","handleToken","_makeLocation","unescaped","_handleSectionOpen","_handleSectionClose","_handleComment","join","e","Error","inverted","section","raw","index","content","extractNewDelimiters","tagContent","matches","match","R_DELIMITER_CHANGE","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","Array","isArray","_helpers","STATE_NONE","_index","_char","_tokens","_line","_column","_state","_error","_location","line","column","shift","matched","_markTokenStartLocation","_read","_handleEOF","_handleText","_handleTextBreak","_handleTag","_markTokenEndLocation","_isDelimiter","_handleStandaloneTag","_makeToken","left","right","_skip","_skipAllWhitespaces","_setError","_handleEmptyTag","tagTypeChar","_handleVariableCurly","tagContentStart","_handleSimpleTag","substr","_handleDelimiterChange","_handleVariable","newDelimiters","_newDelimiters","trim","begin","_distance","console","log","_isWhitespace","endColumn","offset","delimiter","pos","transformToken","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","isInheritanceTagType","PARENT","BLOCK","_get","_x","_x2","_x3","_again","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_token2","Inheritance","_Extension","_blocks","_parentStack","pushParent","_pushBlock","tagNode","popParent","appendNode","firstLine","firstBlock","find","blockNode","rendererContext","top","_checkTop","_handleParent","_handleBlock","findParentNode","pushNodes","blocks","blockName","keys","_setDefaultBlocks","pushNode","defaultBlock","_getDefaultBlock","frame","topFrame","assign","isFunction","x","toString","nodeTypes","_escapeHtml","_escapeHtml2","default","RenderContext","renderer","_renderer","_evaluate","nodes","_pushNodes","_pushNode","ctx","sp","_pushContext","_out","_parse","_getParsedPartial","Renderer","_this","_parsed","parsed","_partials","partials","_renderContext","_partialCached","k","_contextStack","_partialStack","_lambdaStack","_transformNodeResult","reduce","r","transformNodeResult","context","_this2","node_count","newline","handleNode","splice","partial","_popNode","_expandLambda","isList","testResult","_pushRepeaterNode","_expandPartial","repeat","repeatIndex","contextIndex","contexts","_replaceContextAt","_checkStacks","transformResult","list","Math","min","max","RangeError","_ref","_ref2","path","split","current","resolved","pi","ast","_pushPartial","lambda","_pushLambda","skipped","code","compile","render","Helpers","_extensionsInheritance","escapeHtml","string","matchHtmlRegExp","exec","escape","html","lastIndex","charCodeAt","substring"],"mappings":"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","file":"huz.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.instantiateAll = instantiateAll;\nexports.register = register;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar registry = [];\n\nvar Extension = (function () {\n  function Extension() {\n    _classCallCheck(this, Extension);\n  }\n\n  _createClass(Extension, [{\n    key: \"transformToken\",\n\n    //called by tokenizer\n    value: function transformToken(token) {\n      return token;\n    }\n\n    //called by parser\n  }, {\n    key: \"handleToken\",\n    value: function handleToken(token, parserContext) {}\n  }, {\n    key: \"visit\",\n    value: function visit(root) {\n      return root;\n    }\n\n    //called by renderer\n  }, {\n    key: \"handleNode\",\n    value: function handleNode(node, renderContext) {}\n  }, {\n    key: \"transformNodeResult\",\n    value: function transformNodeResult(node, result, nodeResult) {\n      return nodeResult;\n    }\n  }, {\n    key: \"transformResult\",\n    value: function transformResult(result) {\n      return result;\n    }\n  }]);\n\n  return Extension;\n})();\n\nexports.Extension = Extension;\n\nfunction instantiateAll(opts) {\n  return registry.map(function (ctor) {\n    return new ctor(opts);\n  });\n}\n\nfunction register(constructor) {\n  return registry.push(constructor);\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar EOF = 'EOF';\nexports.EOF = EOF;\nvar TEXT = 'TEXT';\nexports.TEXT = TEXT;\nvar PARTIAL = 'PARTIAL';\nexports.PARTIAL = PARTIAL;\nvar INVERTED_SECTION_OPEN = 'INVERTED_SECTION_OPEN';\nexports.INVERTED_SECTION_OPEN = INVERTED_SECTION_OPEN;\nvar SECTION_OPEN = 'SECTION_OPEN';\nexports.SECTION_OPEN = SECTION_OPEN;\nvar SECTION_CLOSE = 'SECTION_CLOSE';\nexports.SECTION_CLOSE = SECTION_CLOSE;\nvar UNESCAPED_VARIABLE = 'UNESCAPED_VARIABLE';\nexports.UNESCAPED_VARIABLE = UNESCAPED_VARIABLE;\nvar COMMENT = 'COMMENT';\nexports.COMMENT = COMMENT;\nvar VARIABLE = 'VARIABLE';\nexports.VARIABLE = VARIABLE;\nvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\nexports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.walk = walk;\nexports.visit = visit;\nexports.trimStandaloneToken = trimStandaloneToken;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nfunction walk(root, modifier) {\n  var stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    var node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nfunction visit(root, visitor) {\n  var stack = [root];\n  while (stack.length) {\n    var _parent = stack.pop();\n    for (var i = 0; i < _parent.children.length; i++) {\n      var child = _parent.children[i];\n      var modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        _parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nfunction trimStandaloneToken(tokens) {\n  var count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  var open = null;\n  var inline = 0;\n  var standalone = true;\n  var indentTokens = [];\n  for (var i = 0; standalone && i < count; i++) {\n    var token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline++;\n        }\n        break;\n      default:\n        //section-like tags\n        if (open === null) {\n          open = [token];\n          inline++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n\n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    var tailWSNodeCount = 0;\n    for (var i = count - 1; i >= 0; i--) {\n      var token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        var indent = '';\n        indentTokens.forEach(function (t) {\n          indent += t.text;\n        });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return (/^\\s*$/.test(str)\n  );\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar ROOT = \"ROOT\";\nexports.ROOT = ROOT;\nvar VARIABLE = \"VARIABLE\";\nexports.VARIABLE = VARIABLE;\nvar SECTION = \"SECTION\";\nexports.SECTION = SECTION;\nvar TEXT = \"TEXT\";\nexports.TEXT = TEXT;\nvar COMMENT = \"COMMENT\";\nexports.COMMENT = COMMENT;\nvar PARTIAL = \"PARTIAL\";\nexports.PARTIAL = PARTIAL;\nvar DELIMITER_CHANGE = \"DELIMITER_CHANGE\";\nexports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _tokenizer = __webpack_require__(5);\n\nvar _helpers = __webpack_require__(2);\n\nvar _extension = __webpack_require__(0);\n\nvar ParserContext = (function () {\n  function ParserContext(parser) {\n    _classCallCheck(this, ParserContext);\n\n    this._parser = parser;\n  }\n\n  _createClass(ParserContext, [{\n    key: \"appendNode\",\n    value: function appendNode(node) {\n      this._parser._appendNode(node);\n    }\n  }, {\n    key: \"pushParent\",\n    value: function pushParent(node) {\n      this._parser._pushParent(node);\n    }\n  }, {\n    key: \"popParent\",\n    value: function popParent() {\n      return this._parser._popParent();\n    }\n  }, {\n    key: \"findParentNode\",\n    value: function findParentNode(f) {\n      for (var i = this._parser._stack.length - 1; i >= 0; i--) {\n        var item = this._parser._stack[i];\n        if (f(item)) {\n          return item;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(message, location) {\n      return this._parser._throw(message, location);\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._parser._filename;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._parser._stack.length;\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n    }\n\n    /// deprecated, use `parentNode` instead\n  }, {\n    key: \"tailNode\",\n    get: function get() {\n      return this.parentNode;\n    }\n  }, {\n    key: \"src\",\n    get: function get() {\n      return this._parser._src;\n    }\n  }]);\n\n  return ParserContext;\n})();\n\nvar Parser = (function () {\n  function Parser() {\n    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, Parser);\n\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n    this._filename = opts.filename || \"\";\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(src) {\n      var rootNode = {\n        type: NodeType.ROOT,\n        children: []\n      };\n      this._src = src;\n      this._stack = [rootNode];\n      this._lastToken = null;\n      this._parseNodes(src);\n\n      if (this._extensions.length > 0) {\n        for (var i = 0; i < this._extensions.length; i++) {\n          this._extensions[i].visit(rootNode);\n        }\n      }\n\n      return rootNode;\n    }\n  }, {\n    key: \"_addNodeToken\",\n    value: function _addNodeToken(node) {\n      var token = this._lastToken;\n      if (node.tokens) {\n        node.tokens.push(token);\n      } else {\n        node.tokens = [token];\n      }\n    }\n  }, {\n    key: \"_appendNode\",\n    value: function _appendNode(node) {\n      this._addNodeToken(node);\n      node.location.filename = this._filename;\n      this._stack[this._stack.length - 1].children.push(node);\n      return node;\n    }\n  }, {\n    key: \"_getTop\",\n    value: function _getTop() {\n      return this._stack[this._stack.length - 1];\n    }\n  }, {\n    key: \"_clone\",\n    value: function _clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  }, {\n    key: \"_makeLocation\",\n    value: function _makeLocation(beginLocation, endLocation) {\n      var location = this._clone(beginLocation);\n      if (endLocation) {\n        location.endIndex = endLocation.endIndex;\n        location.endLine = endLocation.endLine;\n      }\n      return location;\n    }\n  }, {\n    key: \"_parseNodes\",\n    value: function _parseNodes(src) {\n      var initialStackSize = this._stack.length;\n      var token = undefined;\n      var z = new _tokenizer.Tokenizer(src, {\n        delimiters: this._delimiters.slice(0),\n        extensions: this._extensions,\n        filename: this._filename\n      });\n\n      do {\n        token = z.getNextToken();\n\n        if (z.error !== null) {\n          throw z.error;\n        }\n\n        this._lastToken = token;\n\n        var handled = false;\n        if (this._extensions) {\n          for (var i = 0; i < this._extensions.length; i++) {\n            var ext = this._extensions[i];\n            if (ext.handleToken(token, this._parserContext) === true) {\n              handled = true;\n              break;\n            }\n          }\n        }\n\n        if (!handled) {\n          switch (token.type) {\n            case TokenType.TEXT:\n              this._appendNode({\n                type: NodeType.TEXT,\n                text: token.text,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.VARIABLE:\n            case TokenType.UNESCAPED_VARIABLE:\n              this._appendNode({\n                type: NodeType.VARIABLE,\n                name: token.name,\n                unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.SECTION_OPEN:\n              this._handleSectionOpen(token);\n              break;\n\n            case TokenType.INVERTED_SECTION_OPEN:\n              this._handleSectionOpen(token, true);\n              break;\n\n            case TokenType.SECTION_CLOSE:\n              this._handleSectionClose(token);\n              break;\n\n            case TokenType.PARTIAL:\n              this._appendNode({\n                type: NodeType.PARTIAL,\n                name: token.name,\n                indent: token.indent,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.COMMENT:\n              this._handleComment(token);\n              break;\n\n            case TokenType.DELIMITER_CHANGE:\n              this._appendNode({\n                type: NodeType.DELIMITER_CHANGE,\n                delimiters: token.delimiters,\n                location: this._makeLocation(token.location)\n              });\n              break;\n          }\n        }\n      } while (token.type !== TokenType.EOF);\n\n      if (this._stack.length > initialStackSize) {\n        this._throw(\"Unexpected EOF: sections not closed: \" + this._stack.slice(initialStackSize).map(function (n) {\n          return \"'\" + n.name + \"'\";\n        }).join(\", \"));\n      } else if (this._stack.length < initialStackSize) {\n        this._throw(\"Internal error.\");\n      }\n    }\n  }, {\n    key: \"_throw\",\n    value: function _throw(message, location) {\n      location = location || this._lastToken.location;\n      var e = new Error(message);\n      e.filename = location.filename;\n      e.location = location;\n      throw e;\n    }\n  }, {\n    key: \"_pushParent\",\n    value: function _pushParent(node) {\n      this._addNodeToken(node);\n      node.children = [];\n      this._stack.push(node);\n    }\n  }, {\n    key: \"_popParent\",\n    value: function _popParent() {\n      return this._stack.pop();\n    }\n  }, {\n    key: \"_handleSectionOpen\",\n    value: function _handleSectionOpen(token) {\n      var inverted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n      var name = token.name;\n      var location = token.location;\n\n      this._pushParent({\n        type: NodeType.SECTION,\n        name: name,\n        inverted: inverted,\n        location: location\n      });\n    }\n  }, {\n    key: \"_handleSectionClose\",\n    value: function _handleSectionClose(token) {\n      var name = token.name;\n      var location = token.location;\n\n      var section = this._popParent();\n      if (section.type !== NodeType.SECTION) {\n        this._throw(\"Unexpected SECTION_CLOSE: '\" + name + \"'\");\n      }\n\n      if (section.name !== name) {\n        this._throw(\"Unexpected SECTION_CLOSE: '\" + name + \"', current section: '\" + section.name + \"'\");\n      }\n\n      section.raw = this._src.slice(section.location.endIndex, location.index);\n      section.location = this._makeLocation(section.location, token.location);\n\n      this._appendNode(section);\n    }\n  }, {\n    key: \"_handleComment\",\n    value: function _handleComment(token) {\n      var content = token.content;\n      var location = token.location;\n\n      this._appendNode({\n        type: NodeType.COMMENT,\n        content: content,\n        location: this._makeLocation(location)\n      });\n    }\n  }]);\n\n  return Parser;\n})();\n\nexports.Parser = Parser;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; })();\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _extension = __webpack_require__(0);\n\nvar _helpers = __webpack_require__(2);\n\nvar STATE_NONE = \"STATE_NONE\";\nvar STATE_EOF = \"STATE_EOF\";\nvar STATE_TEXT = \"STATE_TEXT\";\nvar STATE_TEXT_BREAK = \"STATE_TEXT_BREAK\";\nvar STATE_TAG = \"STATE_TAG\";\n\nvar DELIMITER_LEFT = 0;\nvar DELIMITER_RIGHT = 1;\n\nvar Tokenizer = (function () {\n  function Tokenizer(src) {\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Tokenizer);\n\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 1;\n    this._column = 1;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n  }\n\n  _createClass(Tokenizer, [{\n    key: \"getNextToken\",\n    value: function getNextToken() {\n      if (this._tokens.length > 0) {\n        return this._tokens.shift();\n      }\n\n      var done = false;\n      var matched = false;\n      do {\n        //console.log(this._state, this._tokens);\n        if (this._error !== null) {\n          return null;\n        }\n\n        if (this._state !== STATE_NONE) {\n          matched = true;\n          this._markTokenStartLocation();\n        }\n\n        switch (this._state) {\n          case STATE_NONE:\n            this._read();\n            break;\n\n          case STATE_EOF:\n            this._handleEOF();\n            done = true;\n            break;\n\n          case STATE_TEXT:\n            this._handleText();\n            break;\n\n          case STATE_TEXT_BREAK:\n            this._handleTextBreak();\n            done = true;\n            break;\n\n          case STATE_TAG:\n            this._handleTag();\n            break;\n        }\n\n        if (matched && !this._error) {\n          this._markTokenEndLocation();\n          matched = false;\n        }\n\n        if (this._state === STATE_NONE) {\n          if (this._char === null) {\n            this._state = STATE_EOF;\n          } else if (this._char === \"\\n\") {\n            this._state = STATE_TEXT_BREAK;\n          } else if (this._isDelimiter(DELIMITER_LEFT)) {\n            this._state = STATE_TAG;\n          } else {\n            this._state = STATE_TEXT;\n          }\n        }\n      } while (!done);\n\n      return this._error === null ? this._tokens.shift() : null;\n    }\n\n    // Handlers\n\n  }, {\n    key: \"_handleEOF\",\n    value: function _handleEOF() {\n      this._handleStandaloneTag();\n      this._makeToken({\n        type: TokenType.EOF\n      });\n    }\n  }, {\n    key: \"_handleTag\",\n    value: function _handleTag() {\n      var _delimiters = _slicedToArray(this._delimiters, 2);\n\n      var left = _delimiters[0];\n      var right = _delimiters[1];\n\n      this._skip(left.length);\n      this._skipAllWhitespaces();\n\n      if (this._char === null) {\n        this._setError(\"Unclosed tag.\");\n      } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n        this._handleEmptyTag();\n      } else {\n        var tagTypeChar = this._char;\n        if (tagTypeChar === \"{\") {\n          this._handleVariableCurly();\n        } else {\n          var tagContentStart = this._index - 1;\n          //read content\n          while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n            this._read();\n          }\n\n          if (this._char === null) {\n            this._setError(\"Unclosed tag.\");\n          } else {\n            var content = this._src.slice(tagContentStart, this._index - 1);\n            switch (tagTypeChar) {\n              case \">\":\n                this._handleSimpleTag(TokenType.PARTIAL, content);\n                break;\n              case \"^\":\n                this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);\n                break;\n              case \"#\":\n                this._handleSimpleTag(TokenType.SECTION_OPEN, content);\n                break;\n              case \"/\":\n                this._handleSimpleTag(TokenType.SECTION_CLOSE, content);\n                break;\n\n              case \"!\":\n                this._handleComment(content.substr(1));\n                break;\n\n              case \"=\":\n                this._handleDelimiterChange(content);\n                break;\n              case \"&\":\n                this._handleVariable(content.substr(1), true);\n                break;\n              default:\n                this._handleVariable(content);\n                break;\n            }\n          }\n        }\n      }\n      if (this._error === null) {\n        //eat right\n        for (var i = 0; i < right.length; i++) {\n          this._read();\n        }\n      }\n\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleDelimiterChange\",\n    value: function _handleDelimiterChange(content) {\n      var newDelimiters = extractNewDelimiters(content);\n      if (newDelimiters === null) {\n        this._setError(\"Invalid change delimiter syntax.\");\n      } else {\n        var _newDelimiters = _slicedToArray(newDelimiters, 2);\n\n        var left = _newDelimiters[0];\n        var right = _newDelimiters[1];\n\n        this._delimiters = newDelimiters;\n        this._makeToken({\n          type: TokenType.DELIMITER_CHANGE,\n          delimiters: [left, right]\n        });\n      }\n    }\n  }, {\n    key: \"_handleSimpleTag\",\n    value: function _handleSimpleTag(type, content) {\n      this._makeToken({ type: type, name: content.substr(1).trim() });\n    }\n  }, {\n    key: \"_handleComment\",\n    value: function _handleComment(content) {\n      this._makeToken({\n        type: TokenType.COMMENT,\n        content: content\n      });\n    }\n  }, {\n    key: \"_handleVariableCurly\",\n    value: function _handleVariableCurly() {\n      this._read(); //eat '{'\n      var begin = this._index - 1;\n      var d = this._distance(\"}\");\n      if (d === -1) {\n        this._setError(\"Unclosed variable tag: missingright curly.\");\n      } else {\n        var content = this._src.slice(begin, begin + d);\n        this._skip(d + 1); //skip '}'\n        this._skipAllWhitespaces();\n        if (!this._isDelimiter(DELIMITER_RIGHT)) {\n          this._setError(\"Unclosed variable: missing right delimiter.\");\n        } else {\n          this._makeToken({\n            type: TokenType.UNESCAPED_VARIABLE,\n            name: content.trim()\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_handleEmptyTag\",\n    value: function _handleEmptyTag() {\n      this._makeToken({\n        type: TokenType.VARIABLE,\n        name: \"\"\n      });\n    }\n  }, {\n    key: \"_handleVariable\",\n    value: function _handleVariable(content, unescaped) {\n      this._makeToken({\n        type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n        name: content.trim()\n      });\n    }\n  }, {\n    key: \"_handleText\",\n    value: function _handleText() {\n      var done = false;\n      var index = this._index - 1;\n      var length = 0;\n      do {\n        var c = this._char;\n\n        if (c === null || c === \"\\n\" || this._isDelimiter(DELIMITER_LEFT)) {\n          done = true;\n        } else {\n          length++;\n        }\n\n        if (!done) {\n          this._read();\n        }\n      } while (!done);\n\n      this._makeToken({\n        type: TokenType.TEXT,\n        text: this._src.slice(index, index + length)\n      });\n\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleTextBreak\",\n    value: function _handleTextBreak() {\n      this._makeToken({\n        type: TokenType.TEXT,\n        text: \"\\n\"\n      });\n      this._read();\n      this._handleStandaloneTag();\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleStandaloneTag\",\n    value: function _handleStandaloneTag() {\n      this._tokens = (0, _helpers.trimStandaloneToken)(this._tokens);\n    }\n\n    // Helpers\n  }, {\n    key: \"_dump\",\n    value: function _dump() {\n      var t = arguments.length <= 0 || arguments[0] === undefined ? \"\" : arguments[0];\n\n      console.log(t + \">\" + this._src.slice(this._index - 1));\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      if (this._index < this._src.length) {\n        if (this._char === \"\\n\") {\n          this._line++;\n          this._column = 0;\n        } else {\n          this._column++;\n        }\n\n        this._char = this._src[this._index];\n        this._index++;\n      } else {\n        this._char = null;\n      }\n    }\n  }, {\n    key: \"_peek\",\n    value: function _peek() {\n      if (this._index < this._src.length - 1) {\n        return this._src[this._index];\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_skip\",\n    value: function _skip(n) {\n      for (var i = 0; i < n; i++) {\n        this._read();\n      }\n    }\n  }, {\n    key: \"_distance\",\n    value: function _distance(c) {\n      for (var i = this._index; i < this._src.length; i++) {\n        if (this._src[i] === c) {\n          return i - this._index + 1;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"_skipAllWhitespaces\",\n    value: function _skipAllWhitespaces() {\n      while (this._isWhitespace()) {\n        this._read();\n      }\n    }\n  }, {\n    key: \"_markTokenStartLocation\",\n    value: function _markTokenStartLocation() {\n      this._location.index = this._index - 1;\n      this._location.line = this._line;\n      this._location.column = this._column;\n    }\n  }, {\n    key: \"_markTokenEndLocation\",\n    value: function _markTokenEndLocation() {\n      var token = this._tokens[this._tokens.length - 1];\n      token.location.endIndex = this._index - 1;\n      token.location.endLine = this._line;\n      token.location.endColumn = this._column;\n    }\n  }, {\n    key: \"_isWhitespace\",\n    value: function _isWhitespace() {\n      return (/\\s/.test(this._char)\n      );\n    }\n  }, {\n    key: \"_isDelimiter\",\n    value: function _isDelimiter(d) {\n      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      var delimiter = this._delimiters[d];\n      var pos = this._index - 1 + offset;\n      return this._src.slice(pos, pos + delimiter.length) === delimiter;\n    }\n  }, {\n    key: \"_makeToken\",\n    value: function _makeToken(token) {\n      token.filename = this._filename;\n      var _location = this._location;\n      var index = _location.index;\n      var line = _location.line;\n      var column = _location.column;\n\n      token.location = {\n        filename: this._filename,\n        index: index,\n        line: line,\n        column: column\n      };\n      if (this._extensions.length) {\n        try {\n          this._extensions.forEach(function (ext) {\n            token = ext.transformToken(token);\n          });\n        } catch (e) {\n          this._setError(e.message);\n          return;\n        }\n      }\n      this._tokens.push(token);\n    }\n  }, {\n    key: \"_setError\",\n    value: function _setError(message) {\n      var error = new Error(message);\n      error.filename = this._filename;\n      error.index = this._index - 1;\n      error.line = this._line;\n      error.column = this._column;\n      this._error = error;\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      return this._error;\n    }\n  }]);\n\n  return Tokenizer;\n})();\n\nexports.Tokenizer = Tokenizer;\n\nvar R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  var matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// https://github.com/mustache/spec/pull/75\n\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _extension = __webpack_require__(0);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _token2 = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token2);\n\nvar PARENT = \"Inheritance.PARENT\";\nvar BLOCK = \"Inheritance.BLOCK\";\nvar LEAVE_SCOPE = \"Inheritance.LEAVE_SCOPE\";\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nvar Inheritance = (function (_Extension) {\n  _inherits(Inheritance, _Extension);\n\n  function Inheritance() {\n    _classCallCheck(this, Inheritance);\n\n    _get(Object.getPrototypeOf(Inheritance.prototype), \"constructor\", this).call(this);\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  _createClass(Inheritance, [{\n    key: \"transformToken\",\n    value: function transformToken(token) {\n      var _token = token;\n      var type = _token.type;\n      var name = _token.name;\n      var location = _token.location;\n\n      switch (type) {\n        case TokenType.VARIABLE:\n          if (name) {\n            if (name[0] === \"<\") {\n              if (name.length === 1) {\n                throw new Error(\"Parent partial name expected\");\n              }\n              token = {\n                type: PARENT,\n                name: name.slice(1),\n                location: location\n              };\n            } else if (name[0] === \"$\") {\n              if (name.length === 1) {\n                throw new Error(\"Block name expected\");\n              }\n              token = {\n                type: BLOCK,\n                name: name.slice(1),\n                location: location\n              };\n            }\n          }\n          break;\n      }\n      return token;\n    }\n  }, {\n    key: \"handleToken\",\n    value: function handleToken(token, parserContext) {\n      var handled = false;\n      var name = token.name;\n      var location = token.location;\n      var type = token.type;\n\n      switch (type) {\n        case PARENT:\n          parserContext.pushParent({\n            type: PARENT,\n            name: name,\n            location: location\n          });\n          handled = true;\n          break;\n\n        case BLOCK:\n          this._pushBlock({\n            type: BLOCK,\n            content: \"\",\n            name: name,\n            location: location\n          }, parserContext);\n          break;\n\n        case TokenType.SECTION_CLOSE:\n          var tagNode = parserContext.parentNode;\n          if (isInheritanceTagType(tagNode.type) && tagNode.name !== name) {\n            parserContext[\"throw\"](\"Unexpected tag close '\" + name + \"', current tag: '\" + tagNode.name + \"'\");\n          }\n          if (isInheritanceTagType(tagNode.type)) {\n            if (tagNode.type === BLOCK) {\n              var content = parserContext.src.slice(tagNode.location.endIndex, location.index);\n              tagNode.content = content;\n            }\n\n            parserContext.popParent();\n            tagNode.location.endIndex = location.endIndex;\n            tagNode.location.endLine = location.endLine;\n            parserContext.appendNode(tagNode);\n\n            //TODO move this to visit, handle whitespaces after Parent close tag.\n            var firstLine = tagNode.location.line;\n            var firstBlock = tagNode.children.find(function (c) {\n              return c.type === BLOCK;\n            });\n            if (firstBlock && firstBlock.location.line === firstLine) {\n              for (var i = 0; i < firstBlock.children.length; i++) {\n                var blockNode = firstBlock.children[i];\n                if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n                  blockNode.text = \"\";\n                } else {\n                  break;\n                }\n              }\n            }\n\n            handled = true;\n          }\n          break;\n      }\n      return handled;\n    }\n  }, {\n    key: \"handleNode\",\n    value: function handleNode(node, rendererContext) {\n      var top = rendererContext.top;\n      this._checkTop(top);\n\n      switch (node.type) {\n        case PARENT:\n          this._handleParent(node, rendererContext);\n          return true;\n\n        case BLOCK:\n          this._handleBlock(node, rendererContext);\n          return true;\n\n        case LEAVE_SCOPE:\n          this._blocks = null;\n          return true;\n      }\n    }\n  }, {\n    key: \"_pushBlock\",\n    value: function _pushBlock(node, parserContext) {\n      var parent = parserContext.findParentNode(function (parent) {\n        return parent.type === BLOCK && parent.name === node.name;\n      });\n      if (parent) {\n        parserContext[\"throw\"](\"Recursive block: '\" + node.name + \"'\");\n      }\n      parserContext.pushParent(node);\n    }\n  }, {\n    key: \"_handleParent\",\n    value: function _handleParent(node, rendererContext) {\n      var name = node.name;\n      var location = node.location;\n\n      var top = rendererContext.top;\n\n      this._pushParent(name, top);\n\n      if (this._blocks === null) {\n        rendererContext.pushNodes([{\n          type: LEAVE_SCOPE\n        }]);\n        this._blocks = {};\n      }\n\n      //find all blocks defined in parent\n      var blocks = {};\n      node.children.forEach(function (child) {\n        if (child.type === BLOCK) {\n          var blockName = child.name;\n          blocks[blockName] = child;\n        }\n      });\n      if (Object.keys(blocks).length) {\n        this._setDefaultBlocks(blocks);\n      }\n\n      rendererContext.pushNode({\n        type: TokenType.PARTIAL,\n        name: name,\n        location: location,\n        indent: node.indent\n      });\n    }\n  }, {\n    key: \"_handleBlock\",\n    value: function _handleBlock(node, rendererContext) {\n      var name = node.name;\n\n      var defaultBlock = this._getDefaultBlock(name);\n      if (defaultBlock) {\n        rendererContext.pushNodes(defaultBlock.children);\n      } else {\n        rendererContext.pushNodes(node.children);\n      }\n    }\n  }, {\n    key: \"_pushParent\",\n    value: function _pushParent(name, top) {\n      return this._parentStack.push({\n        name: name,\n        blocks: {},\n        top: top\n      });\n    }\n  }, {\n    key: \"_checkTop\",\n    value: function _checkTop(top) {\n      var pop = 0;\n      for (var i = this._parentStack.length - 1; i >= 0; i--) {\n        var frame = this._parentStack[i];\n        if (frame.top > top) {\n          pop++;\n        } else {\n          break;\n        }\n      }\n      if (pop > 0) {\n        this._parentStack = this._parentStack.slice(0, this._parentStack.length - pop);\n      }\n    }\n  }, {\n    key: \"_popParent\",\n    value: function _popParent() {\n      return this._parentStack.pop();\n    }\n  }, {\n    key: \"_getDefaultBlock\",\n    value: function _getDefaultBlock(name) {\n      for (var i = 0; i < this._parentStack.length; i++) {\n        var frame = this._parentStack[i];\n        if (name in frame.blocks) {\n          return frame.blocks[name];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_setDefaultBlocks\",\n    value: function _setDefaultBlocks(blocks) {\n      var topFrame = this._parentStack[this._parentStack.length - 1];\n      topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n    }\n  }]);\n\n  return Inheritance;\n})(_extension.Extension);\n\nexports.Inheritance = Inheritance;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _node = __webpack_require__(3);\n\nvar nodeTypes = _interopRequireWildcard(_node);\n\nvar _escapeHtml = __webpack_require__(9);\n\nvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\nvar _parser = __webpack_require__(4);\n\nvar _helpers = __webpack_require__(2);\n\nvar _extension = __webpack_require__(0);\n\nvar REPEATER_NODE_TYPE = \"_REPEATER\";\nvar MAX_PARTIAL_STACK = 10;\nvar MAX_LAMBDA_STACK = 255;\nvar MAX_NODE_COUNT = 3000;\n\nvar RenderContext = (function () {\n  function RenderContext(renderer) {\n    _classCallCheck(this, RenderContext);\n\n    this._renderer = renderer;\n  }\n\n  _createClass(RenderContext, [{\n    key: \"evaluate\",\n    value: function evaluate(name) {\n      return this._renderer._evaluate(name);\n    }\n  }, {\n    key: \"pushNodes\",\n    value: function pushNodes(nodes) {\n      this._renderer._pushNodes(nodes);\n    }\n  }, {\n    key: \"pushNode\",\n    value: function pushNode(node) {\n      this._renderer._pushNode(node);\n    }\n  }, {\n    key: \"pushContext\",\n    value: function pushContext(ctx, sp) {\n      this._renderer._pushContext(ctx, sp);\n    }\n  }, {\n    key: \"appendText\",\n    value: function appendText(text) {\n      this._renderer._out += text;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(src, opts) {\n      return this._renderer._parse(src, opts);\n    }\n  }, {\n    key: \"getParsedPartial\",\n    value: function getParsedPartial(name) {\n      return this._renderer._getParsedPartial(name);\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(message, location) {\n      return this._renderer._throw(message, location);\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._renderer._stack.length;\n    }\n  }, {\n    key: \"result\",\n    get: function get() {\n      return this._renderer._out;\n    }\n  }]);\n\n  return RenderContext;\n})();\n\nvar Renderer = (function () {\n  function Renderer(src) {\n    var _this = this;\n\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Renderer);\n\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    this._filename = opts.filename;\n\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(function (k) {\n        _this._partialCached[k] = _this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = \"\";\n    this._transformNodeResult = function (node, result, nodeResult) {\n      return _this._extensions.reduce(function (r, e) {\n        return e.transformNodeResult(node, result, r);\n      }, nodeResult);\n    };\n  }\n\n  _createClass(Renderer, [{\n    key: \"render\",\n    value: function render(context) {\n      var _this2 = this;\n\n      this._out = \"\";\n      this._stack = [];\n      this._contextStack = [];\n      this._partialStack = [];\n      this._lambdaStack = [];\n\n      this._pushContext(context);\n\n      //push root nodes\n      var rootNode = this._parsed ? this._src : this._parse(this._src, { filename: this._filename });\n      this._stack = rootNode.children.slice(0).reverse();\n\n      var node_count = 0;\n\n      var newline = true;\n\n      var _loop = function () {\n        var top = _this2._stack.length - 1;\n        var node = _this2._stack[top];\n\n        if (node.type !== nodeTypes.TEXT) {\n          node_count++;\n          if (node_count > MAX_NODE_COUNT) {\n            _this2._throw(\"Possible infinity loop detected: last node type is '\" + node.type + \"'\", node.location);\n          }\n        }\n\n        var handled = false;\n        if (_this2._extensions) {\n          _this2._extensions.forEach(function (ext) {\n            if (ext.handleNode(node, _this2._renderContext)) {\n              handled = true;\n            }\n          });\n        }\n\n        if (handled) {\n          _this2._stack.splice(top, 1);\n        } else {\n          var partial = _this2._partialStack.length ? _this2._partialStack[_this2._partialStack.length - 1] : null;\n\n          //insert indent\n          if (node.type in nodeTypes) {\n            if (newline && partial !== null && partial.indent.length > 0) {\n              _this2._out += partial.indent;\n            }\n          }\n\n          var value = undefined;\n          switch (node.type) {\n            case nodeTypes.VARIABLE:\n              value = _this2._evaluate(node.name);\n              if (isFunction(value)) {\n                _this2._popNode();\n                _this2._expandLambda(node, value);\n              } else {\n                if (!!value) {\n                  var result = node.unescaped ? value : (0, _escapeHtml2[\"default\"])(value);\n                  _this2._out += _this2._transformNodeResult(node, _this2._out, result);\n                }\n                _this2._popNode();\n              }\n              break;\n\n            case nodeTypes.SECTION:\n              value = _this2._evaluate(node.name);\n              if (isFunction(value)) {\n                _this2._popNode();\n                _this2._expandLambda(node, value);\n              } else {\n                var isList = Array.isArray(value);\n\n                if (isList && value.length === 0) {\n                  //Empty lists should behave like falsey values.\n                  value = false;\n                  isList = false;\n                }\n\n                var testResult = !!value;\n                if (node.inverted) {\n                  testResult = !testResult;\n                }\n\n                if (testResult) {\n                  if (isList) {\n                    _this2._popNode();\n                    _this2._pushRepeaterNode(value.length, node.children, value);\n                  } else {\n                    _this2._popNode();\n                    _this2._pushContext(value);\n                    _this2._pushNodes(node.children);\n                  }\n                } else {\n                  _this2._popNode();\n                }\n              }\n              break;\n\n            case nodeTypes.TEXT:\n              _this2._out += _this2._transformNodeResult(node, _this2._out, node.text);\n              _this2._popNode();\n              break;\n\n            case nodeTypes.COMMENT:\n              _this2._popNode();\n              break;\n\n            case nodeTypes.PARTIAL:\n              _this2._popNode();\n              _this2._expandPartial(node);\n              break;\n\n            case nodeTypes.DELIMITER_CHANGE:\n              _this2._popNode();\n              _this2._delimiters = node.delimiters.slice(0);\n              break;\n\n            case REPEATER_NODE_TYPE:\n              if (node.count < node.repeat) {\n                var repeatIndex = node.count;\n                if (repeatIndex === 0) {\n                  node.contextIndex = _this2._pushContext(node.contexts[0]);\n                } else {\n                  _this2._replaceContextAt(node.contextIndex, node.contexts[repeatIndex]);\n                }\n                _this2._pushNodes(node.children);\n                node.count++;\n              } else {\n                _this2._popNode();\n              }\n              break;\n\n            default:\n              _this2._popNode();\n              break;\n          }\n        }\n        _this2._checkStacks();\n        newline = _this2._out.length === 0 || _this2._out[_this2._out.length - 1] === \"\\n\";\n      };\n\n      while (this._stack.length > 0) {\n        _loop();\n      }\n\n      return this._extensions.reduce(function (result, ext) {\n        return ext.transformResult(result);\n      }, this._out);\n    }\n  }, {\n    key: \"_parse\",\n    value: function _parse(src) {\n      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      opts.extensions = this._extensions;\n      var parser = new _parser.Parser(opts);\n      return parser.parse(src);\n    }\n  }, {\n    key: \"_pushNodes\",\n    value: function _pushNodes(list) {\n      for (var i = list.length - 1; i >= 0; i--) {\n        this._stack.push(list[i]);\n      }\n    }\n  }, {\n    key: \"_pushNode\",\n    value: function _pushNode(node) {\n      this._stack.push(node);\n    }\n  }, {\n    key: \"_popNode\",\n    value: function _popNode() {\n      this._stack.pop();\n    }\n  }, {\n    key: \"_pushRepeaterNode\",\n    value: function _pushRepeaterNode(repeat, nodes, contexts) {\n      this._stack.push({\n        type: REPEATER_NODE_TYPE,\n        count: 0,\n        repeat: repeat,\n        children: nodes.slice(0),\n        contexts: contexts\n      });\n    }\n  }, {\n    key: \"_pushContext\",\n    value: function _pushContext(context) {\n      var sp = arguments.length <= 1 || arguments[1] === undefined ? this._stack.length : arguments[1];\n\n      if (this._contextStack.length) {\n        sp = Math.min(Math.max(this._contextStack[this._contextStack.length - 1].sp, sp), this._stack.length);\n      }\n      return this._contextStack.push({\n        context: context,\n        sp: sp\n      }) - 1;\n    }\n  }, {\n    key: \"_replaceContextAt\",\n    value: function _replaceContextAt(index, context) {\n      if (index < 0 || index > this._contextStack.length - 1) {\n        throw new RangeError(\"Huz context index out of range.\");\n      }\n      this._contextStack[index].context = context;\n    }\n  }, {\n    key: \"_pushPartial\",\n    value: function _pushPartial(_ref) {\n      var name = _ref.name;\n      var indent = _ref.indent;\n      var location = _ref.location;\n\n      this._partialStack.push({\n        name: name,\n        indent: indent || \"\",\n        location: location,\n        sp: this._stack.length\n      });\n    }\n  }, {\n    key: \"_pushLambda\",\n    value: function _pushLambda(_ref2) {\n      var name = _ref2.name;\n      var location = _ref2.location;\n\n      this._lambdaStack.push({\n        name: name,\n        location: location,\n        sp: this._stack.length\n      });\n    }\n  }, {\n    key: \"_checkStacks\",\n    value: function _checkStacks() {\n      while (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n        this._contextStack.pop();\n      }\n\n      if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n        this._partialStack.pop();\n      }\n\n      if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n        this._lambdaStack.pop();\n      }\n    }\n  }, {\n    key: \"_evaluate\",\n    value: function _evaluate(name) {\n      if (name === \".\") {\n        return this._contextStack[this._contextStack.length - 1].context;\n      }\n\n      var path = name.split(\".\");\n      for (var i = this._contextStack.length - 1; i >= 0; i--) {\n        var context = this._contextStack[i].context;\n        if (context === null || typeof context !== \"object\") {\n          continue;\n        }\n\n        var current = context;\n        var resolved = true;\n        for (var pi = 0; pi < path.length; pi++) {\n          var key = path[pi];\n          if (typeof current === \"object\" && current !== null && current.hasOwnProperty(key)) {\n            current = current[key];\n          } else {\n            resolved = false;\n            break;\n          }\n        }\n\n        if (resolved) {\n          return current;\n        }\n      }\n      return \"\";\n    }\n  }, {\n    key: \"_getParsedPartial\",\n    value: function _getParsedPartial(name) {\n      if (this._partialCached.hasOwnProperty(name)) {\n        return this._partialCached[name];\n      } else {\n        if (!this._partials.hasOwnProperty(name)) {\n          return null;\n        }\n        var ast = this._parse(this._partials[name], { filename: name });\n        var nodes = this._partialCached[name] = ast.children;\n        return nodes;\n      }\n    }\n  }, {\n    key: \"_expandPartial\",\n    value: function _expandPartial(node) {\n      var name = node.name;\n\n      var nodes = this._getParsedPartial(name);\n\n      if (nodes === null) {\n        //The empty string should be used when the named partial is not found.\n        return;\n      }\n\n      this._pushPartial(node);\n\n      if (this._partialStack.length > MAX_PARTIAL_STACK) {\n        this._throw(\"Possible partial short circuit: \" + this._partialStack.map(function (f) {\n          return f.name + \"@\" + f.location.filename + \":\" + (f.location.line + 1);\n        }).concat([name]).join(\" -> \"), node.location);\n      }\n\n      this._pushNodes(nodes);\n    }\n  }, {\n    key: \"_expandLambda\",\n    value: function _expandLambda(node, lambda) {\n      var name = node.name;\n\n      this._pushLambda(node);\n\n      if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n        this._throw(\"Possible lambda short circuit: \" + this._lambdaStack.map(function (f) {\n          return f.name + \"@\" + f.location.filename + \":\" + (f.location.line + 1);\n        }).concat([name]).join(\" -> \"), node.location);\n      }\n\n      var ast = undefined;\n      var skipped = false;\n      if (node.type === nodeTypes.VARIABLE) {\n        var code = lambda();\n        if (code) {\n          //A lambda's return value should parse with the default delimiters.\n          ast = this._parse(\"\" + code, { filename: \"[lambda]\" });\n          if (!node.unescaped) {\n            //Lambda results should be appropriately escaped.\n            (0, _helpers.walk)(ast, function (node) {\n              if (node.type === nodeTypes.TEXT) {\n                node.text = (0, _escapeHtml2[\"default\"])(node.text);\n              }\n            });\n          }\n        } else {\n          skipped = true;\n        }\n      } else if (node.type === nodeTypes.SECTION) {\n        var code = lambda(node.raw);\n        if (code) {\n          //Lambdas used for inverted sections should be considered truthy.\n          //Lambdas used for sections should parse with the current delimiters.\n          ast = this._parse(\"\" + code, {\n            filename: \"[#lambda]\",\n            delimiters: this._delimiters.slice(0)\n          });\n        } else {\n          skipped = true;\n        }\n      }\n\n      if (!skipped) {\n        this._pushNodes(ast.children);\n      }\n    }\n  }, {\n    key: \"_throw\",\n    value: function _throw(message, location) {\n      var e = new Error(message);\n      e.filename = location.filename;\n      e.location = location;\n      throw e;\n    }\n  }]);\n\n  return Renderer;\n})();\n\nexports.Renderer = Renderer;\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == \"[object Function]\";\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.compile = compile;\nexports.render = render;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _parser = __webpack_require__(4);\n\nvar _renderer = __webpack_require__(7);\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _helpers = __webpack_require__(2);\n\nvar Helpers = _interopRequireWildcard(_helpers);\n\nvar _extension = __webpack_require__(0);\n\nvar _extensionsInheritance = __webpack_require__(6);\n\n// import { Section } from \"./extensions/section\";\n\nvar _tokenizer = __webpack_require__(5);\n\nObject.defineProperty(exports, \"Tokenizer\", {\n  enumerable: true,\n  get: function get() {\n    return _tokenizer.Tokenizer;\n  }\n});\nexports.Parser = _parser.Parser;\nexports.Renderer = _renderer.Renderer;\nexports.TokenType = TokenType;\nexports.NodeType = NodeType;\nObject.defineProperty(exports, \"Extension\", {\n  enumerable: true,\n  get: function get() {\n    return _extension.Extension;\n  }\n});\n(0, _extension.register)(_extensionsInheritance.Inheritance);\n// register(Section);\n\nfunction parse(src, opts) {\n  var parser = new _parser.Parser(opts);\n  return parser.parse(src);\n}\n\nfunction compile(src, opts) {\n  return new _renderer.Renderer(src, opts);\n}\n\nfunction render(src, context, opts) {\n  var r = compile(src, opts);\n  return r.render(context);\n}\n\nexports.register = _extension.register;\nexports.Helpers = Helpers;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// huz.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 624f5411a1ec63c1d8b2","const registry = [];\n\nexport class Extension {\n  //called by tokenizer\n  transformToken(token) { return token; }\n\n  //called by parser\n  handleToken(token, parserContext) { }\n  visit(root) { return root; }\n  \n  //called by renderer\n  handleNode(node, renderContext) { }\n  transformNodeResult(node, result, nodeResult) { return nodeResult; }\n  transformResult(result) { return result; }\n}\n\nexport function instantiateAll(opts) {\n  return registry.map(ctor => {\n    return new ctor(opts);\n  });\n}\n\nexport function register(constructor) {\n  return registry.push(constructor);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/extension.js","export const EOF                    = 'EOF';\nexport const TEXT                   = 'TEXT';\nexport const PARTIAL                = 'PARTIAL';\nexport const INVERTED_SECTION_OPEN  = 'INVERTED_SECTION_OPEN';\nexport const SECTION_OPEN           = 'SECTION_OPEN';\nexport const SECTION_CLOSE          = 'SECTION_CLOSE';\nexport const UNESCAPED_VARIABLE     = 'UNESCAPED_VARIABLE';\nexport const COMMENT                = 'COMMENT';\nexport const VARIABLE               = 'VARIABLE';\nexport const DELIMITER_CHANGE \t\t\t= 'DELIMITER_CHANGE';\n\n\n// WEBPACK FOOTER //\n// ./src/token.js","import * as TokenType from './token';\n\nexport function walk(root, modifier) {\n  let stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    const node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nexport function visit(root, visitor) {\n  let stack = [root];\n  while (stack.length) {\n    const parent = stack.pop();\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      const modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nexport function trimStandaloneToken(tokens) {\n  const count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  let open = null;\n  let inline = 0;\n  let standalone = true;\n  let indentTokens = [];\n  for (let i = 0; standalone && i < count; i++) {\n    const token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline ++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline ++;\n        }\n        break;\n      default: //section-like tags\n        if (open === null) {\n          open = [token];\n          inline ++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n  \n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    let tailWSNodeCount = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount ++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        let indent = '';\n        indentTokens.forEach(t => { indent += t.text });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return /^\\s*$/.test(str);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/helpers.js","export const ROOT = \"ROOT\";\nexport const VARIABLE = \"VARIABLE\";\nexport const SECTION = \"SECTION\";\nexport const TEXT = \"TEXT\";\nexport const COMMENT = \"COMMENT\";\nexport const PARTIAL = \"PARTIAL\";\nexport const DELIMITER_CHANGE = \"DELIMITER_CHANGE\";\n\n\n\n// WEBPACK FOOTER //\n// ./src/node.js","import * as TokenType from \"./token\";\nimport * as NodeType from \"./node\";\nimport { Tokenizer } from \"./tokenizer\";\nimport { visit } from \"./helpers\";\nimport { instantiateAll } from \"./extension\";\n\nclass ParserContext {\n  constructor(parser) {\n    this._parser = parser;\n  }\n\n  appendNode(node) {\n    this._parser._appendNode(node);\n  }\n\n  pushParent(node) {\n    this._parser._pushParent(node);\n  }\n\n  popParent() {\n    return this._parser._popParent();\n  }\n\n  get filename() {\n    return this._parser._filename;\n  }\n\n  get top() {\n    return this._parser._stack.length;\n  }\n\n  get parentNode() {\n    return this._parser._stack.length > 0\n      ? this._parser._stack[this._parser._stack.length - 1]\n      : null;\n  }\n\n  /// deprecated, use `parentNode` instead\n  get tailNode() {\n    return this.parentNode;\n  }\n\n  get src() {\n    return this._parser._src;\n  }\n\n  findParentNode(f) {\n    for (let i = this._parser._stack.length - 1; i >= 0; i--) {\n      const item = this._parser._stack[i];\n      if (f(item)) {\n        return item;\n      }\n    }\n    return null;\n  }\n\n  throw(message, location) {\n    return this._parser._throw(message, location);\n  }\n}\n\nexport class Parser {\n  constructor(opts = {}) {\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    this._filename = opts.filename || \"\";\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  parse(src) {\n    const rootNode = {\n      type: NodeType.ROOT,\n      children: []\n    };\n    this._src = src;\n    this._stack = [rootNode];\n    this._lastToken = null;\n    this._parseNodes(src);\n\n    if (this._extensions.length > 0) {\n      for (let i = 0; i < this._extensions.length; i++) {\n        this._extensions[i].visit(rootNode);\n      }\n    }\n\n    return rootNode;\n  }\n\n  _addNodeToken(node) {\n    const token = this._lastToken;\n    if (node.tokens) {\n      node.tokens.push(token);\n    } else {\n      node.tokens = [token];\n    }\n  }\n\n  _appendNode(node) {\n    this._addNodeToken(node);\n    node.location.filename = this._filename;\n    this._stack[this._stack.length - 1].children.push(node);\n    return node;\n  }\n\n  _getTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  _clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  _makeLocation(beginLocation, endLocation) {\n    const location = this._clone(beginLocation);\n    if (endLocation) {\n      location.endIndex = endLocation.endIndex;\n      location.endLine = endLocation.endLine;\n    }\n    return location;\n  }\n\n  _parseNodes(src) {\n    let initialStackSize = this._stack.length;\n    let token;\n    const z = new Tokenizer(src, {\n      delimiters: this._delimiters.slice(0),\n      extensions: this._extensions,\n      filename: this._filename\n    });\n\n    do {\n      token = z.getNextToken();\n\n      if (z.error !== null) {\n        throw z.error;\n      }\n\n      this._lastToken = token;\n\n      let handled = false;\n      if (this._extensions) {\n        for (let i = 0; i < this._extensions.length; i++) {\n          const ext = this._extensions[i];\n          if (ext.handleToken(token, this._parserContext) === true) {\n            handled = true;\n            break;\n          }\n        }\n      }\n\n      if (!handled) {\n        switch (token.type) {\n          case TokenType.TEXT:\n            this._appendNode({\n              type: NodeType.TEXT,\n              text: token.text,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.VARIABLE:\n          case TokenType.UNESCAPED_VARIABLE:\n            this._appendNode({\n              type: NodeType.VARIABLE,\n              name: token.name,\n              unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.SECTION_OPEN:\n            this._handleSectionOpen(token);\n            break;\n\n          case TokenType.INVERTED_SECTION_OPEN:\n            this._handleSectionOpen(token, true);\n            break;\n\n          case TokenType.SECTION_CLOSE:\n            this._handleSectionClose(token);\n            break;\n\n          case TokenType.PARTIAL:\n            this._appendNode({\n              type: NodeType.PARTIAL,\n              name: token.name,\n              indent: token.indent,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.COMMENT:\n            this._handleComment(token);\n            break;\n\n          case TokenType.DELIMITER_CHANGE:\n            this._appendNode({\n              type: NodeType.DELIMITER_CHANGE,\n              delimiters: token.delimiters,\n              location: this._makeLocation(token.location)\n            });\n            break;\n        }\n      }\n    } while (token.type !== TokenType.EOF);\n\n    if (this._stack.length > initialStackSize) {\n      this._throw(\n        \"Unexpected EOF: sections not closed: \" +\n          this._stack\n            .slice(initialStackSize)\n            .map(n => `'${n.name}'`)\n            .join(\", \")\n      );\n    } else if (this._stack.length < initialStackSize) {\n      this._throw(\"Internal error.\");\n    }\n  }\n\n  _throw(message, location) {\n    location = location || this._lastToken.location;\n    const e = new Error(message);\n    e.filename = location.filename;\n    e.location = location;\n    throw e;\n  }\n\n  _pushParent(node) {\n    this._addNodeToken(node);\n    node.children = [];\n    this._stack.push(node);\n  }\n\n  _popParent() {\n    return this._stack.pop();\n  }\n\n  _handleSectionOpen(token, inverted = false) {\n    const { name, location } = token;\n    this._pushParent({\n      type: NodeType.SECTION,\n      name,\n      inverted,\n      location\n    });\n  }\n\n  _handleSectionClose(token) {\n    const { name, location } = token;\n    const section = this._popParent();\n    if (section.type !== NodeType.SECTION) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}'`);\n    }\n\n    if (section.name !== name) {\n      this._throw(\n        `Unexpected SECTION_CLOSE: '${name}', current section: '${\n          section.name\n        }'`\n      );\n    }\n\n    section.raw = this._src.slice(section.location.endIndex, location.index);\n    section.location = this._makeLocation(section.location, token.location);\n\n    this._appendNode(section);\n  }\n\n  _handleComment(token) {\n    const { content, location } = token;\n    this._appendNode({\n      type: NodeType.COMMENT,\n      content,\n      location: this._makeLocation(location)\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/parser.js","import * as TokenType from \"./token\";\nimport { instantiateAll } from \"./extension\";\nimport { trimStandaloneToken } from \"./helpers\";\n\nconst STATE_NONE = \"STATE_NONE\";\nconst STATE_EOF = \"STATE_EOF\";\nconst STATE_TEXT = \"STATE_TEXT\";\nconst STATE_TEXT_BREAK = \"STATE_TEXT_BREAK\";\nconst STATE_TAG = \"STATE_TAG\";\n\nconst DELIMITER_LEFT = 0;\nconst DELIMITER_RIGHT = 1;\n\nexport class Tokenizer {\n  constructor(src, opts = {}) {\n    this._extensions = opts.extensions || instantiateAll();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 1;\n    this._column = 1;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  getNextToken() {\n    if (this._tokens.length > 0) {\n      return this._tokens.shift();\n    }\n\n    let done = false;\n    let matched = false;\n    do {\n      //console.log(this._state, this._tokens);\n      if (this._error !== null) {\n        return null;\n      }\n\n      if (this._state !== STATE_NONE) {\n        matched = true;\n        this._markTokenStartLocation();\n      }\n\n      switch (this._state) {\n        case STATE_NONE:\n          this._read();\n          break;\n\n        case STATE_EOF:\n          this._handleEOF();\n          done = true;\n          break;\n\n        case STATE_TEXT:\n          this._handleText();\n          break;\n\n        case STATE_TEXT_BREAK:\n          this._handleTextBreak();\n          done = true;\n          break;\n\n        case STATE_TAG:\n          this._handleTag();\n          break;\n      }\n\n      if (matched && !this._error) {\n        this._markTokenEndLocation();\n        matched = false;\n      }\n\n      if (this._state === STATE_NONE) {\n        if (this._char === null) {\n          this._state = STATE_EOF;\n        } else if (this._char === \"\\n\") {\n          this._state = STATE_TEXT_BREAK;\n        } else if (this._isDelimiter(DELIMITER_LEFT)) {\n          this._state = STATE_TAG;\n        } else {\n          this._state = STATE_TEXT;\n        }\n      }\n    } while (!done);\n\n    return this._error === null ? this._tokens.shift() : null;\n  }\n\n  // Handlers\n\n  _handleEOF() {\n    this._handleStandaloneTag();\n    this._makeToken({\n      type: TokenType.EOF\n    });\n  }\n\n  _handleTag() {\n    const [left, right] = this._delimiters;\n    this._skip(left.length);\n    this._skipAllWhitespaces();\n\n    if (this._char === null) {\n      this._setError(\"Unclosed tag.\");\n    } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n      this._handleEmptyTag();\n    } else {\n      const tagTypeChar = this._char;\n      if (tagTypeChar === \"{\") {\n        this._handleVariableCurly();\n      } else {\n        let tagContentStart = this._index - 1;\n        //read content\n        while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n          this._read();\n        }\n\n        if (this._char === null) {\n          this._setError(\"Unclosed tag.\");\n        } else {\n          const content = this._src.slice(tagContentStart, this._index - 1);\n          switch (tagTypeChar) {\n            case \">\":\n              this._handleSimpleTag(TokenType.PARTIAL, content);\n              break;\n            case \"^\":\n              this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);\n              break;\n            case \"#\":\n              this._handleSimpleTag(TokenType.SECTION_OPEN, content);\n              break;\n            case \"/\":\n              this._handleSimpleTag(TokenType.SECTION_CLOSE, content);\n              break;\n\n            case \"!\":\n              this._handleComment(content.substr(1));\n              break;\n\n            case \"=\":\n              this._handleDelimiterChange(content);\n              break;\n            case \"&\":\n              this._handleVariable(content.substr(1), true);\n              break;\n            default:\n              this._handleVariable(content);\n              break;\n          }\n        }\n      }\n    }\n    if (this._error === null) {\n      //eat right\n      for (let i = 0; i < right.length; i++) {\n        this._read();\n      }\n    }\n\n    this._state = STATE_NONE;\n  }\n\n  _handleDelimiterChange(content) {\n    const newDelimiters = extractNewDelimiters(content);\n    if (newDelimiters === null) {\n      this._setError(\"Invalid change delimiter syntax.\");\n    } else {\n      const [left, right] = newDelimiters;\n      this._delimiters = newDelimiters;\n      this._makeToken({\n        type: TokenType.DELIMITER_CHANGE,\n        delimiters: [left, right]\n      });\n    }\n  }\n\n  _handleSimpleTag(type, content) {\n    this._makeToken({ type, name: content.substr(1).trim() });\n  }\n\n  _handleComment(content) {\n    this._makeToken({\n      type: TokenType.COMMENT,\n      content\n    });\n  }\n\n  _handleVariableCurly() {\n    this._read(); //eat '{'\n    const begin = this._index - 1;\n    const d = this._distance(\"}\");\n    if (d === -1) {\n      this._setError(\"Unclosed variable tag: missingright curly.\");\n    } else {\n      const content = this._src.slice(begin, begin + d);\n      this._skip(d + 1); //skip '}'\n      this._skipAllWhitespaces();\n      if (!this._isDelimiter(DELIMITER_RIGHT)) {\n        this._setError(\"Unclosed variable: missing right delimiter.\");\n      } else {\n        this._makeToken({\n          type: TokenType.UNESCAPED_VARIABLE,\n          name: content.trim()\n        });\n      }\n    }\n  }\n\n  _handleEmptyTag() {\n    this._makeToken({\n      type: TokenType.VARIABLE,\n      name: \"\"\n    });\n  }\n\n  _handleVariable(content, unescaped) {\n    this._makeToken({\n      type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n      name: content.trim()\n    });\n  }\n\n  _handleText() {\n    let done = false;\n    let index = this._index - 1;\n    let length = 0;\n    do {\n      const c = this._char;\n\n      if (c === null || c === \"\\n\" || this._isDelimiter(DELIMITER_LEFT)) {\n        done = true;\n      } else {\n        length++;\n      }\n\n      if (!done) {\n        this._read();\n      }\n    } while (!done);\n\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: this._src.slice(index, index + length)\n    });\n\n    this._state = STATE_NONE;\n  }\n\n  _handleTextBreak() {\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: \"\\n\"\n    });\n    this._read();\n    this._handleStandaloneTag();\n    this._state = STATE_NONE;\n  }\n\n  _handleStandaloneTag() {\n    this._tokens = trimStandaloneToken(this._tokens);\n  }\n\n  // Helpers\n  _dump(t = \"\") {\n    console.log(t + \">\" + this._src.slice(this._index - 1));\n  }\n\n  _read() {\n    if (this._index < this._src.length) {\n      if (this._char === \"\\n\") {\n        this._line++;\n        this._column = 0;\n      } else {\n        this._column++;\n      }\n\n      this._char = this._src[this._index];\n      this._index++;\n    } else {\n      this._char = null;\n    }\n  }\n\n  _peek() {\n    if (this._index < this._src.length - 1) {\n      return this._src[this._index];\n    } else {\n      return null;\n    }\n  }\n\n  _skip(n) {\n    for (let i = 0; i < n; i++) {\n      this._read();\n    }\n  }\n\n  _distance(c) {\n    for (let i = this._index; i < this._src.length; i++) {\n      if (this._src[i] === c) {\n        return i - this._index + 1;\n      }\n    }\n    return -1;\n  }\n\n  _skipAllWhitespaces() {\n    while (this._isWhitespace()) {\n      this._read();\n    }\n  }\n\n  _markTokenStartLocation() {\n    this._location.index = this._index - 1;\n    this._location.line = this._line;\n    this._location.column = this._column;\n  }\n\n  _markTokenEndLocation() {\n    const token = this._tokens[this._tokens.length - 1];\n    token.location.endIndex = this._index - 1;\n    token.location.endLine = this._line;\n    token.location.endColumn = this._column;\n  }\n\n  _isWhitespace() {\n    return /\\s/.test(this._char);\n  }\n\n  _isDelimiter(d, offset = 0) {\n    const delimiter = this._delimiters[d];\n    const pos = this._index - 1 + offset;\n    return this._src.slice(pos, pos + delimiter.length) === delimiter;\n  }\n\n  _makeToken(token) {\n    token.filename = this._filename;\n    const { index, line, column } = this._location;\n    token.location = {\n      filename: this._filename,\n      index,\n      line,\n      column\n    };\n    if (this._extensions.length) {\n      try {\n        this._extensions.forEach(ext => {\n          token = ext.transformToken(token);\n        });\n      } catch (e) {\n        this._setError(e.message);\n        return;\n      }\n    }\n    this._tokens.push(token);\n  }\n\n  _setError(message) {\n    const error = new Error(message);\n    error.filename = this._filename;\n    error.index = this._index - 1;\n    error.line = this._line;\n    error.column = this._column;\n    this._error = error;\n  }\n}\n\nconst R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  const matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tokenizer.js","// https://github.com/mustache/spec/pull/75\n\nimport { Extension, register } from \"../extension\";\nimport * as NodeType from \"../node\";\nimport * as TokenType from \"../token\";\n\nconst PARENT = \"Inheritance.PARENT\";\nconst BLOCK = \"Inheritance.BLOCK\";\nconst LEAVE_SCOPE = \"Inheritance.LEAVE_SCOPE\";\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nexport class Inheritance extends Extension {\n  constructor() {\n    super();\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  transformToken(token) {\n    const { type, name, location } = token;\n    switch (type) {\n      case TokenType.VARIABLE:\n        if (name) {\n          if (name[0] === \"<\") {\n            if (name.length === 1) {\n              throw new Error(\"Parent partial name expected\");\n            }\n            token = {\n              type: PARENT,\n              name: name.slice(1),\n              location\n            };\n          } else if (name[0] === \"$\") {\n            if (name.length === 1) {\n              throw new Error(\"Block name expected\");\n            }\n            token = {\n              type: BLOCK,\n              name: name.slice(1),\n              location\n            };\n          }\n        }\n        break;\n    }\n    return token;\n  }\n\n  handleToken(token, parserContext) {\n    let handled = false;\n    const { name, location, type } = token;\n    switch (type) {\n      case PARENT:\n        parserContext.pushParent({\n          type: PARENT,\n          name,\n          location\n        });\n        handled = true;\n        break;\n\n      case BLOCK:\n        this._pushBlock(\n          {\n            type: BLOCK,\n            content: \"\",\n            name,\n            location\n          },\n          parserContext\n        );\n        break;\n\n      case TokenType.SECTION_CLOSE:\n        const tagNode = parserContext.parentNode;\n        if (isInheritanceTagType(tagNode.type) && tagNode.name !== name) {\n          parserContext.throw(\n            `Unexpected tag close '${name}', current tag: '${tagNode.name}'`\n          );\n        }\n        if (isInheritanceTagType(tagNode.type)) {\n          if (tagNode.type === BLOCK) {\n            const content = parserContext.src.slice(\n              tagNode.location.endIndex,\n              location.index\n            );\n            tagNode.content = content;\n          }\n\n          parserContext.popParent();\n          tagNode.location.endIndex = location.endIndex;\n          tagNode.location.endLine = location.endLine;\n          parserContext.appendNode(tagNode);\n\n          //TODO move this to visit, handle whitespaces after Parent close tag.\n          const firstLine = tagNode.location.line;\n          const firstBlock = tagNode.children.find(c => c.type === BLOCK);\n          if (firstBlock && firstBlock.location.line === firstLine) {\n            for (let i = 0; i < firstBlock.children.length; i++) {\n              const blockNode = firstBlock.children[i];\n              if (\n                blockNode.type === NodeType.TEXT &&\n                /^\\s*$/.test(blockNode.text)\n              ) {\n                blockNode.text = \"\";\n              } else {\n                break;\n              }\n            }\n          }\n\n          handled = true;\n        }\n        break;\n    }\n    return handled;\n  }\n\n  handleNode(node, rendererContext) {\n    const top = rendererContext.top;\n    this._checkTop(top);\n\n    switch (node.type) {\n      case PARENT:\n        this._handleParent(node, rendererContext);\n        return true;\n\n      case BLOCK:\n        this._handleBlock(node, rendererContext);\n        return true;\n\n      case LEAVE_SCOPE:\n        this._blocks = null;\n        return true;\n    }\n  }\n\n  _pushBlock(node, parserContext) {\n    const parent = parserContext.findParentNode(\n      parent => parent.type === BLOCK && parent.name === node.name\n    );\n    if (parent) {\n      parserContext.throw(`Recursive block: '${node.name}'`);\n    }\n    parserContext.pushParent(node);\n  }\n\n  _handleParent(node, rendererContext) {\n    const { name, location } = node;\n    const top = rendererContext.top;\n\n    this._pushParent(name, top);\n\n    if (this._blocks === null) {\n      rendererContext.pushNodes([\n        {\n          type: LEAVE_SCOPE\n        }\n      ]);\n      this._blocks = {};\n    }\n\n    //find all blocks defined in parent\n    const blocks = {};\n    node.children.forEach(child => {\n      if (child.type === BLOCK) {\n        const blockName = child.name;\n        blocks[blockName] = child;\n      }\n    });\n    if (Object.keys(blocks).length) {\n      this._setDefaultBlocks(blocks);\n    }\n\n    rendererContext.pushNode({\n      type: TokenType.PARTIAL,\n      name,\n      location,\n      indent: node.indent\n    });\n  }\n\n  _handleBlock(node, rendererContext) {\n    const { name } = node;\n    const defaultBlock = this._getDefaultBlock(name);\n    if (defaultBlock) {\n      rendererContext.pushNodes(defaultBlock.children);\n    } else {\n      rendererContext.pushNodes(node.children);\n    }\n  }\n\n  _pushParent(name, top) {\n    return this._parentStack.push({\n      name,\n      blocks: {},\n      top\n    });\n  }\n\n  _checkTop(top) {\n    let pop = 0;\n    for (let i = this._parentStack.length - 1; i >= 0; i--) {\n      const frame = this._parentStack[i];\n      if (frame.top > top) {\n        pop++;\n      } else {\n        break;\n      }\n    }\n    if (pop > 0) {\n      this._parentStack = this._parentStack.slice(\n        0,\n        this._parentStack.length - pop\n      );\n    }\n  }\n\n  _popParent() {\n    return this._parentStack.pop();\n  }\n\n  _getDefaultBlock(name) {\n    for (let i = 0; i < this._parentStack.length; i++) {\n      const frame = this._parentStack[i];\n      if (name in frame.blocks) {\n        return frame.blocks[name];\n      }\n    }\n    return null;\n  }\n\n  _setDefaultBlocks(blocks) {\n    const topFrame = this._parentStack[this._parentStack.length - 1];\n    topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/extensions/inheritance.js","import * as nodeTypes from \"./node\";\nimport escapeHTML from \"escape-html\";\nimport { Parser } from \"./parser\";\nimport { walk, visit } from \"./helpers\";\nimport { instantiateAll } from \"./extension\";\n\nconst REPEATER_NODE_TYPE = \"_REPEATER\";\nconst MAX_PARTIAL_STACK = 10;\nconst MAX_LAMBDA_STACK = 255;\nconst MAX_NODE_COUNT = 3000;\n\nclass RenderContext {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n\n  get top() {\n    return this._renderer._stack.length;\n  }\n\n  get result() {\n    return this._renderer._out;\n  }\n\n  evaluate(name) {\n    return this._renderer._evaluate(name);\n  }\n\n  pushNodes(nodes) {\n    this._renderer._pushNodes(nodes);\n  }\n\n  pushNode(node) {\n    this._renderer._pushNode(node);\n  }\n\n  pushContext(ctx, sp) {\n    this._renderer._pushContext(ctx, sp);\n  }\n\n  appendText(text) {\n    this._renderer._out += text;\n  }\n\n  parse(src, opts) {\n    return this._renderer._parse(src, opts);\n  }\n\n  getParsedPartial(name) {\n    return this._renderer._getParsedPartial(name);\n  }\n\n  throw(message, location) {\n    return this._renderer._throw(message, location);\n  }\n}\n\nexport class Renderer {\n  constructor(src, opts = {}) {\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    this._filename = opts.filename;\n\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(k => {\n        this._partialCached[k] = this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = \"\";\n    this._transformNodeResult = (node, result, nodeResult) =>\n      this._extensions.reduce(\n        (r, e) => e.transformNodeResult(node, result, r),\n        nodeResult\n      );\n  }\n\n  render(context) {\n    this._out = \"\";\n    this._stack = [];\n    this._contextStack = [];\n    this._partialStack = [];\n    this._lambdaStack = [];\n\n    this._pushContext(context);\n\n    //push root nodes\n    const rootNode = this._parsed\n      ? this._src\n      : this._parse(this._src, { filename: this._filename });\n    this._stack = rootNode.children.slice(0).reverse();\n\n    let node_count = 0;\n\n    let newline = true;\n    while (this._stack.length > 0) {\n      const top = this._stack.length - 1;\n      const node = this._stack[top];\n\n      if (node.type !== nodeTypes.TEXT) {\n        node_count++;\n        if (node_count > MAX_NODE_COUNT) {\n          this._throw(\n            `Possible infinity loop detected: last node type is '${node.type}'`,\n            node.location\n          );\n        }\n      }\n\n      let handled = false;\n      if (this._extensions) {\n        this._extensions.forEach(ext => {\n          if (ext.handleNode(node, this._renderContext)) {\n            handled = true;\n          }\n        });\n      }\n\n      if (handled) {\n        this._stack.splice(top, 1);\n      } else {\n        const partial = this._partialStack.length\n          ? this._partialStack[this._partialStack.length - 1]\n          : null;\n\n        //insert indent\n        if (node.type in nodeTypes) {\n          if (newline && partial !== null && partial.indent.length > 0) {\n            this._out += partial.indent;\n          }\n        }\n\n        let value;\n        switch (node.type) {\n          case nodeTypes.VARIABLE:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              if (!!value) {\n                const result = node.unescaped ? value : escapeHTML(value);\n                this._out += this._transformNodeResult(node, this._out, result);\n              }\n              this._popNode();\n            }\n            break;\n\n          case nodeTypes.SECTION:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              let isList = Array.isArray(value);\n\n              if (isList && value.length === 0) {\n                //Empty lists should behave like falsey values.\n                value = false;\n                isList = false;\n              }\n\n              let testResult = !!value;\n              if (node.inverted) {\n                testResult = !testResult;\n              }\n\n              if (testResult) {\n                if (isList) {\n                  this._popNode();\n                  this._pushRepeaterNode(value.length, node.children, value);\n                } else {\n                  this._popNode();\n                  this._pushContext(value);\n                  this._pushNodes(node.children);\n                }\n              } else {\n                this._popNode();\n              }\n            }\n            break;\n\n          case nodeTypes.TEXT:\n            this._out += this._transformNodeResult(node, this._out, node.text);\n            this._popNode();\n            break;\n\n          case nodeTypes.COMMENT:\n            this._popNode();\n            break;\n\n          case nodeTypes.PARTIAL:\n            this._popNode();\n            this._expandPartial(node);\n            break;\n\n          case nodeTypes.DELIMITER_CHANGE:\n            this._popNode();\n            this._delimiters = node.delimiters.slice(0);\n            break;\n\n          case REPEATER_NODE_TYPE:\n            if (node.count < node.repeat) {\n              const repeatIndex = node.count;\n              if (repeatIndex === 0) {\n                node.contextIndex = this._pushContext(node.contexts[0]);\n              } else {\n                this._replaceContextAt(\n                  node.contextIndex,\n                  node.contexts[repeatIndex]\n                );\n              }\n              this._pushNodes(node.children);\n              node.count++;\n            } else {\n              this._popNode();\n            }\n            break;\n\n          default:\n            this._popNode();\n            break;\n        }\n      }\n      this._checkStacks();\n      newline =\n        this._out.length === 0 || this._out[this._out.length - 1] === \"\\n\";\n    }\n\n    return this._extensions.reduce(\n      (result, ext) => ext.transformResult(result),\n      this._out\n    );\n  }\n\n  _parse(src, opts = {}) {\n    opts.extensions = this._extensions;\n    const parser = new Parser(opts);\n    return parser.parse(src);\n  }\n\n  _pushNodes(list) {\n    for (let i = list.length - 1; i >= 0; i--) {\n      this._stack.push(list[i]);\n    }\n  }\n\n  _pushNode(node) {\n    this._stack.push(node);\n  }\n\n  _popNode() {\n    this._stack.pop();\n  }\n\n  _pushRepeaterNode(repeat, nodes, contexts) {\n    this._stack.push({\n      type: REPEATER_NODE_TYPE,\n      count: 0,\n      repeat,\n      children: nodes.slice(0),\n      contexts\n    });\n  }\n\n  _pushContext(context, sp = this._stack.length) {\n    if (this._contextStack.length) {\n      sp = Math.min(\n        Math.max(this._contextStack[this._contextStack.length - 1].sp, sp),\n        this._stack.length\n      );\n    }\n    return (\n      this._contextStack.push({\n        context,\n        sp\n      }) - 1\n    );\n  }\n\n  _replaceContextAt(index, context) {\n    if (index < 0 || index > this._contextStack.length - 1) {\n      throw new RangeError(\"Huz context index out of range.\");\n    }\n    this._contextStack[index].context = context;\n  }\n\n  _pushPartial({ name, indent, location }) {\n    this._partialStack.push({\n      name,\n      indent: indent || \"\",\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _pushLambda({ name, location }) {\n    this._lambdaStack.push({\n      name,\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _checkStacks() {\n    while (\n      this._stack.length < this._contextStack[this._contextStack.length - 1].sp\n    ) {\n      this._contextStack.pop();\n    }\n\n    if (\n      this._partialStack.length > 0 &&\n      this._stack.length ===\n        this._partialStack[this._partialStack.length - 1].sp\n    ) {\n      this._partialStack.pop();\n    }\n\n    if (\n      this._lambdaStack.length > 0 &&\n      this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp\n    ) {\n      this._lambdaStack.pop();\n    }\n  }\n\n  _evaluate(name) {\n    if (name === \".\") {\n      return this._contextStack[this._contextStack.length - 1].context;\n    }\n\n    const path = name.split(\".\");\n    for (let i = this._contextStack.length - 1; i >= 0; i--) {\n      const context = this._contextStack[i].context;\n      if (context === null || typeof context !== \"object\") {\n        continue;\n      }\n\n      let current = context;\n      let resolved = true;\n      for (let pi = 0; pi < path.length; pi++) {\n        const key = path[pi];\n        if (\n          typeof current === \"object\" &&\n          current !== null &&\n          current.hasOwnProperty(key)\n        ) {\n          current = current[key];\n        } else {\n          resolved = false;\n          break;\n        }\n      }\n\n      if (resolved) {\n        return current;\n      }\n    }\n    return \"\";\n  }\n\n  _getParsedPartial(name) {\n    if (this._partialCached.hasOwnProperty(name)) {\n      return this._partialCached[name];\n    } else {\n      if (!this._partials.hasOwnProperty(name)) {\n        return null;\n      }\n      const ast = this._parse(this._partials[name], { filename: name });\n      const nodes = (this._partialCached[name] = ast.children);\n      return nodes;\n    }\n  }\n\n  _expandPartial(node) {\n    const { name } = node;\n    const nodes = this._getParsedPartial(name);\n\n    if (nodes === null) {\n      //The empty string should be used when the named partial is not found.\n      return;\n    }\n\n    this._pushPartial(node);\n\n    if (this._partialStack.length > MAX_PARTIAL_STACK) {\n      this._throw(\n        \"Possible partial short circuit: \" +\n          this._partialStack\n            .map(f => `${f.name}@${f.location.filename}:${f.location.line + 1}`)\n            .concat([name])\n            .join(\" -> \"),\n        node.location\n      );\n    }\n\n    this._pushNodes(nodes);\n  }\n\n  _expandLambda(node, lambda) {\n    const { name } = node;\n\n    this._pushLambda(node);\n\n    if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n      this._throw(\n        \"Possible lambda short circuit: \" +\n          this._lambdaStack\n            .map(f => `${f.name}@${f.location.filename}:${f.location.line + 1}`)\n            .concat([name])\n            .join(\" -> \"),\n        node.location\n      );\n    }\n\n    let ast;\n    let skipped = false;\n    if (node.type === nodeTypes.VARIABLE) {\n      const code = lambda();\n      if (code) {\n        //A lambda's return value should parse with the default delimiters.\n        ast = this._parse(\"\" + code, { filename: \"[lambda]\" });\n        if (!node.unescaped) {\n          //Lambda results should be appropriately escaped.\n          walk(ast, node => {\n            if (node.type === nodeTypes.TEXT) {\n              node.text = escapeHTML(node.text);\n            }\n          });\n        }\n      } else {\n        skipped = true;\n      }\n    } else if (node.type === nodeTypes.SECTION) {\n      const code = lambda(node.raw);\n      if (code) {\n        //Lambdas used for inverted sections should be considered truthy.\n        //Lambdas used for sections should parse with the current delimiters.\n        ast = this._parse(\"\" + code, {\n          filename: \"[#lambda]\",\n          delimiters: this._delimiters.slice(0)\n        });\n      } else {\n        skipped = true;\n      }\n    }\n\n    if (!skipped) {\n      this._pushNodes(ast.children);\n    }\n  }\n\n  _throw(message, location) {\n    const e = new Error(message);\n    e.filename = location.filename;\n    e.location = location;\n    throw e;\n  }\n}\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == \"[object Function]\";\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderer.js","import { Parser } from \"./parser\";\nimport { Renderer } from \"./renderer\";\nimport * as TokenType from \"./token\";\nimport * as NodeType from \"./node\";\nimport * as Helpers from \"./helpers\";\nimport { register } from \"./extension\";\n\nexport { Tokenizer } from \"./tokenizer\";\nexport { Parser, Renderer, TokenType, NodeType };\n\nexport { Extension } from \"./extension\";\nimport { Inheritance } from \"./extensions/inheritance\";\n// import { Section } from \"./extensions/section\";\n\nregister(Inheritance);\n// register(Section);\n\nexport function parse(src, opts) {\n  const parser = new Parser(opts);\n  return parser.parse(src);\n}\n\nexport function compile(src, opts) {\n  return new Renderer(src, opts);\n}\n\nexport function render(src, context, opts) {\n  const r = compile(src, opts);\n  return r.render(context);\n}\n\nexport { register, Helpers };\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/escape-html/index.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}