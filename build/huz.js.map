{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///huz.js","webpack:///webpack/bootstrap 2b98fc9fd9c46b7daf18","webpack:///./src/index.js","webpack:///./src/extension.js","webpack:///./src/helpers.js","webpack:///./src/token.js","webpack:///./src/node.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js","webpack:///./src/extensions/inheritance.js","webpack:///./src/renderer.js","webpack:///./~/escape-html/index.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","parse","src","opts","parser","_parser","Parser","compile","_renderer","Renderer","render","context","r","defineProperty","value","_token","TokenType","_node","NodeType","_helpers","Helpers","_extension","_extensionsInheritance","_tokenizer","enumerable","get","Tokenizer","register","Inheritance","_classCallCheck","instance","Constructor","TypeError","instantiateAll","registry","map","ctor","constructor","push","_createClass","defineProperties","target","props","length","descriptor","configurable","writable","protoProps","staticProps","Extension","token","parserContext","node","renderContext","walk","modifier","stack","children","slice","reverse","pop","undefined","concat","visit","visitor","_parent","child","modified","trimStandaloneToken","tokens","count","open","inline","standalone","indentTokens","type","VARIABLE","UNESCAPED_VARIABLE","TEXT","isStringWhitespace","text","DELIMITER_CHANGE","COMMENT","SECTION_CLOSE","name","tailWSNodeCount","indent","forEach","t","str","test","EOF","PARTIAL","INVERTED_SECTION_OPEN","SECTION_OPEN","ROOT","SECTION","ParserContext","_appendNode","_pushParent","_popParent","message","_throw","_filename","_stack","arguments","_delimiters","delimiters","_extensions","extensions","filename","_parserContext","_lastToken","_src","rootNode","_parseNodes","location","JSON","stringify","beginLocation","endLocation","_clone","endIndex","endLine","initialStackSize","z","getNextToken","error","handled","ext","handleToken","_makeLocation","unescaped","_handleSectionOpen","_handleSectionClose","_handleComment","n","join","e","Error","inverted","section","raw","index","content","extractNewDelimiters","tagContent","matches","match","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","Array","isArray","STATE_NONE","STATE_EOF","STATE_TEXT","STATE_TEXT_BREAK","STATE_TAG","DELIMITER_LEFT","DELIMITER_RIGHT","_index","_char","_tokens","_line","_column","_state","_error","_location","line","column","shift","matched","_markTokenStartLocation","_read","_handleEOF","_handleText","_handleTextBreak","_handleTag","_markTokenEndLocation","_isDelimiter","_handleStandaloneTag","_makeToken","left","right","_skip","_skipAllWhitespaces","_setError","_handleEmptyTag","tagTypeChar","_handleVariableCurly","tagContentStart","_handleSimpleTag","substr","_handleDelimiterChange","_handleVariable","newDelimiters","_newDelimiters","trim","begin","d","_distance","console","log","_isWhitespace","endColumn","offset","delimiter","pos","transformToken","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","isInheritanceTagType","PARENT","BLOCK","_get","_x","_x2","_x3","_again","object","property","receiver","desc","parent","getter","Function","getOwnPropertyDescriptor","getPrototypeOf","_token2","LEAVE_SCOPE","_Extension","_blocks","pushParent","tagNode","tailNode","popParent","appendNode","firstLine","firstBlock","find","blockNode","top","f","rendererContext","_handleParent","_handleBlock","_this","pushNodes","blockName","pushNode","_interopRequireDefault","default","isFunction","x","toString","nodeTypes","_escapeHtml","_escapeHtml2","REPEATER_NODE_TYPE","MAX_PARTIAL_STACK","MAX_LAMBDA_STACK","RenderContext","renderer","_evaluate","nodes","_pushNodes","_pushNode","ctx","_pushContext","_parse","_getParsedPartial","_parsed","parsed","_partials","partials","_renderContext","_partialCached","keys","k","_contextStack","_partialStack","_lambdaStack","_this2","out","newline","_loop","handleNode","splice","partial","_popNode","_expandLambda","isList","testResult","_pushRepeaterNode","_expandPartial","repeat","repeatIndex","contexts","_replaceTopContext","_checkStacks","list","sp","_ref","_ref2","path","split","current","resolved","pi","ast","_pushPartial","lambda","_pushLambda","skipped","code","escapeHtml","string","matchHtmlRegExp","exec","escape","html","lastIndex","charCodeAt","substring"],"mappings":"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","file":"huz.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.parse = parse;\n\texports.compile = compile;\n\texports.render = render;\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tvar _parser = __webpack_require__(5);\n\t\n\tvar _renderer = __webpack_require__(8);\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar Helpers = _interopRequireWildcard(_helpers);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _extensionsInheritance = __webpack_require__(7);\n\t\n\tvar _tokenizer = __webpack_require__(6);\n\t\n\tObject.defineProperty(exports, 'Tokenizer', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _tokenizer.Tokenizer;\n\t  }\n\t});\n\texports.Parser = _parser.Parser;\n\texports.Renderer = _renderer.Renderer;\n\texports.TokenType = TokenType;\n\texports.NodeType = NodeType;\n\t\n\t(0, _extension.register)(_extensionsInheritance.Inheritance);\n\t\n\tfunction parse(src, opts) {\n\t  var parser = new _parser.Parser(opts);\n\t  return parser.parse(src);\n\t}\n\t\n\tfunction compile(src, opts) {\n\t  return new _renderer.Renderer(src, opts);\n\t}\n\t\n\tfunction render(src, context, opts) {\n\t  var r = compile(src, opts);\n\t  return r.render(context);\n\t}\n\t\n\texports.register = _extension.register;\n\texports.Helpers = Helpers;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\texports.instantiateAll = instantiateAll;\n\texports.register = register;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar registry = [];\n\t\n\tvar Extension = (function () {\n\t  function Extension() {\n\t    _classCallCheck(this, Extension);\n\t  }\n\t\n\t  _createClass(Extension, [{\n\t    key: \"transformToken\",\n\t\n\t    //called by tokenizer\n\t    value: function transformToken(token) {\n\t      return token;\n\t    }\n\t\n\t    //called by parser\n\t  }, {\n\t    key: \"handleToken\",\n\t    value: function handleToken(token, parserContext) {}\n\t  }, {\n\t    key: \"visit\",\n\t    value: function visit(root) {\n\t      return root;\n\t    }\n\t\n\t    //called by renderer\n\t  }, {\n\t    key: \"handleNode\",\n\t    value: function handleNode(node, renderContext) {}\n\t  }]);\n\t\n\t  return Extension;\n\t})();\n\t\n\texports.Extension = Extension;\n\t\n\tfunction instantiateAll(opts) {\n\t  return registry.map(function (ctor) {\n\t    return new ctor(opts);\n\t  });\n\t}\n\t\n\tfunction register(constructor) {\n\t  return registry.push(constructor);\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports.walk = walk;\n\texports.visit = visit;\n\texports.trimStandaloneToken = trimStandaloneToken;\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tfunction walk(root, modifier) {\n\t  var stack = root.children.slice(0).reverse();\n\t  while (stack.length) {\n\t    var node = stack.pop();\n\t    modifier(node);\n\t    if (node.children !== undefined) {\n\t      stack = stack.concat(node.children.slice(0).reverse());\n\t    }\n\t  }\n\t}\n\t\n\tfunction visit(root, visitor) {\n\t  var stack = [root];\n\t  while (stack.length) {\n\t    var _parent = stack.pop();\n\t    for (var i = 0; i < _parent.children.length; i++) {\n\t      var child = _parent.children[i];\n\t      var modified = visitor.visit(child) || child;\n\t      if (modified !== child) {\n\t        _parent.children[i] = modified;\n\t      }\n\t      if (child.children && child.children.length) {\n\t        stack.push(child);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction trimStandaloneToken(tokens) {\n\t  var count = tokens.length;\n\t\n\t  if (count === 0) {\n\t    return tokens;\n\t  }\n\t\n\t  var open = null;\n\t  var inline = 0;\n\t  var standalone = true;\n\t  var indentTokens = [];\n\t  for (var i = 0; standalone && i < count; i++) {\n\t    var token = tokens[i];\n\t    switch (token.type) {\n\t      case TokenType.VARIABLE:\n\t      case TokenType.UNESCAPED_VARIABLE:\n\t        standalone = false;\n\t        break;\n\t      case TokenType.TEXT:\n\t        if (isStringWhitespace(token.text)) {\n\t          if (inline === 0) {\n\t            indentTokens.push(token);\n\t          }\n\t        } else {\n\t          standalone = false;\n\t        }\n\t        break;\n\t      case TokenType.DELIMITER_CHANGE:\n\t      case TokenType.COMMENT:\n\t        if (open !== null) {\n\t          open.push(token);\n\t        } else {\n\t          inline++;\n\t        }\n\t        break;\n\t      case TokenType.SECTION_CLOSE:\n\t        if (open) {\n\t          if (open[0].name === token.name) {\n\t            open = null;\n\t          } else {\n\t            standalone = false;\n\t          }\n\t        } else {\n\t          inline++;\n\t        }\n\t        break;\n\t      default:\n\t        //section-like tags\n\t        if (open === null) {\n\t          open = [token];\n\t          inline++;\n\t        } else {\n\t          standalone = false;\n\t        }\n\t        break;\n\t    }\n\t\n\t    if (inline > 1) {\n\t      standalone = false;\n\t    }\n\t  }\n\t\n\t  if (open && open.length > 1) {\n\t    standalone = false;\n\t  }\n\t\n\t  if (standalone) {\n\t    //all whitespace\n\t    if (indentTokens.length === count) {\n\t      return tokens;\n\t    }\n\t\n\t    var tailWSNodeCount = 0;\n\t    for (var i = count - 1; i >= 0; i--) {\n\t      var token = tokens[i];\n\t      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n\t        tailWSNodeCount++;\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n\t      //trim\n\t      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n\t      if (indentTokens.length) {\n\t        var indent = '';\n\t        indentTokens.forEach(function (t) {\n\t          indent += t.text;\n\t        });\n\t        tokens[0].indent = indent;\n\t      }\n\t    }\n\t  }\n\t  return tokens;\n\t}\n\t\n\tfunction isStringWhitespace(str) {\n\t  return (/^\\s*$/.test(str)\n\t  );\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar EOF = 'EOF';\n\texports.EOF = EOF;\n\tvar TEXT = 'TEXT';\n\texports.TEXT = TEXT;\n\tvar PARTIAL = 'PARTIAL';\n\texports.PARTIAL = PARTIAL;\n\tvar INVERTED_SECTION_OPEN = 'INVERTED_SECTION_OPEN';\n\texports.INVERTED_SECTION_OPEN = INVERTED_SECTION_OPEN;\n\tvar SECTION_OPEN = 'SECTION_OPEN';\n\texports.SECTION_OPEN = SECTION_OPEN;\n\tvar SECTION_CLOSE = 'SECTION_CLOSE';\n\texports.SECTION_CLOSE = SECTION_CLOSE;\n\tvar UNESCAPED_VARIABLE = 'UNESCAPED_VARIABLE';\n\texports.UNESCAPED_VARIABLE = UNESCAPED_VARIABLE;\n\tvar COMMENT = 'COMMENT';\n\texports.COMMENT = COMMENT;\n\tvar VARIABLE = 'VARIABLE';\n\texports.VARIABLE = VARIABLE;\n\tvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\texports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\tvar ROOT = 'ROOT';\n\texports.ROOT = ROOT;\n\tvar VARIABLE = 'VARIABLE';\n\texports.VARIABLE = VARIABLE;\n\tvar SECTION = 'SECTION';\n\texports.SECTION = SECTION;\n\tvar TEXT = 'TEXT';\n\texports.TEXT = TEXT;\n\tvar COMMENT = 'COMMENT';\n\texports.COMMENT = COMMENT;\n\tvar PARTIAL = 'PARTIAL';\n\texports.PARTIAL = PARTIAL;\n\tvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\texports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _tokenizer = __webpack_require__(6);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar ParserContext = (function () {\n\t  function ParserContext(parser) {\n\t    _classCallCheck(this, ParserContext);\n\t\n\t    this._parser = parser;\n\t  }\n\t\n\t  _createClass(ParserContext, [{\n\t    key: 'appendNode',\n\t    value: function appendNode(node) {\n\t      this._parser._appendNode(node);\n\t    }\n\t  }, {\n\t    key: 'pushParent',\n\t    value: function pushParent(node) {\n\t      this._parser._pushParent(node);\n\t    }\n\t  }, {\n\t    key: 'popParent',\n\t    value: function popParent() {\n\t      return this._parser._popParent();\n\t    }\n\t  }, {\n\t    key: 'throw',\n\t    value: function _throw(message) {\n\t      return this._parser._throw(message);\n\t    }\n\t  }, {\n\t    key: 'filename',\n\t    get: function get() {\n\t      return this._parser._filename;\n\t    }\n\t  }, {\n\t    key: 'top',\n\t    get: function get() {\n\t      return this._parser._stack.length;\n\t    }\n\t  }, {\n\t    key: 'tailNode',\n\t    get: function get() {\n\t      return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n\t    }\n\t  }]);\n\t\n\t  return ParserContext;\n\t})();\n\t\n\tvar Parser = (function () {\n\t  function Parser() {\n\t    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t    _classCallCheck(this, Parser);\n\t\n\t    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n\t    this._filename = opts.filename || '';\n\t\n\t    if (this._extensions.length > 0) {\n\t      this._parserContext = new ParserContext(this);\n\t    }\n\t\n\t    this._stack = null;\n\t    this._lastToken = null;\n\t    this._src = null;\n\t  }\n\t\n\t  _createClass(Parser, [{\n\t    key: 'parse',\n\t    value: function parse(src) {\n\t      var rootNode = {\n\t        type: NodeType.ROOT,\n\t        children: []\n\t      };\n\t      this._src = src;\n\t      this._stack = [rootNode];\n\t      this._lastToken = null;\n\t      this._parseNodes(src);\n\t\n\t      if (this._extensions.length > 0) {\n\t        for (var i = 0; i < this._extensions.length; i++) {\n\t          this._extensions[i].visit(rootNode);\n\t        }\n\t      }\n\t\n\t      return rootNode;\n\t    }\n\t  }, {\n\t    key: '_appendNode',\n\t    value: function _appendNode(node) {\n\t      node.location.filename = this._filename;\n\t      this._stack[this._stack.length - 1].children.push(node);\n\t      return node;\n\t    }\n\t  }, {\n\t    key: '_getTop',\n\t    value: function _getTop() {\n\t      return this._stack[this._stack.length - 1];\n\t    }\n\t  }, {\n\t    key: '_clone',\n\t    value: function _clone(obj) {\n\t      return JSON.parse(JSON.stringify(obj));\n\t    }\n\t  }, {\n\t    key: '_makeLocation',\n\t    value: function _makeLocation(beginLocation, endLocation) {\n\t      var location = this._clone(beginLocation);\n\t      if (endLocation) {\n\t        location.endIndex = endLocation.endIndex;\n\t        location.endLine = endLocation.endLine;\n\t      }\n\t      return location;\n\t    }\n\t  }, {\n\t    key: '_parseNodes',\n\t    value: function _parseNodes(src) {\n\t      var initialStackSize = this._stack.length;\n\t      var token = undefined;\n\t      var z = new _tokenizer.Tokenizer(src, {\n\t        delimiters: this._delimiters.slice(0),\n\t        extensions: this._extensions\n\t      });\n\t\n\t      do {\n\t        token = z.getNextToken();\n\t\n\t        if (z.error !== null) {\n\t          throw z.error;\n\t        }\n\t\n\t        this._lastToken = token;\n\t\n\t        var handled = false;\n\t        if (this._extensions) {\n\t          for (var i = 0; i < this._extensions.length; i++) {\n\t            var ext = this._extensions[i];\n\t            if (ext.handleToken(token, this._parserContext) === true) {\n\t              handled = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (!handled) {\n\t          switch (token.type) {\n\t            case TokenType.TEXT:\n\t              this._appendNode({\n\t                type: NodeType.TEXT,\n\t                text: token.text,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.VARIABLE:\n\t            case TokenType.UNESCAPED_VARIABLE:\n\t              this._appendNode({\n\t                type: NodeType.VARIABLE,\n\t                name: token.name,\n\t                unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.SECTION_OPEN:\n\t              this._handleSectionOpen(token);\n\t              break;\n\t\n\t            case TokenType.INVERTED_SECTION_OPEN:\n\t              this._handleSectionOpen(token, true);\n\t              break;\n\t\n\t            case TokenType.SECTION_CLOSE:\n\t              this._handleSectionClose(token);\n\t              break;\n\t\n\t            case TokenType.PARTIAL:\n\t              this._appendNode({\n\t                type: NodeType.PARTIAL,\n\t                name: token.name,\n\t                indent: token.indent,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t\n\t            case TokenType.COMMENT:\n\t              this._handleComment(token);\n\t              break;\n\t\n\t            case TokenType.DELIMITER_CHANGE:\n\t              this._appendNode({\n\t                type: NodeType.DELIMITER_CHANGE,\n\t                delimiters: token.delimiters,\n\t                location: this._makeLocation(token.location)\n\t              });\n\t              break;\n\t          }\n\t        }\n\t      } while (token.type !== TokenType.EOF);\n\t\n\t      if (this._stack.length > initialStackSize) {\n\t        this._throw('Unexpected EOF: sections not closed: ' + this._stack.slice(initialStackSize).map(function (n) {\n\t          return '\\'' + n.name + '\\'';\n\t        }).join(', '));\n\t      } else if (this._stack.length < initialStackSize) {\n\t        this._throw('Internal error.');\n\t      }\n\t    }\n\t  }, {\n\t    key: '_throw',\n\t    value: function _throw(message) {\n\t      var e = new Error(message);\n\t      e.location = this._lastToken.location;\n\t      throw e;\n\t    }\n\t  }, {\n\t    key: '_pushParent',\n\t    value: function _pushParent(node) {\n\t      node.children = [];\n\t      this._stack.push(node);\n\t    }\n\t  }, {\n\t    key: '_popParent',\n\t    value: function _popParent() {\n\t      return this._stack.pop();\n\t    }\n\t  }, {\n\t    key: '_handleSectionOpen',\n\t    value: function _handleSectionOpen(token) {\n\t      var inverted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t      var name = token.name;\n\t      var location = token.location;\n\t\n\t      this._pushParent({\n\t        type: NodeType.SECTION,\n\t        name: name,\n\t        inverted: inverted,\n\t        location: location\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleSectionClose',\n\t    value: function _handleSectionClose(token) {\n\t      var name = token.name;\n\t      var location = token.location;\n\t\n\t      var section = this._popParent();\n\t      if (section.type !== NodeType.SECTION) {\n\t        this._throw('Unexpected SECTION_CLOSE: \\'' + name + '\\'');\n\t      }\n\t\n\t      if (section.name !== name) {\n\t        this._throw('Unexpected SECTION_CLOSE: \\'' + name + '\\', current section: \\'' + section.name + '\\'');\n\t      }\n\t\n\t      section.raw = this._src.slice(section.location.endIndex, location.index);\n\t      section.location = this._makeLocation(section.location, token.location);\n\t\n\t      this._appendNode(section);\n\t    }\n\t  }, {\n\t    key: '_handleComment',\n\t    value: function _handleComment(token) {\n\t      var content = token.content;\n\t      var location = token.location;\n\t\n\t      this._appendNode({\n\t        type: NodeType.COMMENT,\n\t        content: content,\n\t        location: this._makeLocation(location)\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Parser;\n\t})();\n\n\texports.Parser = Parser;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _token = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar STATE_NONE = 'STATE_NONE';\n\tvar STATE_EOF = 'STATE_EOF';\n\tvar STATE_TEXT = 'STATE_TEXT';\n\tvar STATE_TEXT_BREAK = 'STATE_TEXT_BREAK';\n\tvar STATE_TAG = 'STATE_TAG';\n\t\n\tvar DELIMITER_LEFT = 0;\n\tvar DELIMITER_RIGHT = 1;\n\t\n\tvar Tokenizer = (function () {\n\t  function Tokenizer(src) {\n\t    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Tokenizer);\n\t\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n\t    this._src = src;\n\t    this._index = 0;\n\t    this._char = null;\n\t    this._tokens = [];\n\t    this._line = 0;\n\t    this._column = 0;\n\t    this._state = STATE_NONE;\n\t    this._error = null;\n\t    this._location = {\n\t      index: 0,\n\t      line: 0,\n\t      column: 0\n\t    };\n\t    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n\t  }\n\t\n\t  _createClass(Tokenizer, [{\n\t    key: 'getNextToken',\n\t    value: function getNextToken() {\n\t      if (this._tokens.length > 0) {\n\t        return this._tokens.shift();\n\t      }\n\t\n\t      var done = false;\n\t      var matched = false;\n\t      do {\n\t        //console.log(this._state, this._tokens);\n\t        if (this._error !== null) {\n\t          return null;\n\t        }\n\t\n\t        if (this._state !== STATE_NONE) {\n\t          matched = true;\n\t          this._markTokenStartLocation();\n\t        }\n\t\n\t        switch (this._state) {\n\t          case STATE_NONE:\n\t            this._read();\n\t            break;\n\t\n\t          case STATE_EOF:\n\t            this._handleEOF();\n\t            done = true;\n\t            break;\n\t\n\t          case STATE_TEXT:\n\t            this._handleText();\n\t            break;\n\t\n\t          case STATE_TEXT_BREAK:\n\t            this._handleTextBreak();\n\t            done = true;\n\t            break;\n\t\n\t          case STATE_TAG:\n\t            this._handleTag();\n\t            break;\n\t        }\n\t\n\t        if (matched) {\n\t          this._markTokenEndLocation();\n\t          matched = false;\n\t        }\n\t\n\t        if (this._state === STATE_NONE) {\n\t          if (this._char === null) {\n\t            this._state = STATE_EOF;\n\t          } else if (this._char === '\\n') {\n\t            this._state = STATE_TEXT_BREAK;\n\t          } else if (this._isDelimiter(DELIMITER_LEFT)) {\n\t            this._state = STATE_TAG;\n\t          } else {\n\t            this._state = STATE_TEXT;\n\t          }\n\t        }\n\t      } while (!done);\n\t\n\t      return this._error === null ? this._tokens.shift() : null;\n\t    }\n\t\n\t    // Handlers\n\t\n\t  }, {\n\t    key: '_handleEOF',\n\t    value: function _handleEOF() {\n\t      this._handleStandaloneTag();\n\t      this._makeToken({\n\t        type: TokenType.EOF\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleTag',\n\t    value: function _handleTag() {\n\t      var _delimiters = _slicedToArray(this._delimiters, 2);\n\t\n\t      var left = _delimiters[0];\n\t      var right = _delimiters[1];\n\t\n\t      this._skip(left.length);\n\t      this._skipAllWhitespaces();\n\t\n\t      if (this._char === null) {\n\t        this._setError('Unclosed tag.');\n\t      } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n\t        this._handleEmptyTag();\n\t      } else {\n\t        var tagTypeChar = this._char;\n\t        if (tagTypeChar === '{') {\n\t          this._handleVariableCurly();\n\t        } else {\n\t          var tagContentStart = this._index - 1;\n\t          //read content\n\t          while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n\t            this._read();\n\t          }\n\t\n\t          if (this._char === null) {\n\t            this._setError('Unclosed tag.');\n\t          } else {\n\t            var content = this._src.slice(tagContentStart, this._index - 1);\n\t            switch (tagTypeChar) {\n\t              case '>':\n\t                this._handleSimpleTag(TokenType.PARTIAL, content);break;\n\t              case '^':\n\t                this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);break;\n\t              case '#':\n\t                this._handleSimpleTag(TokenType.SECTION_OPEN, content);break;\n\t              case '/':\n\t                this._handleSimpleTag(TokenType.SECTION_CLOSE, content);break;\n\t\n\t              case '!':\n\t                this._handleComment(content.substr(1));\n\t                break;\n\t\n\t              case '=':\n\t                this._handleDelimiterChange(content);\n\t                break;\n\t              case '&':\n\t                this._handleVariable(content.substr(1), true);\n\t                break;\n\t              default:\n\t                this._handleVariable(content);\n\t                break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      if (this._error === null) {\n\t        //eat right\n\t        for (var i = 0; i < right.length; i++) {\n\t          this._read();\n\t        }\n\t      }\n\t\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleDelimiterChange',\n\t    value: function _handleDelimiterChange(content) {\n\t      var newDelimiters = extractNewDelimiters(content);\n\t      if (newDelimiters === null) {\n\t        this._setError('Invalid change delimiter syntax.');\n\t      } else {\n\t        var _newDelimiters = _slicedToArray(newDelimiters, 2);\n\t\n\t        var left = _newDelimiters[0];\n\t        var right = _newDelimiters[1];\n\t\n\t        this._delimiters = newDelimiters;\n\t        this._makeToken({\n\t          type: TokenType.DELIMITER_CHANGE,\n\t          delimiters: [left, right]\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleSimpleTag',\n\t    value: function _handleSimpleTag(type, content) {\n\t      this._makeToken({ type: type, name: content.substr(1).trim() });\n\t    }\n\t  }, {\n\t    key: '_handleComment',\n\t    value: function _handleComment(content) {\n\t      this._makeToken({\n\t        type: TokenType.COMMENT,\n\t        content: content\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleVariableCurly',\n\t    value: function _handleVariableCurly() {\n\t      this._read(); //eat '{'\n\t      var begin = this._index - 1;\n\t      var d = this._distance('}');\n\t      if (d === -1) {\n\t        this._setError('Unclosed variable tag: missingright curly.');\n\t      } else {\n\t        var content = this._src.slice(begin, begin + d);\n\t        this._skip(d + 1); //skip '}'\n\t        this._skipAllWhitespaces();\n\t        if (!this._isDelimiter(DELIMITER_RIGHT)) {\n\t          this._setError('Unclosed variable: missing right delimiter.');\n\t        } else {\n\t          this._makeToken({\n\t            type: TokenType.UNESCAPED_VARIABLE,\n\t            name: content.trim()\n\t          });\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleEmptyTag',\n\t    value: function _handleEmptyTag() {\n\t      this._makeToken({\n\t        type: TokenType.VARIABLE,\n\t        name: ''\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleVariable',\n\t    value: function _handleVariable(content, unescaped) {\n\t      this._makeToken({\n\t        type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n\t        name: content.trim()\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleText',\n\t    value: function _handleText() {\n\t      var done = false;\n\t      var index = this._index - 1;\n\t      var length = 0;\n\t      do {\n\t        var c = this._char;\n\t\n\t        if (c === null || c === '\\n' || this._isDelimiter(DELIMITER_LEFT)) {\n\t          done = true;\n\t        } else {\n\t          length++;\n\t        }\n\t\n\t        if (!done) {\n\t          this._read();\n\t        }\n\t      } while (!done);\n\t\n\t      this._makeToken({\n\t        type: TokenType.TEXT,\n\t        text: this._src.slice(index, index + length)\n\t      });\n\t\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleTextBreak',\n\t    value: function _handleTextBreak() {\n\t      this._makeToken({\n\t        type: TokenType.TEXT,\n\t        text: '\\n'\n\t      });\n\t      this._read();\n\t      this._handleStandaloneTag();\n\t      this._state = STATE_NONE;\n\t    }\n\t  }, {\n\t    key: '_handleStandaloneTag',\n\t    value: function _handleStandaloneTag() {\n\t      this._tokens = (0, _helpers.trimStandaloneToken)(this._tokens);\n\t    }\n\t\n\t    // Helpers\n\t  }, {\n\t    key: '_dump',\n\t    value: function _dump() {\n\t      var t = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\t\n\t      console.log(t + '>' + this._src.slice(this._index - 1));\n\t    }\n\t  }, {\n\t    key: '_read',\n\t    value: function _read() {\n\t      if (this._index < this._src.length) {\n\t        if (this._char === '\\n') {\n\t          this._line++;\n\t          this._column = 0;\n\t        } else {\n\t          this._column++;\n\t        }\n\t\n\t        this._char = this._src[this._index];\n\t        this._index++;\n\t      } else {\n\t        this._char = null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_peek',\n\t    value: function _peek() {\n\t      if (this._index < this._src.length - 1) {\n\t        return this._src[this._index];\n\t      } else {\n\t        return null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_skip',\n\t    value: function _skip(n) {\n\t      for (var i = 0; i < n; i++) {\n\t        this._read();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_distance',\n\t    value: function _distance(c) {\n\t      for (var i = this._index; i < this._src.length; i++) {\n\t        if (this._src[i] === c) {\n\t          return i - this._index + 1;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t  }, {\n\t    key: '_skipAllWhitespaces',\n\t    value: function _skipAllWhitespaces() {\n\t      while (this._isWhitespace()) {\n\t        this._read();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_markTokenStartLocation',\n\t    value: function _markTokenStartLocation() {\n\t      this._location.index = this._index - 1;\n\t      this._location.line = this._line;\n\t      this._location.column = this._column;\n\t    }\n\t  }, {\n\t    key: '_markTokenEndLocation',\n\t    value: function _markTokenEndLocation() {\n\t      var token = this._tokens[this._tokens.length - 1];\n\t      var _location = this._location;\n\t      var index = _location.index;\n\t      var line = _location.line;\n\t      var column = _location.column;\n\t\n\t      token.location = {\n\t        index: index, line: line, column: column,\n\t        endIndex: this._index - 1,\n\t        endLine: this._line,\n\t        endColumn: this._column\n\t      };\n\t    }\n\t  }, {\n\t    key: '_isWhitespace',\n\t    value: function _isWhitespace() {\n\t      return (/\\s/.test(this._char)\n\t      );\n\t    }\n\t  }, {\n\t    key: '_isDelimiter',\n\t    value: function _isDelimiter(d) {\n\t      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\t\n\t      var delimiter = this._delimiters[d];\n\t      var pos = this._index - 1 + offset;\n\t      return this._src.slice(pos, pos + delimiter.length) === delimiter;\n\t    }\n\t  }, {\n\t    key: '_makeToken',\n\t    value: function _makeToken(token) {\n\t      if (this._extensions.length) {\n\t        try {\n\t          this._extensions.forEach(function (ext) {\n\t            token = ext.transformToken(token);\n\t          });\n\t        } catch (e) {\n\t          this._setError(e.message);\n\t          return;\n\t        }\n\t      }\n\t      this._tokens.push(token);\n\t    }\n\t  }, {\n\t    key: '_setError',\n\t    value: function _setError(message) {\n\t      var error = new Error(message);\n\t      error.index = this._index - 1;\n\t      error.line = this._line;\n\t      error.column = this._column;\n\t      this._error = error;\n\t    }\n\t  }, {\n\t    key: 'error',\n\t    get: function get() {\n\t      return this._error;\n\t    }\n\t  }]);\n\t\n\t  return Tokenizer;\n\t})();\n\t\n\texports.Tokenizer = Tokenizer;\n\t\n\tfunction extractNewDelimiters(tagContent) {\n\t  var matches = tagContent.match(/=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/);\n\t  if (matches) {\n\t    return matches.slice(1);\n\t  } else {\n\t    return null;\n\t  }\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://github.com/mustache/spec/pull/75\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar NodeType = _interopRequireWildcard(_node);\n\t\n\tvar _token2 = __webpack_require__(3);\n\t\n\tvar TokenType = _interopRequireWildcard(_token2);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar PARENT = 'Inheritance.PARENT';\n\tvar BLOCK = 'Inheritance.BLOCK';\n\tvar LEAVE_SCOPE = 'Inheritance.LEAVE_SCOPE';\n\t\n\tfunction isInheritanceTagType(type) {\n\t  return type === PARENT || type === BLOCK;\n\t}\n\t\n\tvar Inheritance = (function (_Extension) {\n\t  _inherits(Inheritance, _Extension);\n\t\n\t  function Inheritance() {\n\t    _classCallCheck(this, Inheritance);\n\t\n\t    _get(Object.getPrototypeOf(Inheritance.prototype), 'constructor', this).call(this);\n\t\n\t    this._blocks = null;\n\t  }\n\t\n\t  _createClass(Inheritance, [{\n\t    key: 'transformToken',\n\t    value: function transformToken(token) {\n\t      var _token = token;\n\t      var type = _token.type;\n\t      var name = _token.name;\n\t      var location = _token.location;\n\t\n\t      switch (type) {\n\t        case TokenType.VARIABLE:\n\t          if (name) {\n\t            if (name[0] === '<') {\n\t              if (name.length === 1) {\n\t                throw new Error('Parent partial name expected');\n\t              }\n\t              token = {\n\t                type: PARENT,\n\t                name: name.slice(1),\n\t                location: location\n\t              };\n\t            } else if (name[0] === '$') {\n\t              if (name.length === 1) {\n\t                throw new Error('Block name expected');\n\t              }\n\t              token = {\n\t                type: BLOCK,\n\t                name: name.slice(1),\n\t                location: location\n\t              };\n\t            }\n\t          }\n\t          break;\n\t      }\n\t      return token;\n\t    }\n\t  }, {\n\t    key: 'handleToken',\n\t    value: function handleToken(token, parserContext) {\n\t      var handled = false;\n\t      var name = token.name;\n\t      var location = token.location;\n\t      var type = token.type;\n\t\n\t      switch (type) {\n\t        case PARENT:\n\t          parserContext.pushParent({\n\t            type: PARENT,\n\t            name: name,\n\t            location: location\n\t          });\n\t          handled = true;\n\t          break;\n\t\n\t        case BLOCK:\n\t          parserContext.pushParent({\n\t            type: BLOCK,\n\t            name: name,\n\t            location: location\n\t          });\n\t          break;\n\t\n\t        case TokenType.SECTION_CLOSE:\n\t          var tagNode = parserContext.tailNode;\n\t          if (tagNode === null) {\n\t            if (isInheritanceTagType(tagNode.type)) {\n\t              parserContext['throw']('Unexpected tag close');\n\t            }\n\t          } else {\n\t            if (tagNode.name !== name) {\n\t              parserContext['throw']('Unexpected tag close, current tag: ' + tagNode.name);\n\t            }\n\t            if (isInheritanceTagType(tagNode.type)) {\n\t              parserContext.popParent();\n\t              tagNode.location.endIndex = location.endIndex;\n\t              tagNode.location.endLine = location.endLine;\n\t              parserContext.appendNode(tagNode);\n\t\n\t              //TODO move this to visit, handle whitespaces after Parent close tag.\n\t              var firstLine = tagNode.location.line;\n\t              var firstBlock = tagNode.children.find(function (c) {\n\t                return c.type === BLOCK;\n\t              });\n\t              if (firstBlock && firstBlock.location.line === firstLine) {\n\t                for (var i = 0; i < firstBlock.children.length; i++) {\n\t                  var blockNode = firstBlock.children[i];\n\t                  if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n\t                    blockNode.text = '';\n\t                  } else {\n\t                    break;\n\t                  }\n\t                }\n\t              }\n\t\n\t              handled = true;\n\t            }\n\t          }\n\t          break;\n\t\n\t        case TokenType.EOF:\n\t          if (this.top > 0) {\n\t            parserContext['throw']('Unexpected EOF: tags not closed: ' + this.stack.map(function (f) {\n\t              return f.name;\n\t            }).join(', '));\n\t          }\n\t          break;\n\t      }\n\t      return handled;\n\t    }\n\t  }, {\n\t    key: 'handleNode',\n\t    value: function handleNode(node, rendererContext) {\n\t      switch (node.type) {\n\t        case PARENT:\n\t          this._handleParent(node, rendererContext);\n\t          return true;\n\t\n\t        case BLOCK:\n\t          this._handleBlock(node, rendererContext);\n\t          return true;\n\t\n\t        case LEAVE_SCOPE:\n\t          this._blocks = null;\n\t          return true;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_handleParent',\n\t    value: function _handleParent(node, rendererContext) {\n\t      var _this = this;\n\t\n\t      var name = node.name;\n\t      var location = node.location;\n\t\n\t      if (this._blocks === null) {\n\t        rendererContext.pushNodes([{\n\t          type: LEAVE_SCOPE\n\t        }]);\n\t        this._blocks = {};\n\t      }\n\t\n\t      //find all blocks defined in parent\n\t      node.children.forEach(function (child) {\n\t        if (child.type === BLOCK) {\n\t          var blockName = child.name;\n\t          if (!_this._blocks.hasOwnProperty(blockName)) {\n\t            _this._blocks[blockName] = child;\n\t          }\n\t        }\n\t      });\n\t\n\t      rendererContext.pushNode({\n\t        type: TokenType.PARTIAL,\n\t        name: name, location: location,\n\t        indent: node.indent\n\t      });\n\t    }\n\t  }, {\n\t    key: '_handleBlock',\n\t    value: function _handleBlock(node, rendererContext) {\n\t      var name = node.name;\n\t\n\t      if (this._blocks !== null && this._blocks.hasOwnProperty(name)) {\n\t        rendererContext.pushNodes(this._blocks[name].children);\n\t      } else {\n\t        rendererContext.pushNodes(node.children);\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return Inheritance;\n\t})(_extension.Extension);\n\n\texports.Inheritance = Inheritance;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\t\n\tvar _node = __webpack_require__(4);\n\t\n\tvar nodeTypes = _interopRequireWildcard(_node);\n\t\n\tvar _escapeHtml = __webpack_require__(9);\n\t\n\tvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\t\n\tvar _parser = __webpack_require__(5);\n\t\n\tvar _helpers = __webpack_require__(2);\n\t\n\tvar _extension = __webpack_require__(1);\n\t\n\tvar REPEATER_NODE_TYPE = '_REPEATER';\n\tvar MAX_PARTIAL_STACK = 10;\n\tvar MAX_LAMBDA_STACK = 255;\n\t\n\tvar RenderContext = (function () {\n\t  function RenderContext(renderer) {\n\t    _classCallCheck(this, RenderContext);\n\t\n\t    this._renderer = renderer;\n\t  }\n\t\n\t  _createClass(RenderContext, [{\n\t    key: 'evaluate',\n\t    value: function evaluate(name) {\n\t      return this._renderer._evaluate(name);\n\t    }\n\t  }, {\n\t    key: 'pushNodes',\n\t    value: function pushNodes(nodes) {\n\t      this._renderer._pushNodes(nodes);\n\t    }\n\t  }, {\n\t    key: 'pushNode',\n\t    value: function pushNode(node) {\n\t      this._renderer._pushNode(node);\n\t    }\n\t  }, {\n\t    key: 'pushContext',\n\t    value: function pushContext(ctx) {\n\t      this._renderer._pushContext(ctx);\n\t    }\n\t  }, {\n\t    key: 'parse',\n\t    value: function parse(src, opts) {\n\t      return this._renderer._parse(src, opts);\n\t    }\n\t  }, {\n\t    key: 'getParsedPartial',\n\t    value: function getParsedPartial(name) {\n\t      return this._renderer._getParsedPartial(name);\n\t    }\n\t  }, {\n\t    key: 'throw',\n\t    value: function _throw(message, location) {\n\t      return this._renderer._throw(message, location);\n\t    }\n\t  }, {\n\t    key: 'top',\n\t    get: function get() {\n\t      return this._renderer._stack.length;\n\t    }\n\t  }]);\n\t\n\t  return RenderContext;\n\t})();\n\t\n\tvar Renderer = (function () {\n\t  function Renderer(src) {\n\t    var _this = this;\n\t\n\t    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Renderer);\n\t\n\t    //if this is true, src and values in partials are parsed tree, not string\n\t    this._parsed = opts.parsed || false;\n\t\n\t    this._partials = opts.partials || {};\n\t    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n\t    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n\t    if (this._extensions.length > 0) {\n\t      this._renderContext = new RenderContext(this);\n\t    }\n\t\n\t    this._partialCached = {};\n\t    if (this._parsed) {\n\t      Object.keys(opts.partials).forEach(function (k) {\n\t        _this._partialCached[k] = opts.partials[k].children;\n\t      });\n\t    }\n\t\n\t    this._stack = null;\n\t    this._contextStack = null;\n\t    this._partialStack = null;\n\t    this._lambdaStack = null;\n\t    this._src = src;\n\t  }\n\t\n\t  _createClass(Renderer, [{\n\t    key: 'render',\n\t    value: function render(context) {\n\t      var _this2 = this;\n\t\n\t      this._stack = [];\n\t      this._contextStack = [];\n\t      this._partialStack = [];\n\t      this._lambdaStack = [];\n\t\n\t      this._pushContext(context);\n\t\n\t      //push root nodes\n\t      var rootNode = this._parsed ? this._src : this._parse(this._src);\n\t      this._stack = rootNode.children.slice(0).reverse();\n\t\n\t      var out = '';\n\t      var newline = true;\n\t\n\t      var _loop = function () {\n\t        var top = _this2._stack.length - 1;\n\t        var node = _this2._stack[top];\n\t\n\t        var handled = false;\n\t        if (_this2._extensions) {\n\t          _this2._extensions.forEach(function (ext) {\n\t            if (ext.handleNode(node, _this2._renderContext)) {\n\t              handled = true;\n\t            }\n\t          });\n\t        }\n\t\n\t        if (handled) {\n\t          _this2._stack.splice(top, 1);\n\t        } else {\n\t          var partial = _this2._partialStack.length ? _this2._partialStack[_this2._partialStack.length - 1] : null;\n\t\n\t          //insert indent\n\t          if (node.type in nodeTypes) {\n\t            if (newline && partial !== null && partial.indent.length > 0) {\n\t              out += partial.indent;\n\t            }\n\t          }\n\t\n\t          var value = undefined;\n\t          switch (node.type) {\n\t            case nodeTypes.VARIABLE:\n\t              value = _this2._evaluate(node.name);\n\t              if (isFunction(value)) {\n\t                _this2._popNode();\n\t                _this2._expandLambda(node, value);\n\t              } else {\n\t                if (!!value) {\n\t                  out += node.unescaped ? value : (0, _escapeHtml2['default'])(value);\n\t                }\n\t                _this2._popNode();\n\t              }\n\t              break;\n\t\n\t            case nodeTypes.SECTION:\n\t              value = _this2._evaluate(node.name);\n\t              if (isFunction(value)) {\n\t                _this2._popNode();\n\t                _this2._expandLambda(node, value);\n\t              } else {\n\t                var isList = Array.isArray(value);\n\t\n\t                if (isList && value.length === 0) {\n\t                  //Empty lists should behave like falsey values.\n\t                  value = false;\n\t                  isList = false;\n\t                }\n\t\n\t                var testResult = !!value;\n\t                if (node.inverted) {\n\t                  testResult = !testResult;\n\t                }\n\t\n\t                if (testResult) {\n\t                  if (isList) {\n\t                    _this2._popNode();\n\t                    _this2._pushRepeaterNode(value.length, node.children, value);\n\t                  } else {\n\t                    _this2._popNode();\n\t                    _this2._pushContext(value);\n\t                    _this2._pushNodes(node.children);\n\t                  }\n\t                } else {\n\t                  _this2._popNode();\n\t                }\n\t              }\n\t              break;\n\t\n\t            case nodeTypes.TEXT:\n\t              out += node.text;\n\t              _this2._popNode();\n\t              break;\n\t\n\t            case nodeTypes.COMMENT:\n\t              _this2._popNode();\n\t              break;\n\t\n\t            case nodeTypes.PARTIAL:\n\t              _this2._popNode();\n\t              _this2._expandPartial(node);\n\t              break;\n\t\n\t            case nodeTypes.DELIMITER_CHANGE:\n\t              _this2._popNode();\n\t              _this2._delimiters = node.delimiters.slice(0);\n\t              break;\n\t\n\t            case REPEATER_NODE_TYPE:\n\t              if (node.count < node.repeat) {\n\t                var repeatIndex = node.count;\n\t                if (repeatIndex === 0) {\n\t                  _this2._pushContext(node.contexts[0]);\n\t                } else {\n\t                  _this2._replaceTopContext(node.contexts[repeatIndex]);\n\t                }\n\t                _this2._pushNodes(node.children);\n\t                node.count++;\n\t              } else {\n\t                _this2._popNode();\n\t              }\n\t              break;\n\t\n\t            default:\n\t              _this2._popNode();\n\t              break;\n\t          }\n\t        }\n\t        _this2._checkStacks();\n\t        newline = out.length === 0 || out[out.length - 1] === '\\n';\n\t      };\n\t\n\t      while (this._stack.length > 0) {\n\t        _loop();\n\t      }\n\t      return out;\n\t    }\n\t  }, {\n\t    key: '_parse',\n\t    value: function _parse(src) {\n\t      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t      opts.extensions = this._extensions;\n\t      var parser = new _parser.Parser(opts);\n\t      return parser.parse(src);\n\t    }\n\t  }, {\n\t    key: '_pushNodes',\n\t    value: function _pushNodes(list) {\n\t      for (var i = list.length - 1; i >= 0; i--) {\n\t        this._stack.push(list[i]);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_pushNode',\n\t    value: function _pushNode(node) {\n\t      this._stack.push(node);\n\t    }\n\t  }, {\n\t    key: '_popNode',\n\t    value: function _popNode() {\n\t      this._stack.pop();\n\t    }\n\t  }, {\n\t    key: '_pushRepeaterNode',\n\t    value: function _pushRepeaterNode(repeat, nodes, contexts) {\n\t      this._stack.push({\n\t        type: REPEATER_NODE_TYPE,\n\t        count: 0,\n\t        repeat: repeat,\n\t        children: nodes.slice(0),\n\t        contexts: contexts\n\t      });\n\t    }\n\t  }, {\n\t    key: '_pushContext',\n\t    value: function _pushContext(context) {\n\t      this._contextStack.push({\n\t        context: context,\n\t        sp: this._stack.length\n\t      });\n\t    }\n\t  }, {\n\t    key: '_pushPartial',\n\t    value: function _pushPartial(_ref) {\n\t      var name = _ref.name;\n\t      var indent = _ref.indent;\n\t      var location = _ref.location;\n\t\n\t      this._partialStack.push({\n\t        name: name,\n\t        indent: indent || '',\n\t        location: location,\n\t        sp: this._stack.length\n\t      });\n\t    }\n\t  }, {\n\t    key: '_pushLambda',\n\t    value: function _pushLambda(_ref2) {\n\t      var name = _ref2.name;\n\t      var location = _ref2.location;\n\t\n\t      this._lambdaStack.push({\n\t        name: name,\n\t        location: location,\n\t        sp: this._stack.length\n\t      });\n\t    }\n\t  }, {\n\t    key: '_replaceTopContext',\n\t    value: function _replaceTopContext(context) {\n\t      this._contextStack[this._contextStack.length - 1].context = context;\n\t    }\n\t  }, {\n\t    key: '_checkStacks',\n\t    value: function _checkStacks() {\n\t      if (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n\t        this._contextStack.pop();\n\t      }\n\t\n\t      if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n\t        this._partialStack.pop();\n\t      }\n\t\n\t      if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n\t        this._lambdaStack.pop();\n\t      }\n\t    }\n\t  }, {\n\t    key: '_evaluate',\n\t    value: function _evaluate(name) {\n\t      if (name === '.') {\n\t        return this._contextStack[this._contextStack.length - 1].context;\n\t      }\n\t\n\t      var path = name.split('.');\n\t      for (var i = this._contextStack.length - 1; i >= 0; i--) {\n\t        var context = this._contextStack[i].context;\n\t        if (context === null || typeof context !== 'object') {\n\t          continue;\n\t        }\n\t\n\t        var current = context;\n\t        var resolved = true;\n\t        for (var pi = 0; pi < path.length; pi++) {\n\t          var key = path[pi];\n\t          if (current.hasOwnProperty(key)) {\n\t            current = current[key];\n\t          } else {\n\t            resolved = false;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (resolved) {\n\t          return current;\n\t        }\n\t      }\n\t      return '';\n\t    }\n\t  }, {\n\t    key: '_getParsedPartial',\n\t    value: function _getParsedPartial(name) {\n\t      if (this._partialCached.hasOwnProperty(name)) {\n\t        return this._partialCached[name];\n\t      } else {\n\t        if (!this._partials.hasOwnProperty(name)) {\n\t          return null;\n\t        }\n\t        var ast = this._parse(this._partials[name], { filename: name });\n\t        var nodes = this._partialCached[name] = ast.children;\n\t        return nodes;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_expandPartial',\n\t    value: function _expandPartial(node) {\n\t      var name = node.name;\n\t\n\t      var nodes = this._getParsedPartial(name);\n\t\n\t      if (nodes === null) {\n\t        //The empty string should be used when the named partial is not found.\n\t        return;\n\t      }\n\t\n\t      this._pushPartial(node);\n\t\n\t      if (this._partialStack.length > MAX_PARTIAL_STACK) {\n\t        this._throw('Possible partial short circuit: ' + this._partialStack.map(function (f) {\n\t          return f.name + '@' + f.location.filename + ':' + (f.location.line + 1);\n\t        }).concat([name]).join(' -> '), node.location);\n\t      }\n\t\n\t      this._pushNodes(nodes);\n\t    }\n\t  }, {\n\t    key: '_expandLambda',\n\t    value: function _expandLambda(node, lambda) {\n\t      var name = node.name;\n\t\n\t      this._pushLambda(node);\n\t\n\t      if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n\t        this._throw('Possible lambda short circuit: ' + this._lambdaStack.map(function (f) {\n\t          return f.name + '@' + f.location.filename + ':' + (f.location.line + 1);\n\t        }).concat([name]).join(' -> '), node.location);\n\t      }\n\t\n\t      var ast = undefined;\n\t      var skipped = false;\n\t      if (node.type === nodeTypes.VARIABLE) {\n\t        var code = lambda();\n\t        if (code) {\n\t          //A lambda's return value should parse with the default delimiters.\n\t          ast = this._parse('' + code, { filename: '[lambda]' });\n\t          if (!node.unescaped) {\n\t            //Lambda results should be appropriately escaped.\n\t            (0, _helpers.walk)(ast, function (node) {\n\t              if (node.type === nodeTypes.TEXT) {\n\t                node.text = (0, _escapeHtml2['default'])(node.text);\n\t              }\n\t            });\n\t          }\n\t        } else {\n\t          skipped = true;\n\t        }\n\t      } else if (node.type === nodeTypes.SECTION) {\n\t        var code = lambda(node.raw);\n\t        if (code) {\n\t          //Lambdas used for inverted sections should be considered truthy.\n\t          //Lambdas used for sections should parse with the current delimiters.\n\t          ast = this._parse('' + code, {\n\t            filename: '[#lambda]',\n\t            delimiters: this._delimiters.slice(0)\n\t          });\n\t        } else {\n\t          skipped = true;\n\t        }\n\t      }\n\t\n\t      if (!skipped) {\n\t        this._pushNodes(ast.children);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_throw',\n\t    value: function _throw(message, location) {\n\t      var e = new Error(message);\n\t      e.location = location;\n\t      throw e;\n\t    }\n\t  }]);\n\t\n\t  return Renderer;\n\t})();\n\t\n\texports.Renderer = Renderer;\n\t\n\tfunction isFunction(x) {\n\t  return Object.prototype.toString.call(x) == '[object Function]';\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * escape-html\n\t * Copyright(c) 2012-2013 TJ Holowaychuk\n\t * Copyright(c) 2015 Andreas Lubbe\n\t * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n\t * MIT Licensed\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Module variables.\n\t * @private\n\t */\n\t\n\tvar matchHtmlRegExp = /[\"'&<>]/;\n\t\n\t/**\n\t * Module exports.\n\t * @public\n\t */\n\t\n\tmodule.exports = escapeHtml;\n\t\n\t/**\n\t * Escape special characters in the given string of html.\n\t *\n\t * @param  {string} string The string to escape for inserting into HTML\n\t * @return {string}\n\t * @public\n\t */\n\t\n\tfunction escapeHtml(string) {\n\t  var str = '' + string;\n\t  var match = matchHtmlRegExp.exec(str);\n\t\n\t  if (!match) {\n\t    return str;\n\t  }\n\t\n\t  var escape;\n\t  var html = '';\n\t  var index = 0;\n\t  var lastIndex = 0;\n\t\n\t  for (index = match.index; index < str.length; index++) {\n\t    switch (str.charCodeAt(index)) {\n\t      case 34: // \"\n\t        escape = '&quot;';\n\t        break;\n\t      case 38: // &\n\t        escape = '&amp;';\n\t        break;\n\t      case 39: // '\n\t        escape = '&#39;';\n\t        break;\n\t      case 60: // <\n\t        escape = '&lt;';\n\t        break;\n\t      case 62: // >\n\t        escape = '&gt;';\n\t        break;\n\t      default:\n\t        continue;\n\t    }\n\t\n\t    if (lastIndex !== index) {\n\t      html += str.substring(lastIndex, index);\n\t    }\n\t\n\t    lastIndex = index + 1;\n\t    html += escape;\n\t  }\n\t\n\t  return lastIndex !== index\n\t    ? html + str.substring(lastIndex, index)\n\t    : html;\n\t}\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** huz.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2b98fc9fd9c46b7daf18\n **/","import { Parser } from './parser';\nimport { Renderer } from './renderer';\nimport * as TokenType from './token';\nimport * as NodeType from './node';\nimport * as Helpers from './helpers';\nimport { register } from './extension';\n\nexport { Tokenizer } from './tokenizer';\nexport { Parser, Renderer, TokenType, NodeType };\n\nimport { Inheritance } from './extensions/inheritance';\n\nregister(Inheritance);\n\nexport function parse(src, opts) {\n  const parser = new Parser(opts);\n  return parser.parse(src);\n}\n\nexport function compile(src, opts) {\n  return new Renderer(src, opts);\n}\n\nexport function render(src, context, opts) {\n  const r = compile(src, opts);\n  return r.render(context);\n}\n\nexport { register, Helpers };\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","const registry = [];\n\nexport class Extension {\n  //called by tokenizer\n  transformToken(token) { return token; }\n\n  //called by parser\n  handleToken(token, parserContext) { }\n  visit(root) { return root; }\n  \n  //called by renderer\n  handleNode(node, renderContext) { }\n}\n\nexport function instantiateAll(opts) {\n  return registry.map(ctor => {\n    return new ctor(opts);\n  });\n}\n\nexport function register(constructor) {\n  return registry.push(constructor);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/extension.js\n **/","import * as TokenType from './token';\n\nexport function walk(root, modifier) {\n  let stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    const node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nexport function visit(root, visitor) {\n  let stack = [root];\n  while (stack.length) {\n    const parent = stack.pop();\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      const modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nexport function trimStandaloneToken(tokens) {\n  const count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  let open = null;\n  let inline = 0;\n  let standalone = true;\n  let indentTokens = [];\n  for (let i = 0; standalone && i < count; i++) {\n    const token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline ++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline ++;\n        }\n        break;\n      default: //section-like tags\n        if (open === null) {\n          open = [token];\n          inline ++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n  \n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    let tailWSNodeCount = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount ++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        let indent = '';\n        indentTokens.forEach(t => { indent += t.text });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return /^\\s*$/.test(str);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/helpers.js\n **/","export const EOF                    = 'EOF';\nexport const TEXT                   = 'TEXT';\nexport const PARTIAL                = 'PARTIAL';\nexport const INVERTED_SECTION_OPEN  = 'INVERTED_SECTION_OPEN';\nexport const SECTION_OPEN           = 'SECTION_OPEN';\nexport const SECTION_CLOSE          = 'SECTION_CLOSE';\nexport const UNESCAPED_VARIABLE     = 'UNESCAPED_VARIABLE';\nexport const COMMENT                = 'COMMENT';\nexport const VARIABLE               = 'VARIABLE';\nexport const DELIMITER_CHANGE \t\t\t= 'DELIMITER_CHANGE';\n\n\n/** WEBPACK FOOTER **\n ** ./src/token.js\n **/","export const ROOT             = 'ROOT';\nexport const VARIABLE         = 'VARIABLE';\nexport const SECTION          = 'SECTION';\nexport const TEXT             = 'TEXT';\nexport const COMMENT          = 'COMMENT';\nexport const PARTIAL          = 'PARTIAL';\nexport const DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\n\n/** WEBPACK FOOTER **\n ** ./src/node.js\n **/","import * as TokenType from './token';\nimport * as NodeType from './node';\nimport { Tokenizer } from './tokenizer';\nimport { visit } from './helpers';\nimport { instantiateAll } from './extension';\n\nclass ParserContext {\n  constructor(parser) {\n    this._parser = parser;\n  }\n\n  appendNode(node) {\n    this._parser._appendNode(node);\n  }\n\n  pushParent(node) {\n    this._parser._pushParent(node);\n  }\n\n  popParent() {\n    return this._parser._popParent();\n  }\n\n  get filename() {\n    return this._parser._filename;\n  }\n\n  get top() {\n    return this._parser._stack.length;\n  }\n\n  get tailNode() {\n    return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n  }\n\n  throw(message) {\n    return this._parser._throw(message);\n  }\n}\n\nexport class Parser {\n  constructor(opts = {}) {\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    this._filename = opts.filename || '';\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  parse(src) {\n    const rootNode = { \n      type: NodeType.ROOT, \n      children: []\n    };\n    this._src = src;\n    this._stack = [rootNode];\n    this._lastToken = null;\n    this._parseNodes(src);\n\n    if (this._extensions.length > 0) {\n      for (let i = 0; i < this._extensions.length; i++) {\n        this._extensions[i].visit(rootNode);\n      }\n    }\n\n    return rootNode;\n  }\n\n  _appendNode(node) {\n    node.location.filename = this._filename;\n    this._stack[this._stack.length - 1].children.push(node);\n    return node;\n  }\n\n  _getTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  _clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  _makeLocation(beginLocation, endLocation) {\n    const location = this._clone(beginLocation);\n    if (endLocation) {\n      location.endIndex = endLocation.endIndex;\n      location.endLine = endLocation.endLine;\n    }\n    return location;\n  }\n\n  _parseNodes(src) {\n    let initialStackSize = this._stack.length;\n    let token;\n    const z = new Tokenizer(src, { \n      delimiters: this._delimiters.slice(0),\n      extensions: this._extensions\n    });\n\n    do {\n      token = z.getNextToken();\n\n      if (z.error !== null) {\n        throw z.error;\n      }\n\n      this._lastToken = token;\n\n      let handled = false;\n      if (this._extensions) {\n        for (let i = 0; i < this._extensions.length; i++) {\n          const ext = this._extensions[i];\n          if (ext.handleToken(token, this._parserContext) === true) {\n            handled = true;\n            break;\n          }\n        }\n      }\n\n      if (!handled) {\n        switch (token.type) {\n          case TokenType.TEXT:\n            this._appendNode({\n              type: NodeType.TEXT,\n              text: token.text,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.VARIABLE:\n          case TokenType.UNESCAPED_VARIABLE:\n            this._appendNode({\n              type: NodeType.VARIABLE,\n              name: token.name,\n              unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.SECTION_OPEN:\n            this._handleSectionOpen(token);\n            break;\n\n          case TokenType.INVERTED_SECTION_OPEN:\n            this._handleSectionOpen(token, true);\n            break;\n\n          case TokenType.SECTION_CLOSE:\n            this._handleSectionClose(token);\n            break;\n\n          case TokenType.PARTIAL:\n            this._appendNode({\n              type: NodeType.PARTIAL,\n              name: token.name,\n              indent: token.indent,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.COMMENT:\n            this._handleComment(token);\n            break;\n\n          case TokenType.DELIMITER_CHANGE:\n            this._appendNode({\n              type: NodeType.DELIMITER_CHANGE,\n              delimiters: token.delimiters,\n              location: this._makeLocation(token.location)\n            });\n            break;\n        }\n      }\n    } while (token.type !== TokenType.EOF);\n\n    if (this._stack.length > initialStackSize) {\n      this._throw('Unexpected EOF: sections not closed: ' + \n        this._stack.slice(initialStackSize).map(n => `'${n.name}'`).join(', '));\n    } else if (this._stack.length < initialStackSize) {\n      this._throw('Internal error.');\n    }\n  }\n\n  _throw(message) {\n    const e = new Error(message);\n    e.location = this._lastToken.location;\n    throw e;\n  }\n\n  _pushParent(node) {\n    node.children = [];\n    this._stack.push(node);\n  }\n\n  _popParent() {\n    return this._stack.pop();\n  }\n\n  _handleSectionOpen(token, inverted = false) {\n    const { name, location } = token;\n    this._pushParent({\n      type: NodeType.SECTION,\n      name,\n      inverted,\n      location\n    });\n  }\n\n  _handleSectionClose(token) {\n    const { name, location } = token;\n    const section = this._popParent();\n    if (section.type !== NodeType.SECTION) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}'`);\n    }\n\n    if (section.name !== name) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}', current section: '${section.name}'`);\n    }\n\n    section.raw = this._src.slice(section.location.endIndex, location.index);\n    section.location = this._makeLocation(section.location, token.location);\n\n    this._appendNode(section);\n  }\n\n  _handleComment(token) {\n    const { content, location } = token;\n    this._appendNode({\n      type: NodeType.COMMENT,\n      content,\n      location: this._makeLocation(location)\n    });\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/parser.js\n **/","import * as TokenType from './token';\nimport { instantiateAll } from './extension';\nimport { trimStandaloneToken } from './helpers';\n\nconst STATE_NONE        = 'STATE_NONE';\nconst STATE_EOF         = 'STATE_EOF';\nconst STATE_TEXT        = 'STATE_TEXT';\nconst STATE_TEXT_BREAK  = 'STATE_TEXT_BREAK';\nconst STATE_TAG         = 'STATE_TAG';\n\nconst DELIMITER_LEFT  = 0;\nconst DELIMITER_RIGHT = 1;\n\nexport class Tokenizer {\n  constructor(src, opts = {}) {\n    this._extensions = opts.extensions || instantiateAll();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 0;\n    this._column = 0;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  getNextToken() {\n    if (this._tokens.length > 0) {\n      return this._tokens.shift();\n    }\n\n    let done = false;\n    let matched = false;\n    do {\n      //console.log(this._state, this._tokens);\n      if (this._error !== null) {\n        return null;\n      }\n\n      if (this._state !== STATE_NONE) {\n        matched = true;\n        this._markTokenStartLocation();\n      }\n\n      switch (this._state) {\n        case STATE_NONE:\n          this._read();\n          break;\n\n        case STATE_EOF:\n          this._handleEOF();\n          done = true;\n          break;\n\n        case STATE_TEXT:\n          this._handleText();\n          break;\n\n        case STATE_TEXT_BREAK:\n          this._handleTextBreak();\n          done = true;\n          break;\n\n        case STATE_TAG:\n          this._handleTag();\n          break;\n      }\n\n      if (matched) {\n        this._markTokenEndLocation();\n        matched = false;\n      }\n\n      if (this._state === STATE_NONE) {\n        if (this._char === null) {\n          this._state = STATE_EOF;\n        } else if (this._char === '\\n') {\n          this._state = STATE_TEXT_BREAK;\n        } else if (this._isDelimiter(DELIMITER_LEFT)) {\n          this._state = STATE_TAG;\n        } else {\n          this._state = STATE_TEXT;\n        }\n      }\n\n    } while (!done);\n\n    return this._error === null ? this._tokens.shift() : null;\n  }\n\n  // Handlers\n\n  _handleEOF() {\n    this._handleStandaloneTag();\n    this._makeToken({ \n      type: TokenType.EOF\n    });\n  }\n\n  _handleTag() {\n    const [ left, right ] = this._delimiters;\n    this._skip(left.length);\n    this._skipAllWhitespaces();\n\n    if (this._char === null) {\n      this._setError('Unclosed tag.');\n    }\n    else if (this._isDelimiter(DELIMITER_RIGHT)) {\n      this._handleEmptyTag();\n    } else {\n      const tagTypeChar = this._char;\n      if (tagTypeChar === '{') {\n        this._handleVariableCurly();\n      } else {\n        let tagContentStart = this._index - 1;\n        //read content\n        while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n          this._read();\n        }\n\n        if (this._char === null) {\n          this._setError('Unclosed tag.');\n        } else {\n          const content = this._src.slice(tagContentStart, this._index - 1);\n          switch (tagTypeChar) {\n            case '>': this._handleSimpleTag(TokenType.PARTIAL, content); break;\n            case '^': this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content); break;\n            case '#': this._handleSimpleTag(TokenType.SECTION_OPEN, content); break;\n            case '/': this._handleSimpleTag(TokenType.SECTION_CLOSE, content); break;\n\n            case '!':\n              this._handleComment(content.substr(1));\n              break;\n\n            case '=':\n              this._handleDelimiterChange(content);\n              break;\n            case '&':\n              this._handleVariable(content.substr(1), true);\n              break;\n            default:\n              this._handleVariable(content);\n              break;\n          }\n        }\n      }\n    }\n    if (this._error === null) {\n      //eat right\n      for (let i = 0; i < right.length; i++) {\n        this._read();\n      }\n    }\n\n    this._state = STATE_NONE;\n  }\n\n  _handleDelimiterChange(content) {\n    const newDelimiters = extractNewDelimiters(content);\n    if (newDelimiters === null) {\n      this._setError('Invalid change delimiter syntax.');\n    } else {\n      const [ left, right ] = newDelimiters;\n      this._delimiters = newDelimiters;\n      this._makeToken({\n        type: TokenType.DELIMITER_CHANGE,\n        delimiters: [ left, right ]\n      });\n    }\n  }\n\n  _handleSimpleTag(type, content) {\n    this._makeToken({ type, name: content.substr(1).trim() });\n  }\n\n  _handleComment(content) {\n    this._makeToken({\n      type: TokenType.COMMENT,\n      content\n    });\n  }\n\n  _handleVariableCurly() {\n    this._read(); //eat '{'\n    const begin = this._index - 1;\n    const d = this._distance('}');\n    if (d === -1) {\n      this._setError('Unclosed variable tag: missingright curly.');\n    } else {\n      const content = this._src.slice(begin, begin + d);\n      this._skip(d + 1); //skip '}'\n      this._skipAllWhitespaces();\n      if (!this._isDelimiter(DELIMITER_RIGHT)) {\n        this._setError('Unclosed variable: missing right delimiter.');\n      } else {\n        this._makeToken({\n          type: TokenType.UNESCAPED_VARIABLE,\n          name: content.trim()\n        });\n      }\n    }\n  }\n\n  _handleEmptyTag() {\n    this._makeToken({\n      type: TokenType.VARIABLE,\n      name: ''\n    });\n  }\n\n  _handleVariable(content, unescaped) {\n    this._makeToken({\n      type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n      name: content.trim()\n    });\n  }\n\n  _handleText() {\n    let done = false;\n    let index = this._index - 1;\n    let length = 0;\n    do {\n      const c = this._char;\n\n      if (c === null || c === '\\n' || this._isDelimiter(DELIMITER_LEFT)) {\n        done = true;\n      } else {\n        length ++;\n      }\n\n      if (!done) {\n        this._read();\n      }\n    } while (!done);\n\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: this._src.slice(index, index + length)\n    });\n\n    this._state = STATE_NONE;\n  }\n\n  _handleTextBreak() {\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: '\\n'\n    });\n    this._read();\n    this._handleStandaloneTag();\n    this._state = STATE_NONE;\n  }\n\n  _handleStandaloneTag() {\n    this._tokens = trimStandaloneToken(this._tokens);\n  }\n\n  // Helpers\n  _dump(t = '') {\n    console.log(t +'>'+this._src.slice(this._index - 1));\n  }\n\n  _read() {\n    if (this._index < this._src.length) {\n      if (this._char === '\\n') {\n        this._line ++;\n        this._column = 0;\n      } else {\n        this._column ++;\n      }\n\n      this._char = this._src[this._index];\n      this._index ++;\n    } else {\n      this._char = null;\n    }\n  }\n\n  _peek() {\n    if (this._index < this._src.length - 1) {\n      return this._src[this._index];\n    } else {\n      return null;\n    }\n  }\n\n  _skip(n) {\n    for (let i = 0; i < n; i ++) {\n      this._read();\n    }\n  }\n\n  _distance(c) {\n    for (let i = this._index; i < this._src.length; i++) {\n      if (this._src[i] === c) {\n        return i - this._index + 1;\n      }\n    }\n    return -1;\n  }\n\n  _skipAllWhitespaces() {\n    while (this._isWhitespace()) {\n      this._read();\n    }\n  }\n\n  _markTokenStartLocation() {\n    this._location.index = this._index - 1;\n    this._location.line = this._line;\n    this._location.column = this._column;\n  }\n\n  _markTokenEndLocation() {\n    const token = this._tokens[this._tokens.length - 1];\n    const { index, line, column } = this._location;\n    token.location = {\n      index, line, column,\n      endIndex: this._index - 1,\n      endLine: this._line,\n      endColumn: this._column\n    };\n  }\n\n  _isWhitespace() {\n    return /\\s/.test(this._char);\n  }\n\n  _isDelimiter(d, offset = 0) {\n    const delimiter = this._delimiters[d];\n    const pos = this._index - 1 + offset;\n    return this._src.slice(pos, pos + delimiter.length) === delimiter;\n  }\n\n  _makeToken(token) {\n    if (this._extensions.length) {\n      try {\n        this._extensions.forEach(ext => {\n          token = ext.transformToken(token);\n        });\n      } catch (e) {\n        this._setError(e.message);\n        return;\n      }\n    }\n    this._tokens.push(token);\n  }\n\n  _setError(message) {\n    const error = new Error(message);\n    error.index = this._index - 1;\n    error.line = this._line;\n    error.column = this._column;\n    this._error = error;\n  }\n}\n\nfunction extractNewDelimiters(tagContent) {\n  const matches = tagContent.match(/=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/tokenizer.js\n **/","// https://github.com/mustache/spec/pull/75\n\nimport { Extension, register } from '../extension';\nimport * as NodeType from '../node';\nimport * as TokenType from '../token';\nimport { walk } from '../helpers';\n\nconst PARENT = 'Inheritance.PARENT';\nconst BLOCK = 'Inheritance.BLOCK';\nconst LEAVE_SCOPE = 'Inheritance.LEAVE_SCOPE';\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nexport class Inheritance extends Extension {\n  constructor() {\n    super();\n\n    this._blocks = null;\n  }\n\n  transformToken(token) {\n    const { type, name, location } = token;\n    switch (type) {\n      case TokenType.VARIABLE:\n        if (name) {\n          if (name[0] === '<') {\n            if (name.length === 1) {\n              throw new Error('Parent partial name expected');\n            }\n            token = {\n              type: PARENT,\n              name: name.slice(1),\n              location\n            };\n          } else if (name[0] === '$') {\n            if (name.length === 1) {\n              throw new Error('Block name expected');\n            }\n            token = {\n              type: BLOCK,\n              name: name.slice(1),\n              location\n            };\n          }\n        }\n        break;\n    }\n    return token;\n  }\n\n  handleToken(token, parserContext) {\n    let handled = false;\n    const { name, location, type } = token;\n    switch (type) {\n      case PARENT:\n        parserContext.pushParent({\n          type: PARENT,\n          name,\n          location\n        });\n        handled = true;\n        break;\n\n      case BLOCK:\n        parserContext.pushParent({\n          type: BLOCK,\n          name,\n          location\n        });\n        break;\n\n      case TokenType.SECTION_CLOSE:\n        const tagNode = parserContext.tailNode;\n        if (tagNode === null) {\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.throw('Unexpected tag close');\n          }\n        } else {\n          if (tagNode.name !== name) {\n            parserContext.throw(`Unexpected tag close, current tag: ${tagNode.name}`);\n          }\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.popParent();\n            tagNode.location.endIndex = location.endIndex;\n            tagNode.location.endLine = location.endLine;\n            parserContext.appendNode(tagNode);\n\n            //TODO move this to visit, handle whitespaces after Parent close tag.\n            const firstLine = tagNode.location.line;\n            const firstBlock = tagNode.children.find(c => c.type === BLOCK);\n            if (firstBlock && firstBlock.location.line === firstLine) {\n              for (let i = 0; i < firstBlock.children.length; i++) {\n                const blockNode = firstBlock.children[i];\n                if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n                  blockNode.text = '';\n                } else {\n                  break;\n                }\n              }\n            }\n\n            handled = true;\n          }\n        }\n        break;\n\n      case TokenType.EOF:\n        if (this.top > 0) {\n          parserContext.throw('Unexpected EOF: tags not closed: ' + \n            this.stack.map(f => f.name).join(', '));\n        }\n        break;\n    }\n    return handled;\n  }\n\n  handleNode(node, rendererContext) {\n    switch (node.type) {\n      case PARENT:\n        this._handleParent(node, rendererContext);\n        return true;\n\n      case BLOCK:\n        this._handleBlock(node, rendererContext);\n        return true;\n\n      case LEAVE_SCOPE:\n        this._blocks = null;\n        return true;\n    }\n  }\n\n  _handleParent(node, rendererContext) {\n    const { name, location } = node;\n\n    if (this._blocks === null) {\n      rendererContext.pushNodes([\n        {\n          type: LEAVE_SCOPE\n        }\n      ]);\n      this._blocks = {};\n    }\n\n    //find all blocks defined in parent\n    node.children.forEach(child => {\n      if (child.type === BLOCK) {\n        const blockName = child.name;\n        if (!this._blocks.hasOwnProperty(blockName)) {\n          this._blocks[blockName] = child;\n        }\n      }\n    });\n\n    rendererContext.pushNode({\n      type: TokenType.PARTIAL,\n      name, location,\n      indent: node.indent,\n    });\n  }\n\n  _handleBlock(node, rendererContext) {\n    const { name } = node;\n    if (this._blocks !== null && this._blocks.hasOwnProperty(name)) {\n      rendererContext.pushNodes(this._blocks[name].children);\n    } else {\n      rendererContext.pushNodes(node.children);\n    }\n  }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/extensions/inheritance.js\n **/","import * as nodeTypes from './node';\nimport escapeHTML from 'escape-html';\nimport { Parser } from './parser';\nimport { walk, visit } from './helpers';\nimport { instantiateAll } from './extension';\n\nconst REPEATER_NODE_TYPE  = '_REPEATER';\nconst MAX_PARTIAL_STACK = 10;\nconst MAX_LAMBDA_STACK = 255;\n\nclass RenderContext {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n\n  get top() {\n    return this._renderer._stack.length;\n  }\n\n  evaluate(name) {\n    return this._renderer._evaluate(name);\n  }\n\n  pushNodes(nodes) {\n    this._renderer._pushNodes(nodes);\n  }\n\n  pushNode(node) {\n    this._renderer._pushNode(node);\n  }\n\n  pushContext(ctx) {\n    this._renderer._pushContext(ctx);\n  }\n\n  parse(src, opts) {\n    return this._renderer._parse(src, opts);\n  }\n\n  getParsedPartial(name) {\n    return this._renderer._getParsedPartial(name);\n  }\n\n  throw(message, location) {\n    return this._renderer._throw(message, location);\n  }\n}\n\nexport class Renderer {\n  constructor(src, opts = {}) {\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    \n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(opts.partials).forEach(k => {\n        this._partialCached[k] = opts.partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n  }\n\n  render(context) {\n    this._stack = [];\n    this._contextStack = [];\n    this._partialStack = [];\n    this._lambdaStack = [];\n\n    this._pushContext(context);\n\n    //push root nodes\n    const rootNode = this._parsed ? this._src : this._parse(this._src);\n    this._stack = rootNode.children.slice(0).reverse();\n\n    let out = '';\n    let newline = true;\n    while (this._stack.length > 0) {\n      const top = this._stack.length - 1;\n      const node = this._stack[top];\n\n      let handled = false;\n      if (this._extensions) {\n        this._extensions.forEach(ext => {\n          if (ext.handleNode(node, this._renderContext)) {\n            handled = true;\n          }\n        });\n      }\n\n      if (handled) {\n        this._stack.splice(top, 1);\n      } else {\n        const partial = this._partialStack.length ? this._partialStack[this._partialStack.length - 1] : null;\n\n        //insert indent\n        if (node.type in nodeTypes) {\n          if (newline && partial !== null && partial.indent.length > 0) {\n            out += partial.indent;\n          }\n        }\n\n        let value;\n        switch (node.type) {\n          case nodeTypes.VARIABLE:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              if (!!value) {\n                out += node.unescaped ? value : escapeHTML(value);\n              }\n              this._popNode();\n            }\n            break;\n\n          case nodeTypes.SECTION:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              let isList = Array.isArray(value);\n\n              if (isList && value.length === 0) {\n                //Empty lists should behave like falsey values.\n                value = false;\n                isList = false;\n              }\n\n              let testResult = !!value;\n              if (node.inverted) {\n                testResult = !testResult;\n              }\n\n              if (testResult) {\n                if (isList) {\n                  this._popNode();\n                  this._pushRepeaterNode(value.length, node.children, value);\n                } else {\n                  this._popNode()\n                  this._pushContext(value);\n                  this._pushNodes(node.children);\n                }\n              } else {\n                this._popNode();\n              }\n            }\n            break;\n\n          case nodeTypes.TEXT:\n            out += node.text;\n            this._popNode()\n            break;\n\n          case nodeTypes.COMMENT:\n            this._popNode();\n            break;\n\n          case nodeTypes.PARTIAL:\n            this._popNode();\n            this._expandPartial(node);\n            break;\n\n          case nodeTypes.DELIMITER_CHANGE:\n            this._popNode();\n            this._delimiters = node.delimiters.slice(0);\n            break;\n\n          case REPEATER_NODE_TYPE:\n            if (node.count < node.repeat) {\n              const repeatIndex = node.count;\n              if (repeatIndex === 0) {\n                this._pushContext(node.contexts[0]);\n              } else {\n                this._replaceTopContext(node.contexts[repeatIndex]);\n              }\n              this._pushNodes(node.children);\n              node.count ++;\n            } else {\n              this._popNode();\n            }\n            break;\n\n          default:\n            this._popNode();\n            break;\n        }\n      }\n      this._checkStacks();\n      newline = out.length === 0 || (out[out.length -1 ] === '\\n');\n    }\n    return out;\n  }\n\n  _parse(src, opts = {}) {\n    opts.extensions = this._extensions;\n    const parser = new Parser(opts);\n    return parser.parse(src);\n  }\n\n  _pushNodes(list) {\n    for (let i = list.length - 1; i >= 0; i --) {\n      this._stack.push(list[i]);\n    }\n  }\n\n  _pushNode(node) {\n    this._stack.push(node);\n  }\n\n  _popNode() {\n    this._stack.pop();\n  }\n\n  _pushRepeaterNode(repeat, nodes, contexts) {\n    this._stack.push({\n      type: REPEATER_NODE_TYPE,\n      count: 0,\n      repeat,\n      children: nodes.slice(0),\n      contexts\n    });\n  }\n\n  _pushContext(context) {\n    this._contextStack.push({\n      context,\n      sp: this._stack.length\n    });\n  }\n\n  _pushPartial({ name, indent, location }) {\n    this._partialStack.push({\n      name,\n      indent: indent || '',\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _pushLambda({ name, location }) {\n    this._lambdaStack.push({\n      name,\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _replaceTopContext(context) {\n    this._contextStack[this._contextStack.length - 1].context = context;\n  }\n\n  _checkStacks() {\n    if (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n      this._contextStack.pop();\n    }\n\n    if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n      this._partialStack.pop();\n    }\n\n    if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n      this._lambdaStack.pop();\n    }\n  }\n\n  _evaluate(name) {\n    if (name === '.') {\n      return this._contextStack[this._contextStack.length - 1].context;\n    }\n\n    const path = name.split('.');\n    for (let i = this._contextStack.length - 1; i >= 0; i--) {\n      const context = this._contextStack[i].context;\n      if (context === null || typeof context !== 'object') {\n        continue;\n      }\n\n      let current = context;\n      let resolved = true;\n      for (let pi = 0; pi < path.length; pi++) {\n        const key = path[pi];\n        if (current.hasOwnProperty(key)) {\n          current = current[key];\n        } else {\n          resolved = false;\n          break;\n        }\n      }\n\n      if (resolved) {\n        return current;\n      }\n    }\n    return '';\n  }\n\n  _getParsedPartial(name) {\n    if (this._partialCached.hasOwnProperty(name)) {\n      return this._partialCached[name];\n    } else {\n      if (!this._partials.hasOwnProperty(name)) {\n        return null;\n      }\n      const ast = this._parse(this._partials[name], { filename: name });\n      const nodes = this._partialCached[name] = ast.children;\n      return nodes;\n    }\n  }\n\n  _expandPartial(node) {\n    const { name } = node;\n    const nodes = this._getParsedPartial(name);\n\n    if (nodes === null) {\n      //The empty string should be used when the named partial is not found.\n      return;\n    }\n\n    this._pushPartial(node);\n\n    if (this._partialStack.length > MAX_PARTIAL_STACK) {\n      this._throw(\n        'Possible partial short circuit: ' +\n          this._partialStack.map(f => `${f.name}@${f.location.filename}:${f.location.line+1}`).concat([name]).join(' -> '),\n        node.location\n      );\n    }\n\n    this._pushNodes(nodes);\n  }\n\n  _expandLambda(node, lambda) {\n    const { name } = node;\n\n    this._pushLambda(node);\n\n    if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n      this._throw(\n        'Possible lambda short circuit: ' +\n          this._lambdaStack.map(f => `${f.name}@${f.location.filename}:${f.location.line+1}`).concat([name]).join(' -> '),\n        node.location\n      );\n    }\n\n    let ast;\n    let skipped = false;\n    if (node.type === nodeTypes.VARIABLE) {\n      const code = lambda();\n      if (code) {\n        //A lambda's return value should parse with the default delimiters.\n        ast = this._parse('' + code, { filename: '[lambda]' });\n        if (!node.unescaped) {\n          //Lambda results should be appropriately escaped.\n          walk(ast, node => {\n            if (node.type === nodeTypes.TEXT) {\n              node.text = escapeHTML(node.text);\n            }\n          });\n        }\n      } else {\n        skipped = true;\n      }\n    } else if (node.type === nodeTypes.SECTION) {\n      const code = lambda(node.raw);\n      if (code) {\n        //Lambdas used for inverted sections should be considered truthy.\n        //Lambdas used for sections should parse with the current delimiters.\n        ast = this._parse('' + code, {\n          filename: '[#lambda]',\n          delimiters: this._delimiters.slice(0)\n        });\n      } else {\n        skipped = true;\n      }\n    }\n\n    if (!skipped) {\n      this._pushNodes(ast.children);\n    }\n  }\n\n  _throw(message, location) {\n    const e = new Error(message);\n    e.location = location;\n    throw e;\n  }\n}\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == '[object Function]';\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/renderer.js\n **/","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/escape-html/index.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":""}