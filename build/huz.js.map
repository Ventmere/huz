{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///huz.js","webpack:///webpack/bootstrap 8d72c3c871219142c1fd","webpack:///./src/extension.js","webpack:///./src/token.js","webpack:///./src/helpers.js","webpack:///./src/node.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js","webpack:///./src/extensions/inheritance.js","webpack:///./src/renderer.js","webpack:///./src/index.js","webpack:///./~/escape-html/index.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","instantiateAll","opts","registry","map","ctor","register","constructor","push","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Extension","token","parserContext","node","renderContext","result","nodeResult","EOF","TEXT","PARTIAL","INVERTED_SECTION_OPEN","SECTION_OPEN","SECTION_CLOSE","UNESCAPED_VARIABLE","COMMENT","VARIABLE","DELIMITER_CHANGE","walk","modifier","stack","children","slice","reverse","pop","undefined","concat","visit","visitor","_parent","child","modified","trimStandaloneToken","tokens","count","open","inline","standalone","indentTokens","type","TokenType","isStringWhitespace","text","tailWSNodeCount","indent","forEach","t","str","test","_token","obj","newObj","ROOT","SECTION","_interopRequireWildcard","_node","NodeType","_tokenizer","_extension","ParserContext","parser","_parser","_appendNode","_pushParent","_popParent","_lastParent","message","_throw","_filename","_stack","Parser","arguments","_delimiters","delimiters","_extensions","extensions","filename","_parserContext","_lastToken","_src","src","rootNode","_parseNodes","_addNodeToken","location","JSON","parse","stringify","beginLocation","endLocation","_clone","endIndex","endLine","initialStackSize","z","Tokenizer","getNextToken","error","handled","ext","handleToken","_makeLocation","unescaped","_handleSectionOpen","_handleSectionClose","_handleComment","join","e","Error","inverted","section","raw","index","content","extractNewDelimiters","tagContent","matches","match","R_DELIMITER_CHANGE","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","Array","isArray","_helpers","STATE_NONE","_index","_char","_tokens","_line","_column","_state","_error","_location","line","column","shift","matched","_markTokenStartLocation","_read","_handleEOF","_handleText","_handleTextBreak","_handleTag","_markTokenEndLocation","_isDelimiter","_handleStandaloneTag","_makeToken","left","right","_skip","_skipAllWhitespaces","_setError","_handleEmptyTag","tagTypeChar","_handleVariableCurly","tagContentStart","_handleSimpleTag","substr","_handleDelimiterChange","_handleVariable","newDelimiters","_newDelimiters","trim","begin","_distance","console","log","_isWhitespace","endColumn","offset","delimiter","pos","transformToken","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","isInheritanceTagType","PARENT","BLOCK","_get","_x","_x2","_x3","_again","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_token2","Inheritance","_Extension","_blocks","_parentStack","pushParent","_pushBlock","tagNode","tailNode","popParent","appendNode","firstLine","firstBlock","find","blockNode","top","f","rendererContext","_checkTop","_handleParent","_handleBlock","lastParent","pushNodes","blocks","blockName","keys","_setDefaultBlocks","pushNode","defaultBlock","_getDefaultBlock","frame","topFrame","assign","isFunction","x","toString","nodeTypes","_escapeHtml","_escapeHtml2","default","RenderContext","renderer","_renderer","_evaluate","nodes","_pushNodes","_pushNode","ctx","_pushContext","_out","_parse","_getParsedPartial","Renderer","_this","_parsed","parsed","_partials","partials","_renderContext","_partialCached","k","_contextStack","_partialStack","_lambdaStack","_transformNodeResult","reduce","r","transformNodeResult","context","_this2","node_count","newline","handleNode","splice","partial","_popNode","_expandLambda","isList","testResult","_pushRepeaterNode","_expandPartial","repeat","repeatIndex","contextIndex","contexts","_replaceContextAt","_checkStacks","transformResult","list","sp","RangeError","_ref","_ref2","path","split","current","resolved","pi","ast","_pushPartial","lambda","_pushLambda","skipped","code","compile","render","Helpers","_extensionsInheritance","escapeHtml","string","matchHtmlRegExp","exec","escape","html","lastIndex","charCodeAt","substring"],"mappings":"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","file":"huz.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.instantiateAll = instantiateAll;\nexports.register = register;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar registry = [];\n\nvar Extension = (function () {\n  function Extension() {\n    _classCallCheck(this, Extension);\n  }\n\n  _createClass(Extension, [{\n    key: \"transformToken\",\n\n    //called by tokenizer\n    value: function transformToken(token) {\n      return token;\n    }\n\n    //called by parser\n  }, {\n    key: \"handleToken\",\n    value: function handleToken(token, parserContext) {}\n  }, {\n    key: \"visit\",\n    value: function visit(root) {\n      return root;\n    }\n\n    //called by renderer\n  }, {\n    key: \"handleNode\",\n    value: function handleNode(node, renderContext) {}\n  }, {\n    key: \"transformNodeResult\",\n    value: function transformNodeResult(node, result, nodeResult) {\n      return nodeResult;\n    }\n  }, {\n    key: \"transformResult\",\n    value: function transformResult(result) {\n      return result;\n    }\n  }]);\n\n  return Extension;\n})();\n\nexports.Extension = Extension;\n\nfunction instantiateAll(opts) {\n  return registry.map(function (ctor) {\n    return new ctor(opts);\n  });\n}\n\nfunction register(constructor) {\n  return registry.push(constructor);\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar EOF = 'EOF';\nexports.EOF = EOF;\nvar TEXT = 'TEXT';\nexports.TEXT = TEXT;\nvar PARTIAL = 'PARTIAL';\nexports.PARTIAL = PARTIAL;\nvar INVERTED_SECTION_OPEN = 'INVERTED_SECTION_OPEN';\nexports.INVERTED_SECTION_OPEN = INVERTED_SECTION_OPEN;\nvar SECTION_OPEN = 'SECTION_OPEN';\nexports.SECTION_OPEN = SECTION_OPEN;\nvar SECTION_CLOSE = 'SECTION_CLOSE';\nexports.SECTION_CLOSE = SECTION_CLOSE;\nvar UNESCAPED_VARIABLE = 'UNESCAPED_VARIABLE';\nexports.UNESCAPED_VARIABLE = UNESCAPED_VARIABLE;\nvar COMMENT = 'COMMENT';\nexports.COMMENT = COMMENT;\nvar VARIABLE = 'VARIABLE';\nexports.VARIABLE = VARIABLE;\nvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\nexports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.walk = walk;\nexports.visit = visit;\nexports.trimStandaloneToken = trimStandaloneToken;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nfunction walk(root, modifier) {\n  var stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    var node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nfunction visit(root, visitor) {\n  var stack = [root];\n  while (stack.length) {\n    var _parent = stack.pop();\n    for (var i = 0; i < _parent.children.length; i++) {\n      var child = _parent.children[i];\n      var modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        _parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nfunction trimStandaloneToken(tokens) {\n  var count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  var open = null;\n  var inline = 0;\n  var standalone = true;\n  var indentTokens = [];\n  for (var i = 0; standalone && i < count; i++) {\n    var token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline++;\n        }\n        break;\n      default:\n        //section-like tags\n        if (open === null) {\n          open = [token];\n          inline++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n\n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    var tailWSNodeCount = 0;\n    for (var i = count - 1; i >= 0; i--) {\n      var token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        var indent = '';\n        indentTokens.forEach(function (t) {\n          indent += t.text;\n        });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return (/^\\s*$/.test(str)\n  );\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar ROOT = 'ROOT';\nexports.ROOT = ROOT;\nvar VARIABLE = 'VARIABLE';\nexports.VARIABLE = VARIABLE;\nvar SECTION = 'SECTION';\nexports.SECTION = SECTION;\nvar TEXT = 'TEXT';\nexports.TEXT = TEXT;\nvar COMMENT = 'COMMENT';\nexports.COMMENT = COMMENT;\nvar PARTIAL = 'PARTIAL';\nexports.PARTIAL = PARTIAL;\nvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\nexports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _tokenizer = __webpack_require__(5);\n\nvar _helpers = __webpack_require__(2);\n\nvar _extension = __webpack_require__(0);\n\nvar ParserContext = (function () {\n  function ParserContext(parser) {\n    _classCallCheck(this, ParserContext);\n\n    this._parser = parser;\n  }\n\n  _createClass(ParserContext, [{\n    key: \"appendNode\",\n    value: function appendNode(node) {\n      this._parser._appendNode(node);\n    }\n  }, {\n    key: \"pushParent\",\n    value: function pushParent(node) {\n      this._parser._pushParent(node);\n    }\n  }, {\n    key: \"popParent\",\n    value: function popParent() {\n      return this._parser._popParent();\n    }\n  }, {\n    key: \"lastParent\",\n    value: function lastParent() {\n      return this._parser._lastParent;\n    }\n  }, {\n    key: \"lastParentType\",\n    value: function lastParentType() {\n      return this._parser._lastParent ? this._parser._lastParent.type : null;\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(message) {\n      return this._parser._throw(message);\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._parser._filename;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._parser._stack.length;\n    }\n  }, {\n    key: \"tailNode\",\n    get: function get() {\n      return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n    }\n  }]);\n\n  return ParserContext;\n})();\n\nvar Parser = (function () {\n  function Parser() {\n    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, Parser);\n\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n    this._filename = opts.filename || \"\";\n    this._lastParent = null;\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(src) {\n      var rootNode = {\n        type: NodeType.ROOT,\n        children: []\n      };\n      this._src = src;\n      this._stack = [rootNode];\n      this._lastToken = null;\n      this._parseNodes(src);\n\n      if (this._extensions.length > 0) {\n        for (var i = 0; i < this._extensions.length; i++) {\n          this._extensions[i].visit(rootNode);\n        }\n      }\n\n      return rootNode;\n    }\n  }, {\n    key: \"_addNodeToken\",\n    value: function _addNodeToken(node) {\n      var token = this._lastToken;\n      if (node.tokens) {\n        node.tokens.push(token);\n      } else {\n        node.tokens = [token];\n      }\n    }\n  }, {\n    key: \"_appendNode\",\n    value: function _appendNode(node) {\n      this._addNodeToken(node);\n      node.location.filename = this._filename;\n      this._stack[this._stack.length - 1].children.push(node);\n      return node;\n    }\n  }, {\n    key: \"_getTop\",\n    value: function _getTop() {\n      return this._stack[this._stack.length - 1];\n    }\n  }, {\n    key: \"_clone\",\n    value: function _clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  }, {\n    key: \"_makeLocation\",\n    value: function _makeLocation(beginLocation, endLocation) {\n      var location = this._clone(beginLocation);\n      if (endLocation) {\n        location.endIndex = endLocation.endIndex;\n        location.endLine = endLocation.endLine;\n      }\n      return location;\n    }\n  }, {\n    key: \"_parseNodes\",\n    value: function _parseNodes(src) {\n      var initialStackSize = this._stack.length;\n      var token = undefined;\n      var z = new _tokenizer.Tokenizer(src, {\n        delimiters: this._delimiters.slice(0),\n        extensions: this._extensions,\n        filename: this._filename\n      });\n\n      do {\n        token = z.getNextToken();\n\n        if (z.error !== null) {\n          throw z.error;\n        }\n\n        this._lastToken = token;\n\n        var handled = false;\n        if (this._extensions) {\n          for (var i = 0; i < this._extensions.length; i++) {\n            var ext = this._extensions[i];\n            if (ext.handleToken(token, this._parserContext) === true) {\n              handled = true;\n              break;\n            }\n          }\n        }\n\n        if (!handled) {\n          switch (token.type) {\n            case TokenType.TEXT:\n              this._appendNode({\n                type: NodeType.TEXT,\n                text: token.text,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.VARIABLE:\n            case TokenType.UNESCAPED_VARIABLE:\n              this._appendNode({\n                type: NodeType.VARIABLE,\n                name: token.name,\n                unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.SECTION_OPEN:\n              this._handleSectionOpen(token);\n              break;\n\n            case TokenType.INVERTED_SECTION_OPEN:\n              this._handleSectionOpen(token, true);\n              break;\n\n            case TokenType.SECTION_CLOSE:\n              this._handleSectionClose(token);\n              break;\n\n            case TokenType.PARTIAL:\n              this._appendNode({\n                type: NodeType.PARTIAL,\n                name: token.name,\n                indent: token.indent,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.COMMENT:\n              this._handleComment(token);\n              break;\n\n            case TokenType.DELIMITER_CHANGE:\n              this._appendNode({\n                type: NodeType.DELIMITER_CHANGE,\n                delimiters: token.delimiters,\n                location: this._makeLocation(token.location)\n              });\n              break;\n          }\n        }\n      } while (token.type !== TokenType.EOF);\n\n      if (this._stack.length > initialStackSize) {\n        this._throw(\"Unexpected EOF: sections not closed: \" + this._stack.slice(initialStackSize).map(function (n) {\n          return \"'\" + n.name + \"'\";\n        }).join(\", \"));\n      } else if (this._stack.length < initialStackSize) {\n        this._throw(\"Internal error.\");\n      }\n    }\n  }, {\n    key: \"_throw\",\n    value: function _throw(message) {\n      var e = new Error(message);\n      e.filename = this._lastToken.filename;\n      e.location = this._lastToken.location;\n      throw e;\n    }\n  }, {\n    key: \"_pushParent\",\n    value: function _pushParent(node) {\n      this._addNodeToken(node);\n      node.children = [];\n      this._stack.push(node);\n      this._lastParent = node;\n    }\n  }, {\n    key: \"_popParent\",\n    value: function _popParent() {\n      return this._stack.pop();\n    }\n  }, {\n    key: \"_handleSectionOpen\",\n    value: function _handleSectionOpen(token) {\n      var inverted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n      var name = token.name;\n      var location = token.location;\n\n      this._pushParent({\n        type: NodeType.SECTION,\n        name: name,\n        inverted: inverted,\n        location: location\n      });\n    }\n  }, {\n    key: \"_handleSectionClose\",\n    value: function _handleSectionClose(token) {\n      var name = token.name;\n      var location = token.location;\n\n      var section = this._popParent();\n      if (section.type !== NodeType.SECTION) {\n        this._throw(\"Unexpected SECTION_CLOSE: '\" + name + \"'\");\n      }\n\n      if (section.name !== name) {\n        this._throw(\"Unexpected SECTION_CLOSE: '\" + name + \"', current section: '\" + section.name + \"'\");\n      }\n\n      section.raw = this._src.slice(section.location.endIndex, location.index);\n      section.location = this._makeLocation(section.location, token.location);\n\n      this._appendNode(section);\n    }\n  }, {\n    key: \"_handleComment\",\n    value: function _handleComment(token) {\n      var content = token.content;\n      var location = token.location;\n\n      this._appendNode({\n        type: NodeType.COMMENT,\n        content: content,\n        location: this._makeLocation(location)\n      });\n    }\n  }]);\n\n  return Parser;\n})();\n\nexports.Parser = Parser;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _extension = __webpack_require__(0);\n\nvar _helpers = __webpack_require__(2);\n\nvar STATE_NONE = 'STATE_NONE';\nvar STATE_EOF = 'STATE_EOF';\nvar STATE_TEXT = 'STATE_TEXT';\nvar STATE_TEXT_BREAK = 'STATE_TEXT_BREAK';\nvar STATE_TAG = 'STATE_TAG';\n\nvar DELIMITER_LEFT = 0;\nvar DELIMITER_RIGHT = 1;\n\nvar Tokenizer = (function () {\n  function Tokenizer(src) {\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Tokenizer);\n\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 0;\n    this._column = 0;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n  }\n\n  _createClass(Tokenizer, [{\n    key: 'getNextToken',\n    value: function getNextToken() {\n      if (this._tokens.length > 0) {\n        return this._tokens.shift();\n      }\n\n      var done = false;\n      var matched = false;\n      do {\n        //console.log(this._state, this._tokens);\n        if (this._error !== null) {\n          return null;\n        }\n\n        if (this._state !== STATE_NONE) {\n          matched = true;\n          this._markTokenStartLocation();\n        }\n\n        switch (this._state) {\n          case STATE_NONE:\n            this._read();\n            break;\n\n          case STATE_EOF:\n            this._handleEOF();\n            done = true;\n            break;\n\n          case STATE_TEXT:\n            this._handleText();\n            break;\n\n          case STATE_TEXT_BREAK:\n            this._handleTextBreak();\n            done = true;\n            break;\n\n          case STATE_TAG:\n            this._handleTag();\n            break;\n        }\n\n        if (matched && !this._error) {\n          this._markTokenEndLocation();\n          matched = false;\n        }\n\n        if (this._state === STATE_NONE) {\n          if (this._char === null) {\n            this._state = STATE_EOF;\n          } else if (this._char === '\\n') {\n            this._state = STATE_TEXT_BREAK;\n          } else if (this._isDelimiter(DELIMITER_LEFT)) {\n            this._state = STATE_TAG;\n          } else {\n            this._state = STATE_TEXT;\n          }\n        }\n      } while (!done);\n\n      return this._error === null ? this._tokens.shift() : null;\n    }\n\n    // Handlers\n\n  }, {\n    key: '_handleEOF',\n    value: function _handleEOF() {\n      this._handleStandaloneTag();\n      this._makeToken({\n        type: TokenType.EOF\n      });\n    }\n  }, {\n    key: '_handleTag',\n    value: function _handleTag() {\n      var _delimiters = _slicedToArray(this._delimiters, 2);\n\n      var left = _delimiters[0];\n      var right = _delimiters[1];\n\n      this._skip(left.length);\n      this._skipAllWhitespaces();\n\n      if (this._char === null) {\n        this._setError('Unclosed tag.');\n      } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n        this._handleEmptyTag();\n      } else {\n        var tagTypeChar = this._char;\n        if (tagTypeChar === '{') {\n          this._handleVariableCurly();\n        } else {\n          var tagContentStart = this._index - 1;\n          //read content\n          while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n            this._read();\n          }\n\n          if (this._char === null) {\n            this._setError('Unclosed tag.');\n          } else {\n            var content = this._src.slice(tagContentStart, this._index - 1);\n            switch (tagTypeChar) {\n              case '>':\n                this._handleSimpleTag(TokenType.PARTIAL, content);break;\n              case '^':\n                this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);break;\n              case '#':\n                this._handleSimpleTag(TokenType.SECTION_OPEN, content);break;\n              case '/':\n                this._handleSimpleTag(TokenType.SECTION_CLOSE, content);break;\n\n              case '!':\n                this._handleComment(content.substr(1));\n                break;\n\n              case '=':\n                this._handleDelimiterChange(content);\n                break;\n              case '&':\n                this._handleVariable(content.substr(1), true);\n                break;\n              default:\n                this._handleVariable(content);\n                break;\n            }\n          }\n        }\n      }\n      if (this._error === null) {\n        //eat right\n        for (var i = 0; i < right.length; i++) {\n          this._read();\n        }\n      }\n\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: '_handleDelimiterChange',\n    value: function _handleDelimiterChange(content) {\n      var newDelimiters = extractNewDelimiters(content);\n      if (newDelimiters === null) {\n        this._setError('Invalid change delimiter syntax.');\n      } else {\n        var _newDelimiters = _slicedToArray(newDelimiters, 2);\n\n        var left = _newDelimiters[0];\n        var right = _newDelimiters[1];\n\n        this._delimiters = newDelimiters;\n        this._makeToken({\n          type: TokenType.DELIMITER_CHANGE,\n          delimiters: [left, right]\n        });\n      }\n    }\n  }, {\n    key: '_handleSimpleTag',\n    value: function _handleSimpleTag(type, content) {\n      this._makeToken({ type: type, name: content.substr(1).trim() });\n    }\n  }, {\n    key: '_handleComment',\n    value: function _handleComment(content) {\n      this._makeToken({\n        type: TokenType.COMMENT,\n        content: content\n      });\n    }\n  }, {\n    key: '_handleVariableCurly',\n    value: function _handleVariableCurly() {\n      this._read(); //eat '{'\n      var begin = this._index - 1;\n      var d = this._distance('}');\n      if (d === -1) {\n        this._setError('Unclosed variable tag: missingright curly.');\n      } else {\n        var content = this._src.slice(begin, begin + d);\n        this._skip(d + 1); //skip '}'\n        this._skipAllWhitespaces();\n        if (!this._isDelimiter(DELIMITER_RIGHT)) {\n          this._setError('Unclosed variable: missing right delimiter.');\n        } else {\n          this._makeToken({\n            type: TokenType.UNESCAPED_VARIABLE,\n            name: content.trim()\n          });\n        }\n      }\n    }\n  }, {\n    key: '_handleEmptyTag',\n    value: function _handleEmptyTag() {\n      this._makeToken({\n        type: TokenType.VARIABLE,\n        name: ''\n      });\n    }\n  }, {\n    key: '_handleVariable',\n    value: function _handleVariable(content, unescaped) {\n      this._makeToken({\n        type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n        name: content.trim()\n      });\n    }\n  }, {\n    key: '_handleText',\n    value: function _handleText() {\n      var done = false;\n      var index = this._index - 1;\n      var length = 0;\n      do {\n        var c = this._char;\n\n        if (c === null || c === '\\n' || this._isDelimiter(DELIMITER_LEFT)) {\n          done = true;\n        } else {\n          length++;\n        }\n\n        if (!done) {\n          this._read();\n        }\n      } while (!done);\n\n      this._makeToken({\n        type: TokenType.TEXT,\n        text: this._src.slice(index, index + length)\n      });\n\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: '_handleTextBreak',\n    value: function _handleTextBreak() {\n      this._makeToken({\n        type: TokenType.TEXT,\n        text: '\\n'\n      });\n      this._read();\n      this._handleStandaloneTag();\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: '_handleStandaloneTag',\n    value: function _handleStandaloneTag() {\n      this._tokens = (0, _helpers.trimStandaloneToken)(this._tokens);\n    }\n\n    // Helpers\n  }, {\n    key: '_dump',\n    value: function _dump() {\n      var t = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n      console.log(t + '>' + this._src.slice(this._index - 1));\n    }\n  }, {\n    key: '_read',\n    value: function _read() {\n      if (this._index < this._src.length) {\n        if (this._char === '\\n') {\n          this._line++;\n          this._column = 0;\n        } else {\n          this._column++;\n        }\n\n        this._char = this._src[this._index];\n        this._index++;\n      } else {\n        this._char = null;\n      }\n    }\n  }, {\n    key: '_peek',\n    value: function _peek() {\n      if (this._index < this._src.length - 1) {\n        return this._src[this._index];\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: '_skip',\n    value: function _skip(n) {\n      for (var i = 0; i < n; i++) {\n        this._read();\n      }\n    }\n  }, {\n    key: '_distance',\n    value: function _distance(c) {\n      for (var i = this._index; i < this._src.length; i++) {\n        if (this._src[i] === c) {\n          return i - this._index + 1;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: '_skipAllWhitespaces',\n    value: function _skipAllWhitespaces() {\n      while (this._isWhitespace()) {\n        this._read();\n      }\n    }\n  }, {\n    key: '_markTokenStartLocation',\n    value: function _markTokenStartLocation() {\n      this._location.index = this._index - 1;\n      this._location.line = this._line;\n      this._location.column = this._column;\n    }\n  }, {\n    key: '_markTokenEndLocation',\n    value: function _markTokenEndLocation() {\n      var token = this._tokens[this._tokens.length - 1];\n      token.location.endIndex = this._index - 1;\n      token.location.endLine = this._line;\n      token.location.endColumn = this._column;\n    }\n  }, {\n    key: '_isWhitespace',\n    value: function _isWhitespace() {\n      return (/\\s/.test(this._char)\n      );\n    }\n  }, {\n    key: '_isDelimiter',\n    value: function _isDelimiter(d) {\n      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      var delimiter = this._delimiters[d];\n      var pos = this._index - 1 + offset;\n      return this._src.slice(pos, pos + delimiter.length) === delimiter;\n    }\n  }, {\n    key: '_makeToken',\n    value: function _makeToken(token) {\n      token.filename = this._filename;\n      var _location = this._location;\n      var index = _location.index;\n      var line = _location.line;\n      var column = _location.column;\n\n      token.location = {\n        index: index, line: line, column: column\n      };\n      if (this._extensions.length) {\n        try {\n          this._extensions.forEach(function (ext) {\n            token = ext.transformToken(token);\n          });\n        } catch (e) {\n          this._setError(e.message);\n          return;\n        }\n      }\n      this._tokens.push(token);\n    }\n  }, {\n    key: '_setError',\n    value: function _setError(message) {\n      var error = new Error(message);\n      error.filename = this._filename;\n      error.index = this._index - 1;\n      error.line = this._line;\n      error.column = this._column;\n      this._error = error;\n    }\n  }, {\n    key: 'error',\n    get: function get() {\n      return this._error;\n    }\n  }]);\n\n  return Tokenizer;\n})();\n\nexports.Tokenizer = Tokenizer;\n\nvar R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  var matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// https://github.com/mustache/spec/pull/75\n\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _extension = __webpack_require__(0);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _token2 = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token2);\n\nvar PARENT = \"Inheritance.PARENT\";\nvar BLOCK = \"Inheritance.BLOCK\";\nvar LEAVE_SCOPE = \"Inheritance.LEAVE_SCOPE\";\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nvar Inheritance = (function (_Extension) {\n  _inherits(Inheritance, _Extension);\n\n  function Inheritance() {\n    _classCallCheck(this, Inheritance);\n\n    _get(Object.getPrototypeOf(Inheritance.prototype), \"constructor\", this).call(this);\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  _createClass(Inheritance, [{\n    key: \"transformToken\",\n    value: function transformToken(token) {\n      var _token = token;\n      var type = _token.type;\n      var name = _token.name;\n      var location = _token.location;\n\n      switch (type) {\n        case TokenType.VARIABLE:\n          if (name) {\n            if (name[0] === \"<\") {\n              if (name.length === 1) {\n                throw new Error(\"Parent partial name expected\");\n              }\n              token = {\n                type: PARENT,\n                name: name.slice(1),\n                location: location\n              };\n            } else if (name[0] === \"$\") {\n              if (name.length === 1) {\n                throw new Error(\"Block name expected\");\n              }\n              token = {\n                type: BLOCK,\n                name: name.slice(1),\n                location: location\n              };\n            }\n          }\n          break;\n      }\n      return token;\n    }\n  }, {\n    key: \"handleToken\",\n    value: function handleToken(token, parserContext) {\n      var handled = false;\n      var name = token.name;\n      var location = token.location;\n      var type = token.type;\n\n      switch (type) {\n        case PARENT:\n          parserContext.pushParent({\n            type: PARENT,\n            name: name,\n            location: location\n          });\n          handled = true;\n          break;\n\n        case BLOCK:\n          this._pushBlock({\n            type: BLOCK,\n            name: name,\n            location: location\n          }, parserContext);\n          break;\n\n        case TokenType.SECTION_CLOSE:\n          var tagNode = parserContext.tailNode;\n          if (tagNode === null) {\n            if (isInheritanceTagType(tagNode.type)) {\n              parserContext[\"throw\"](\"Unexpected tag close\");\n            }\n          } else {\n            if (tagNode.name !== name) {\n              parserContext[\"throw\"](\"Unexpected tag close, current tag: \" + tagNode.name);\n            }\n            if (isInheritanceTagType(tagNode.type)) {\n              parserContext.popParent();\n              tagNode.location.endIndex = location.endIndex;\n              tagNode.location.endLine = location.endLine;\n              parserContext.appendNode(tagNode);\n\n              //TODO move this to visit, handle whitespaces after Parent close tag.\n              var firstLine = tagNode.location.line;\n              var firstBlock = tagNode.children.find(function (c) {\n                return c.type === BLOCK;\n              });\n              if (firstBlock && firstBlock.location.line === firstLine) {\n                for (var i = 0; i < firstBlock.children.length; i++) {\n                  var blockNode = firstBlock.children[i];\n                  if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n                    blockNode.text = \"\";\n                  } else {\n                    break;\n                  }\n                }\n              }\n\n              handled = true;\n            }\n          }\n          break;\n\n        case TokenType.EOF:\n          if (this.top > 0) {\n            parserContext[\"throw\"](\"Unexpected EOF: tags not closed: \" + this.stack.map(function (f) {\n              return f.name;\n            }).join(\", \"));\n          }\n          break;\n      }\n      return handled;\n    }\n  }, {\n    key: \"handleNode\",\n    value: function handleNode(node, rendererContext) {\n      var top = rendererContext.top;\n      this._checkTop(top);\n\n      switch (node.type) {\n        case PARENT:\n          this._handleParent(node, rendererContext);\n          return true;\n\n        case BLOCK:\n          this._handleBlock(node, rendererContext);\n          return true;\n\n        case LEAVE_SCOPE:\n          this._blocks = null;\n          return true;\n      }\n    }\n  }, {\n    key: \"_pushBlock\",\n    value: function _pushBlock(node, parserContext) {\n      var parent = parserContext.lastParent();\n      if (parent && parent.type === BLOCK && parent.name === node.name) {\n        parserContext[\"throw\"](\"Recursive block: '\" + node.name + \"'\");\n      }\n      parserContext.pushParent(node);\n    }\n  }, {\n    key: \"_handleParent\",\n    value: function _handleParent(node, rendererContext) {\n      var name = node.name;\n      var location = node.location;\n\n      var top = rendererContext.top;\n\n      this._pushParent(name, top);\n\n      if (this._blocks === null) {\n        rendererContext.pushNodes([{\n          type: LEAVE_SCOPE\n        }]);\n        this._blocks = {};\n      }\n\n      //find all blocks defined in parent\n      var blocks = {};\n      node.children.forEach(function (child) {\n        if (child.type === BLOCK) {\n          var blockName = child.name;\n          blocks[blockName] = child;\n        }\n      });\n      if (Object.keys(blocks).length) {\n        this._setDefaultBlocks(blocks);\n      }\n\n      rendererContext.pushNode({\n        type: TokenType.PARTIAL,\n        name: name,\n        location: location,\n        indent: node.indent\n      });\n    }\n  }, {\n    key: \"_handleBlock\",\n    value: function _handleBlock(node, rendererContext) {\n      var name = node.name;\n\n      var defaultBlock = this._getDefaultBlock(name);\n      if (defaultBlock) {\n        rendererContext.pushNodes(defaultBlock.children);\n      } else {\n        rendererContext.pushNodes(node.children);\n      }\n    }\n  }, {\n    key: \"_pushParent\",\n    value: function _pushParent(name, top) {\n      return this._parentStack.push({\n        name: name,\n        blocks: {},\n        top: top\n      });\n    }\n  }, {\n    key: \"_checkTop\",\n    value: function _checkTop(top) {\n      var pop = 0;\n      for (var i = this._parentStack.length - 1; i >= 0; i--) {\n        var frame = this._parentStack[i];\n        if (frame.top > top) {\n          pop++;\n        } else {\n          break;\n        }\n      }\n      if (pop > 0) {\n        this._parentStack = this._parentStack.slice(0, this._parentStack.length - pop);\n      }\n    }\n  }, {\n    key: \"_popParent\",\n    value: function _popParent() {\n      return this._parentStack.pop();\n    }\n  }, {\n    key: \"_getDefaultBlock\",\n    value: function _getDefaultBlock(name) {\n      for (var i = 0; i < this._parentStack.length; i++) {\n        var frame = this._parentStack[i];\n        if (name in frame.blocks) {\n          return frame.blocks[name];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_setDefaultBlocks\",\n    value: function _setDefaultBlocks(blocks) {\n      var topFrame = this._parentStack[this._parentStack.length - 1];\n      topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n    }\n  }]);\n\n  return Inheritance;\n})(_extension.Extension);\n\nexports.Inheritance = Inheritance;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _node = __webpack_require__(3);\n\nvar nodeTypes = _interopRequireWildcard(_node);\n\nvar _escapeHtml = __webpack_require__(9);\n\nvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\nvar _parser = __webpack_require__(4);\n\nvar _helpers = __webpack_require__(2);\n\nvar _extension = __webpack_require__(0);\n\nvar REPEATER_NODE_TYPE = \"_REPEATER\";\nvar MAX_PARTIAL_STACK = 10;\nvar MAX_LAMBDA_STACK = 255;\nvar MAX_NODE_COUNT = 3000;\n\nvar RenderContext = (function () {\n  function RenderContext(renderer) {\n    _classCallCheck(this, RenderContext);\n\n    this._renderer = renderer;\n  }\n\n  _createClass(RenderContext, [{\n    key: \"evaluate\",\n    value: function evaluate(name) {\n      return this._renderer._evaluate(name);\n    }\n  }, {\n    key: \"pushNodes\",\n    value: function pushNodes(nodes) {\n      this._renderer._pushNodes(nodes);\n    }\n  }, {\n    key: \"pushNode\",\n    value: function pushNode(node) {\n      this._renderer._pushNode(node);\n    }\n  }, {\n    key: \"pushContext\",\n    value: function pushContext(ctx) {\n      this._renderer._pushContext(ctx);\n    }\n  }, {\n    key: \"appendText\",\n    value: function appendText(text) {\n      this._renderer._out += text;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(src, opts) {\n      return this._renderer._parse(src, opts);\n    }\n  }, {\n    key: \"getParsedPartial\",\n    value: function getParsedPartial(name) {\n      return this._renderer._getParsedPartial(name);\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(message, location) {\n      return this._renderer._throw(message, location);\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._renderer._stack.length;\n    }\n  }, {\n    key: \"result\",\n    get: function get() {\n      return this._renderer._out;\n    }\n  }]);\n\n  return RenderContext;\n})();\n\nvar Renderer = (function () {\n  function Renderer(src) {\n    var _this = this;\n\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Renderer);\n\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(function (k) {\n        _this._partialCached[k] = _this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = \"\";\n    this._transformNodeResult = function (node, result, nodeResult) {\n      return _this._extensions.reduce(function (r, e) {\n        return e.transformNodeResult(node, result, r);\n      }, nodeResult);\n    };\n  }\n\n  _createClass(Renderer, [{\n    key: \"render\",\n    value: function render(context) {\n      var _this2 = this;\n\n      this._out = \"\";\n      this._stack = [];\n      this._contextStack = [];\n      this._partialStack = [];\n      this._lambdaStack = [];\n\n      this._pushContext(context);\n\n      //push root nodes\n      var rootNode = this._parsed ? this._src : this._parse(this._src);\n      this._stack = rootNode.children.slice(0).reverse();\n\n      var node_count = 0;\n\n      var newline = true;\n\n      var _loop = function () {\n        var top = _this2._stack.length - 1;\n        var node = _this2._stack[top];\n\n        if (node.type !== nodeTypes.TEXT) {\n          node_count++;\n          if (node_count > MAX_NODE_COUNT) {\n            _this2._throw(\"Possible infinity loop detected: last node type is '\" + node.type + \"'\", node.location);\n          }\n        }\n\n        var handled = false;\n        if (_this2._extensions) {\n          _this2._extensions.forEach(function (ext) {\n            if (ext.handleNode(node, _this2._renderContext)) {\n              handled = true;\n            }\n          });\n        }\n\n        if (handled) {\n          _this2._stack.splice(top, 1);\n        } else {\n          var partial = _this2._partialStack.length ? _this2._partialStack[_this2._partialStack.length - 1] : null;\n\n          //insert indent\n          if (node.type in nodeTypes) {\n            if (newline && partial !== null && partial.indent.length > 0) {\n              _this2._out += partial.indent;\n            }\n          }\n\n          var value = undefined;\n          switch (node.type) {\n            case nodeTypes.VARIABLE:\n              value = _this2._evaluate(node.name);\n              if (isFunction(value)) {\n                _this2._popNode();\n                _this2._expandLambda(node, value);\n              } else {\n                if (!!value) {\n                  var result = node.unescaped ? value : (0, _escapeHtml2[\"default\"])(value);\n                  _this2._out += _this2._transformNodeResult(node, _this2._out, result);\n                }\n                _this2._popNode();\n              }\n              break;\n\n            case nodeTypes.SECTION:\n              value = _this2._evaluate(node.name);\n              if (isFunction(value)) {\n                _this2._popNode();\n                _this2._expandLambda(node, value);\n              } else {\n                var isList = Array.isArray(value);\n\n                if (isList && value.length === 0) {\n                  //Empty lists should behave like falsey values.\n                  value = false;\n                  isList = false;\n                }\n\n                var testResult = !!value;\n                if (node.inverted) {\n                  testResult = !testResult;\n                }\n\n                if (testResult) {\n                  if (isList) {\n                    _this2._popNode();\n                    _this2._pushRepeaterNode(value.length, node.children, value);\n                  } else {\n                    _this2._popNode();\n                    _this2._pushContext(value);\n                    _this2._pushNodes(node.children);\n                  }\n                } else {\n                  _this2._popNode();\n                }\n              }\n              break;\n\n            case nodeTypes.TEXT:\n              _this2._out += _this2._transformNodeResult(node, _this2._out, node.text);\n              _this2._popNode();\n              break;\n\n            case nodeTypes.COMMENT:\n              _this2._popNode();\n              break;\n\n            case nodeTypes.PARTIAL:\n              _this2._popNode();\n              _this2._expandPartial(node);\n              break;\n\n            case nodeTypes.DELIMITER_CHANGE:\n              _this2._popNode();\n              _this2._delimiters = node.delimiters.slice(0);\n              break;\n\n            case REPEATER_NODE_TYPE:\n              if (node.count < node.repeat) {\n                var repeatIndex = node.count;\n                if (repeatIndex === 0) {\n                  node.contextIndex = _this2._pushContext(node.contexts[0]);\n                } else {\n                  _this2._replaceContextAt(node.contextIndex, node.contexts[repeatIndex]);\n                }\n                _this2._pushNodes(node.children);\n                node.count++;\n              } else {\n                _this2._popNode();\n              }\n              break;\n\n            default:\n              _this2._popNode();\n              break;\n          }\n        }\n        _this2._checkStacks();\n        newline = _this2._out.length === 0 || _this2._out[_this2._out.length - 1] === \"\\n\";\n      };\n\n      while (this._stack.length > 0) {\n        _loop();\n      }\n\n      return this._extensions.reduce(function (result, ext) {\n        return ext.transformResult(result);\n      }, this._out);\n    }\n  }, {\n    key: \"_parse\",\n    value: function _parse(src) {\n      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      opts.extensions = this._extensions;\n      var parser = new _parser.Parser(opts);\n      return parser.parse(src);\n    }\n  }, {\n    key: \"_pushNodes\",\n    value: function _pushNodes(list) {\n      for (var i = list.length - 1; i >= 0; i--) {\n        this._stack.push(list[i]);\n      }\n    }\n  }, {\n    key: \"_pushNode\",\n    value: function _pushNode(node) {\n      this._stack.push(node);\n    }\n  }, {\n    key: \"_popNode\",\n    value: function _popNode() {\n      this._stack.pop();\n    }\n  }, {\n    key: \"_pushRepeaterNode\",\n    value: function _pushRepeaterNode(repeat, nodes, contexts) {\n      this._stack.push({\n        type: REPEATER_NODE_TYPE,\n        count: 0,\n        repeat: repeat,\n        children: nodes.slice(0),\n        contexts: contexts\n      });\n    }\n  }, {\n    key: \"_pushContext\",\n    value: function _pushContext(context) {\n      return this._contextStack.push({\n        context: context,\n        sp: this._stack.length\n      }) - 1;\n    }\n  }, {\n    key: \"_replaceContextAt\",\n    value: function _replaceContextAt(index, context) {\n      if (index < 0 || index > this._contextStack.length - 1) {\n        throw new RangeError(\"Huz context index out of range.\");\n      }\n      this._contextStack[index].context = context;\n    }\n  }, {\n    key: \"_pushPartial\",\n    value: function _pushPartial(_ref) {\n      var name = _ref.name;\n      var indent = _ref.indent;\n      var location = _ref.location;\n\n      this._partialStack.push({\n        name: name,\n        indent: indent || \"\",\n        location: location,\n        sp: this._stack.length\n      });\n    }\n  }, {\n    key: \"_pushLambda\",\n    value: function _pushLambda(_ref2) {\n      var name = _ref2.name;\n      var location = _ref2.location;\n\n      this._lambdaStack.push({\n        name: name,\n        location: location,\n        sp: this._stack.length\n      });\n    }\n  }, {\n    key: \"_checkStacks\",\n    value: function _checkStacks() {\n      if (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n        this._contextStack.pop();\n      }\n\n      if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n        this._partialStack.pop();\n      }\n\n      if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n        this._lambdaStack.pop();\n      }\n    }\n  }, {\n    key: \"_evaluate\",\n    value: function _evaluate(name) {\n      if (name === \".\") {\n        return this._contextStack[this._contextStack.length - 1].context;\n      }\n\n      var path = name.split(\".\");\n      for (var i = this._contextStack.length - 1; i >= 0; i--) {\n        var context = this._contextStack[i].context;\n        if (context === null || typeof context !== \"object\") {\n          continue;\n        }\n\n        var current = context;\n        var resolved = true;\n        for (var pi = 0; pi < path.length; pi++) {\n          var key = path[pi];\n          if (typeof current === \"object\" && current !== null && current.hasOwnProperty(key)) {\n            current = current[key];\n          } else {\n            resolved = false;\n            break;\n          }\n        }\n\n        if (resolved) {\n          return current;\n        }\n      }\n      return \"\";\n    }\n  }, {\n    key: \"_getParsedPartial\",\n    value: function _getParsedPartial(name) {\n      if (this._partialCached.hasOwnProperty(name)) {\n        return this._partialCached[name];\n      } else {\n        if (!this._partials.hasOwnProperty(name)) {\n          return null;\n        }\n        var ast = this._parse(this._partials[name], { filename: name });\n        var nodes = this._partialCached[name] = ast.children;\n        return nodes;\n      }\n    }\n  }, {\n    key: \"_expandPartial\",\n    value: function _expandPartial(node) {\n      var name = node.name;\n\n      var nodes = this._getParsedPartial(name);\n\n      if (nodes === null) {\n        //The empty string should be used when the named partial is not found.\n        return;\n      }\n\n      this._pushPartial(node);\n\n      if (this._partialStack.length > MAX_PARTIAL_STACK) {\n        this._throw(\"Possible partial short circuit: \" + this._partialStack.map(function (f) {\n          return f.name + \"@\" + f.location.filename + \":\" + (f.location.line + 1);\n        }).concat([name]).join(\" -> \"), node.location);\n      }\n\n      this._pushNodes(nodes);\n    }\n  }, {\n    key: \"_expandLambda\",\n    value: function _expandLambda(node, lambda) {\n      var name = node.name;\n\n      this._pushLambda(node);\n\n      if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n        this._throw(\"Possible lambda short circuit: \" + this._lambdaStack.map(function (f) {\n          return f.name + \"@\" + f.location.filename + \":\" + (f.location.line + 1);\n        }).concat([name]).join(\" -> \"), node.location);\n      }\n\n      var ast = undefined;\n      var skipped = false;\n      if (node.type === nodeTypes.VARIABLE) {\n        var code = lambda();\n        if (code) {\n          //A lambda's return value should parse with the default delimiters.\n          ast = this._parse(\"\" + code, { filename: \"[lambda]\" });\n          if (!node.unescaped) {\n            //Lambda results should be appropriately escaped.\n            (0, _helpers.walk)(ast, function (node) {\n              if (node.type === nodeTypes.TEXT) {\n                node.text = (0, _escapeHtml2[\"default\"])(node.text);\n              }\n            });\n          }\n        } else {\n          skipped = true;\n        }\n      } else if (node.type === nodeTypes.SECTION) {\n        var code = lambda(node.raw);\n        if (code) {\n          //Lambdas used for inverted sections should be considered truthy.\n          //Lambdas used for sections should parse with the current delimiters.\n          ast = this._parse(\"\" + code, {\n            filename: \"[#lambda]\",\n            delimiters: this._delimiters.slice(0)\n          });\n        } else {\n          skipped = true;\n        }\n      }\n\n      if (!skipped) {\n        this._pushNodes(ast.children);\n      }\n    }\n  }, {\n    key: \"_throw\",\n    value: function _throw(message, location) {\n      var e = new Error(message);\n      e.location = location;\n      throw e;\n    }\n  }]);\n\n  return Renderer;\n})();\n\nexports.Renderer = Renderer;\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == \"[object Function]\";\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.parse = parse;\nexports.compile = compile;\nexports.render = render;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _parser = __webpack_require__(4);\n\nvar _renderer = __webpack_require__(7);\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _helpers = __webpack_require__(2);\n\nvar Helpers = _interopRequireWildcard(_helpers);\n\nvar _extension = __webpack_require__(0);\n\nvar _extensionsInheritance = __webpack_require__(6);\n\nvar _tokenizer = __webpack_require__(5);\n\nObject.defineProperty(exports, 'Tokenizer', {\n  enumerable: true,\n  get: function get() {\n    return _tokenizer.Tokenizer;\n  }\n});\nexports.Parser = _parser.Parser;\nexports.Renderer = _renderer.Renderer;\nexports.TokenType = TokenType;\nexports.NodeType = NodeType;\nObject.defineProperty(exports, 'Extension', {\n  enumerable: true,\n  get: function get() {\n    return _extension.Extension;\n  }\n});\n\n(0, _extension.register)(_extensionsInheritance.Inheritance);\n\nfunction parse(src, opts) {\n  var parser = new _parser.Parser(opts);\n  return parser.parse(src);\n}\n\nfunction compile(src, opts) {\n  return new _renderer.Renderer(src, opts);\n}\n\nfunction render(src, context, opts) {\n  var r = compile(src, opts);\n  return r.render(context);\n}\n\nexports.register = _extension.register;\nexports.Helpers = Helpers;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// huz.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8d72c3c871219142c1fd","const registry = [];\n\nexport class Extension {\n  //called by tokenizer\n  transformToken(token) { return token; }\n\n  //called by parser\n  handleToken(token, parserContext) { }\n  visit(root) { return root; }\n  \n  //called by renderer\n  handleNode(node, renderContext) { }\n  transformNodeResult(node, result, nodeResult) { return nodeResult; }\n  transformResult(result) { return result; }\n}\n\nexport function instantiateAll(opts) {\n  return registry.map(ctor => {\n    return new ctor(opts);\n  });\n}\n\nexport function register(constructor) {\n  return registry.push(constructor);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/extension.js","export const EOF                    = 'EOF';\nexport const TEXT                   = 'TEXT';\nexport const PARTIAL                = 'PARTIAL';\nexport const INVERTED_SECTION_OPEN  = 'INVERTED_SECTION_OPEN';\nexport const SECTION_OPEN           = 'SECTION_OPEN';\nexport const SECTION_CLOSE          = 'SECTION_CLOSE';\nexport const UNESCAPED_VARIABLE     = 'UNESCAPED_VARIABLE';\nexport const COMMENT                = 'COMMENT';\nexport const VARIABLE               = 'VARIABLE';\nexport const DELIMITER_CHANGE \t\t\t= 'DELIMITER_CHANGE';\n\n\n// WEBPACK FOOTER //\n// ./src/token.js","import * as TokenType from './token';\n\nexport function walk(root, modifier) {\n  let stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    const node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nexport function visit(root, visitor) {\n  let stack = [root];\n  while (stack.length) {\n    const parent = stack.pop();\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      const modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nexport function trimStandaloneToken(tokens) {\n  const count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  let open = null;\n  let inline = 0;\n  let standalone = true;\n  let indentTokens = [];\n  for (let i = 0; standalone && i < count; i++) {\n    const token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline ++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline ++;\n        }\n        break;\n      default: //section-like tags\n        if (open === null) {\n          open = [token];\n          inline ++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n  \n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    let tailWSNodeCount = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount ++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        let indent = '';\n        indentTokens.forEach(t => { indent += t.text });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return /^\\s*$/.test(str);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/helpers.js","export const ROOT             = 'ROOT';\nexport const VARIABLE         = 'VARIABLE';\nexport const SECTION          = 'SECTION';\nexport const TEXT             = 'TEXT';\nexport const COMMENT          = 'COMMENT';\nexport const PARTIAL          = 'PARTIAL';\nexport const DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\n\n// WEBPACK FOOTER //\n// ./src/node.js","import * as TokenType from \"./token\";\nimport * as NodeType from \"./node\";\nimport { Tokenizer } from \"./tokenizer\";\nimport { visit } from \"./helpers\";\nimport { instantiateAll } from \"./extension\";\n\nclass ParserContext {\n  constructor(parser) {\n    this._parser = parser;\n  }\n\n  appendNode(node) {\n    this._parser._appendNode(node);\n  }\n\n  pushParent(node) {\n    this._parser._pushParent(node);\n  }\n\n  popParent() {\n    return this._parser._popParent();\n  }\n\n  lastParent() {\n    return this._parser._lastParent;\n  }\n\n  lastParentType() {\n    return this._parser._lastParent ? this._parser._lastParent.type : null;\n  }\n\n  get filename() {\n    return this._parser._filename;\n  }\n\n  get top() {\n    return this._parser._stack.length;\n  }\n\n  get tailNode() {\n    return this._parser._stack.length > 0\n      ? this._parser._stack[this._parser._stack.length - 1]\n      : null;\n  }\n\n  throw(message) {\n    return this._parser._throw(message);\n  }\n}\n\nexport class Parser {\n  constructor(opts = {}) {\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    this._filename = opts.filename || \"\";\n    this._lastParent = null;\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  parse(src) {\n    const rootNode = {\n      type: NodeType.ROOT,\n      children: []\n    };\n    this._src = src;\n    this._stack = [rootNode];\n    this._lastToken = null;\n    this._parseNodes(src);\n\n    if (this._extensions.length > 0) {\n      for (let i = 0; i < this._extensions.length; i++) {\n        this._extensions[i].visit(rootNode);\n      }\n    }\n\n    return rootNode;\n  }\n\n  _addNodeToken(node) {\n    const token = this._lastToken;\n    if (node.tokens) {\n      node.tokens.push(token);\n    } else {\n      node.tokens = [token];\n    }\n  }\n\n  _appendNode(node) {\n    this._addNodeToken(node);\n    node.location.filename = this._filename;\n    this._stack[this._stack.length - 1].children.push(node);\n    return node;\n  }\n\n  _getTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  _clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  _makeLocation(beginLocation, endLocation) {\n    const location = this._clone(beginLocation);\n    if (endLocation) {\n      location.endIndex = endLocation.endIndex;\n      location.endLine = endLocation.endLine;\n    }\n    return location;\n  }\n\n  _parseNodes(src) {\n    let initialStackSize = this._stack.length;\n    let token;\n    const z = new Tokenizer(src, {\n      delimiters: this._delimiters.slice(0),\n      extensions: this._extensions,\n      filename: this._filename\n    });\n\n    do {\n      token = z.getNextToken();\n\n      if (z.error !== null) {\n        throw z.error;\n      }\n\n      this._lastToken = token;\n\n      let handled = false;\n      if (this._extensions) {\n        for (let i = 0; i < this._extensions.length; i++) {\n          const ext = this._extensions[i];\n          if (ext.handleToken(token, this._parserContext) === true) {\n            handled = true;\n            break;\n          }\n        }\n      }\n\n      if (!handled) {\n        switch (token.type) {\n          case TokenType.TEXT:\n            this._appendNode({\n              type: NodeType.TEXT,\n              text: token.text,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.VARIABLE:\n          case TokenType.UNESCAPED_VARIABLE:\n            this._appendNode({\n              type: NodeType.VARIABLE,\n              name: token.name,\n              unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.SECTION_OPEN:\n            this._handleSectionOpen(token);\n            break;\n\n          case TokenType.INVERTED_SECTION_OPEN:\n            this._handleSectionOpen(token, true);\n            break;\n\n          case TokenType.SECTION_CLOSE:\n            this._handleSectionClose(token);\n            break;\n\n          case TokenType.PARTIAL:\n            this._appendNode({\n              type: NodeType.PARTIAL,\n              name: token.name,\n              indent: token.indent,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.COMMENT:\n            this._handleComment(token);\n            break;\n\n          case TokenType.DELIMITER_CHANGE:\n            this._appendNode({\n              type: NodeType.DELIMITER_CHANGE,\n              delimiters: token.delimiters,\n              location: this._makeLocation(token.location)\n            });\n            break;\n        }\n      }\n    } while (token.type !== TokenType.EOF);\n\n    if (this._stack.length > initialStackSize) {\n      this._throw(\n        \"Unexpected EOF: sections not closed: \" +\n          this._stack\n            .slice(initialStackSize)\n            .map(n => `'${n.name}'`)\n            .join(\", \")\n      );\n    } else if (this._stack.length < initialStackSize) {\n      this._throw(\"Internal error.\");\n    }\n  }\n\n  _throw(message) {\n    const e = new Error(message);\n    e.filename = this._lastToken.filename;\n    e.location = this._lastToken.location;\n    throw e;\n  }\n\n  _pushParent(node) {\n    this._addNodeToken(node);\n    node.children = [];\n    this._stack.push(node);\n    this._lastParent = node;\n  }\n\n  _popParent() {\n    return this._stack.pop();\n  }\n\n  _handleSectionOpen(token, inverted = false) {\n    const { name, location } = token;\n    this._pushParent({\n      type: NodeType.SECTION,\n      name,\n      inverted,\n      location\n    });\n  }\n\n  _handleSectionClose(token) {\n    const { name, location } = token;\n    const section = this._popParent();\n    if (section.type !== NodeType.SECTION) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}'`);\n    }\n\n    if (section.name !== name) {\n      this._throw(\n        `Unexpected SECTION_CLOSE: '${name}', current section: '${\n          section.name\n        }'`\n      );\n    }\n\n    section.raw = this._src.slice(section.location.endIndex, location.index);\n    section.location = this._makeLocation(section.location, token.location);\n\n    this._appendNode(section);\n  }\n\n  _handleComment(token) {\n    const { content, location } = token;\n    this._appendNode({\n      type: NodeType.COMMENT,\n      content,\n      location: this._makeLocation(location)\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/parser.js","import * as TokenType from './token';\nimport { instantiateAll } from './extension';\nimport { trimStandaloneToken } from './helpers';\n\nconst STATE_NONE        = 'STATE_NONE';\nconst STATE_EOF         = 'STATE_EOF';\nconst STATE_TEXT        = 'STATE_TEXT';\nconst STATE_TEXT_BREAK  = 'STATE_TEXT_BREAK';\nconst STATE_TAG         = 'STATE_TAG';\n\nconst DELIMITER_LEFT  = 0;\nconst DELIMITER_RIGHT = 1;\n\nexport class Tokenizer {\n  constructor(src, opts = {}) {\n    this._extensions = opts.extensions || instantiateAll();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 0;\n    this._column = 0;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : ['{{', '}}'];\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  getNextToken() {\n    if (this._tokens.length > 0) {\n      return this._tokens.shift();\n    }\n\n    let done = false;\n    let matched = false;\n    do {\n      //console.log(this._state, this._tokens);\n      if (this._error !== null) {\n        return null;\n      }\n\n      if (this._state !== STATE_NONE) {\n        matched = true;\n        this._markTokenStartLocation();\n      }\n\n      switch (this._state) {\n        case STATE_NONE:\n          this._read();\n          break;\n\n        case STATE_EOF:\n          this._handleEOF();\n          done = true;\n          break;\n\n        case STATE_TEXT:\n          this._handleText();\n          break;\n\n        case STATE_TEXT_BREAK:\n          this._handleTextBreak();\n          done = true;\n          break;\n\n        case STATE_TAG:\n          this._handleTag();\n          break;\n      }\n\n      if (matched && !this._error) {\n        this._markTokenEndLocation();\n        matched = false;\n      }\n\n      if (this._state === STATE_NONE) {\n        if (this._char === null) {\n          this._state = STATE_EOF;\n        } else if (this._char === '\\n') {\n          this._state = STATE_TEXT_BREAK;\n        } else if (this._isDelimiter(DELIMITER_LEFT)) {\n          this._state = STATE_TAG;\n        } else {\n          this._state = STATE_TEXT;\n        }\n      }\n\n    } while (!done);\n\n    return this._error === null ? this._tokens.shift() : null;\n  }\n\n  // Handlers\n\n  _handleEOF() {\n    this._handleStandaloneTag();\n    this._makeToken({ \n      type: TokenType.EOF\n    });\n  }\n\n  _handleTag() {\n    const [ left, right ] = this._delimiters;\n    this._skip(left.length);\n    this._skipAllWhitespaces();\n\n    if (this._char === null) {\n      this._setError('Unclosed tag.');\n    }\n    else if (this._isDelimiter(DELIMITER_RIGHT)) {\n      this._handleEmptyTag();\n    } else {\n      const tagTypeChar = this._char;\n      if (tagTypeChar === '{') {\n        this._handleVariableCurly();\n      } else {\n        let tagContentStart = this._index - 1;\n        //read content\n        while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n          this._read();\n        }\n\n        if (this._char === null) {\n          this._setError('Unclosed tag.');\n        } else {\n          const content = this._src.slice(tagContentStart, this._index - 1);\n          switch (tagTypeChar) {\n            case '>': this._handleSimpleTag(TokenType.PARTIAL, content); break;\n            case '^': this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content); break;\n            case '#': this._handleSimpleTag(TokenType.SECTION_OPEN, content); break;\n            case '/': this._handleSimpleTag(TokenType.SECTION_CLOSE, content); break;\n\n            case '!':\n              this._handleComment(content.substr(1));\n              break;\n\n            case '=':\n              this._handleDelimiterChange(content);\n              break;\n            case '&':\n              this._handleVariable(content.substr(1), true);\n              break;\n            default:\n              this._handleVariable(content);\n              break;\n          }\n        }\n      }\n    }\n    if (this._error === null) {\n      //eat right\n      for (let i = 0; i < right.length; i++) {\n        this._read();\n      }\n    }\n\n    this._state = STATE_NONE;\n  }\n\n  _handleDelimiterChange(content) {\n    const newDelimiters = extractNewDelimiters(content);\n    if (newDelimiters === null) {\n      this._setError('Invalid change delimiter syntax.');\n    } else {\n      const [ left, right ] = newDelimiters;\n      this._delimiters = newDelimiters;\n      this._makeToken({\n        type: TokenType.DELIMITER_CHANGE,\n        delimiters: [ left, right ]\n      });\n    }\n  }\n\n  _handleSimpleTag(type, content) {\n    this._makeToken({ type, name: content.substr(1).trim() });\n  }\n\n  _handleComment(content) {\n    this._makeToken({\n      type: TokenType.COMMENT,\n      content\n    });\n  }\n\n  _handleVariableCurly() {\n    this._read(); //eat '{'\n    const begin = this._index - 1;\n    const d = this._distance('}');\n    if (d === -1) {\n      this._setError('Unclosed variable tag: missingright curly.');\n    } else {\n      const content = this._src.slice(begin, begin + d);\n      this._skip(d + 1); //skip '}'\n      this._skipAllWhitespaces();\n      if (!this._isDelimiter(DELIMITER_RIGHT)) {\n        this._setError('Unclosed variable: missing right delimiter.');\n      } else {\n        this._makeToken({\n          type: TokenType.UNESCAPED_VARIABLE,\n          name: content.trim()\n        });\n      }\n    }\n  }\n\n  _handleEmptyTag() {\n    this._makeToken({\n      type: TokenType.VARIABLE,\n      name: ''\n    });\n  }\n\n  _handleVariable(content, unescaped) {\n    this._makeToken({\n      type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n      name: content.trim()\n    });\n  }\n\n  _handleText() {\n    let done = false;\n    let index = this._index - 1;\n    let length = 0;\n    do {\n      const c = this._char;\n\n      if (c === null || c === '\\n' || this._isDelimiter(DELIMITER_LEFT)) {\n        done = true;\n      } else {\n        length ++;\n      }\n\n      if (!done) {\n        this._read();\n      }\n    } while (!done);\n\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: this._src.slice(index, index + length)\n    });\n\n    this._state = STATE_NONE;\n  }\n\n  _handleTextBreak() {\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: '\\n'\n    });\n    this._read();\n    this._handleStandaloneTag();\n    this._state = STATE_NONE;\n  }\n\n  _handleStandaloneTag() {\n    this._tokens = trimStandaloneToken(this._tokens);\n  }\n\n  // Helpers\n  _dump(t = '') {\n    console.log(t +'>'+this._src.slice(this._index - 1));\n  }\n\n  _read() {\n    if (this._index < this._src.length) {\n      if (this._char === '\\n') {\n        this._line ++;\n        this._column = 0;\n      } else {\n        this._column ++;\n      }\n\n      this._char = this._src[this._index];\n      this._index ++;\n    } else {\n      this._char = null;\n    }\n  }\n\n  _peek() {\n    if (this._index < this._src.length - 1) {\n      return this._src[this._index];\n    } else {\n      return null;\n    }\n  }\n\n  _skip(n) {\n    for (let i = 0; i < n; i ++) {\n      this._read();\n    }\n  }\n\n  _distance(c) {\n    for (let i = this._index; i < this._src.length; i++) {\n      if (this._src[i] === c) {\n        return i - this._index + 1;\n      }\n    }\n    return -1;\n  }\n\n  _skipAllWhitespaces() {\n    while (this._isWhitespace()) {\n      this._read();\n    }\n  }\n\n  _markTokenStartLocation() {\n    this._location.index = this._index - 1;\n    this._location.line = this._line;\n    this._location.column = this._column;\n  }\n\n  _markTokenEndLocation() {\n    const token = this._tokens[this._tokens.length - 1];\n    token.location.endIndex = this._index - 1;\n    token.location.endLine = this._line;\n    token.location.endColumn = this._column;\n  }\n\n  _isWhitespace() {\n    return /\\s/.test(this._char);\n  }\n\n  _isDelimiter(d, offset = 0) {\n    const delimiter = this._delimiters[d];\n    const pos = this._index - 1 + offset;\n    return this._src.slice(pos, pos + delimiter.length) === delimiter;\n  }\n\n  _makeToken(token) {\n    token.filename = this._filename;\n    const { index, line, column } = this._location;\n    token.location = {\n      index, line, column\n    };\n    if (this._extensions.length) {\n      try {\n        this._extensions.forEach(ext => {\n          token = ext.transformToken(token);\n        });\n      } catch (e) {\n        this._setError(e.message);\n        return;\n      }\n    }\n    this._tokens.push(token);\n  }\n\n  _setError(message) {\n    const error = new Error(message);\n    error.filename = this._filename;\n    error.index = this._index - 1;\n    error.line = this._line;\n    error.column = this._column;\n    this._error = error;\n  }\n}\n\nconst R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  const matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/tokenizer.js","// https://github.com/mustache/spec/pull/75\n\nimport { Extension, register } from \"../extension\";\nimport * as NodeType from \"../node\";\nimport * as TokenType from \"../token\";\n\nconst PARENT = \"Inheritance.PARENT\";\nconst BLOCK = \"Inheritance.BLOCK\";\nconst LEAVE_SCOPE = \"Inheritance.LEAVE_SCOPE\";\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nexport class Inheritance extends Extension {\n  constructor() {\n    super();\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  transformToken(token) {\n    const { type, name, location } = token;\n    switch (type) {\n      case TokenType.VARIABLE:\n        if (name) {\n          if (name[0] === \"<\") {\n            if (name.length === 1) {\n              throw new Error(\"Parent partial name expected\");\n            }\n            token = {\n              type: PARENT,\n              name: name.slice(1),\n              location\n            };\n          } else if (name[0] === \"$\") {\n            if (name.length === 1) {\n              throw new Error(\"Block name expected\");\n            }\n            token = {\n              type: BLOCK,\n              name: name.slice(1),\n              location\n            };\n          }\n        }\n        break;\n    }\n    return token;\n  }\n\n  handleToken(token, parserContext) {\n    let handled = false;\n    const { name, location, type } = token;\n    switch (type) {\n      case PARENT:\n        parserContext.pushParent({\n          type: PARENT,\n          name,\n          location\n        });\n        handled = true;\n        break;\n\n      case BLOCK:\n        this._pushBlock(\n          {\n            type: BLOCK,\n            name,\n            location\n          },\n          parserContext\n        );\n        break;\n\n      case TokenType.SECTION_CLOSE:\n        const tagNode = parserContext.tailNode;\n        if (tagNode === null) {\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.throw(\"Unexpected tag close\");\n          }\n        } else {\n          if (tagNode.name !== name) {\n            parserContext.throw(\n              `Unexpected tag close, current tag: ${tagNode.name}`\n            );\n          }\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.popParent();\n            tagNode.location.endIndex = location.endIndex;\n            tagNode.location.endLine = location.endLine;\n            parserContext.appendNode(tagNode);\n\n            //TODO move this to visit, handle whitespaces after Parent close tag.\n            const firstLine = tagNode.location.line;\n            const firstBlock = tagNode.children.find(c => c.type === BLOCK);\n            if (firstBlock && firstBlock.location.line === firstLine) {\n              for (let i = 0; i < firstBlock.children.length; i++) {\n                const blockNode = firstBlock.children[i];\n                if (\n                  blockNode.type === NodeType.TEXT &&\n                  /^\\s*$/.test(blockNode.text)\n                ) {\n                  blockNode.text = \"\";\n                } else {\n                  break;\n                }\n              }\n            }\n\n            handled = true;\n          }\n        }\n        break;\n\n      case TokenType.EOF:\n        if (this.top > 0) {\n          parserContext.throw(\n            \"Unexpected EOF: tags not closed: \" +\n              this.stack.map(f => f.name).join(\", \")\n          );\n        }\n        break;\n    }\n    return handled;\n  }\n\n  handleNode(node, rendererContext) {\n    const top = rendererContext.top;\n    this._checkTop(top);\n\n    switch (node.type) {\n      case PARENT:\n        this._handleParent(node, rendererContext);\n        return true;\n\n      case BLOCK:\n        this._handleBlock(node, rendererContext);\n        return true;\n\n      case LEAVE_SCOPE:\n        this._blocks = null;\n        return true;\n    }\n  }\n\n  _pushBlock(node, parserContext) {\n    const parent = parserContext.lastParent();\n    if (parent && parent.type === BLOCK && parent.name === node.name) {\n      parserContext.throw(`Recursive block: '${node.name}'`);\n    }\n    parserContext.pushParent(node);\n  }\n\n  _handleParent(node, rendererContext) {\n    const { name, location } = node;\n    const top = rendererContext.top;\n\n    this._pushParent(name, top);\n\n    if (this._blocks === null) {\n      rendererContext.pushNodes([\n        {\n          type: LEAVE_SCOPE\n        }\n      ]);\n      this._blocks = {};\n    }\n\n    //find all blocks defined in parent\n    const blocks = {};\n    node.children.forEach(child => {\n      if (child.type === BLOCK) {\n        const blockName = child.name;\n        blocks[blockName] = child;\n      }\n    });\n    if (Object.keys(blocks).length) {\n      this._setDefaultBlocks(blocks);\n    }\n\n    rendererContext.pushNode({\n      type: TokenType.PARTIAL,\n      name,\n      location,\n      indent: node.indent\n    });\n  }\n\n  _handleBlock(node, rendererContext) {\n    const { name } = node;\n    const defaultBlock = this._getDefaultBlock(name);\n    if (defaultBlock) {\n      rendererContext.pushNodes(defaultBlock.children);\n    } else {\n      rendererContext.pushNodes(node.children);\n    }\n  }\n\n  _pushParent(name, top) {\n    return this._parentStack.push({\n      name,\n      blocks: {},\n      top\n    });\n  }\n\n  _checkTop(top) {\n    let pop = 0;\n    for (let i = this._parentStack.length - 1; i >= 0; i--) {\n      const frame = this._parentStack[i];\n      if (frame.top > top) {\n        pop++;\n      } else {\n        break;\n      }\n    }\n    if (pop > 0) {\n      this._parentStack = this._parentStack.slice(\n        0,\n        this._parentStack.length - pop\n      );\n    }\n  }\n\n  _popParent() {\n    return this._parentStack.pop();\n  }\n\n  _getDefaultBlock(name) {\n    for (let i = 0; i < this._parentStack.length; i++) {\n      const frame = this._parentStack[i];\n      if (name in frame.blocks) {\n        return frame.blocks[name];\n      }\n    }\n    return null;\n  }\n\n  _setDefaultBlocks(blocks) {\n    const topFrame = this._parentStack[this._parentStack.length - 1];\n    topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/extensions/inheritance.js","import * as nodeTypes from \"./node\";\nimport escapeHTML from \"escape-html\";\nimport { Parser } from \"./parser\";\nimport { walk, visit } from \"./helpers\";\nimport { instantiateAll } from \"./extension\";\n\nconst REPEATER_NODE_TYPE = \"_REPEATER\";\nconst MAX_PARTIAL_STACK = 10;\nconst MAX_LAMBDA_STACK = 255;\nconst MAX_NODE_COUNT = 3000;\n\nclass RenderContext {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n\n  get top() {\n    return this._renderer._stack.length;\n  }\n\n  get result() {\n    return this._renderer._out;\n  }\n\n  evaluate(name) {\n    return this._renderer._evaluate(name);\n  }\n\n  pushNodes(nodes) {\n    this._renderer._pushNodes(nodes);\n  }\n\n  pushNode(node) {\n    this._renderer._pushNode(node);\n  }\n\n  pushContext(ctx) {\n    this._renderer._pushContext(ctx);\n  }\n\n  appendText(text) {\n    this._renderer._out += text;\n  }\n\n  parse(src, opts) {\n    return this._renderer._parse(src, opts);\n  }\n\n  getParsedPartial(name) {\n    return this._renderer._getParsedPartial(name);\n  }\n\n  throw(message, location) {\n    return this._renderer._throw(message, location);\n  }\n}\n\nexport class Renderer {\n  constructor(src, opts = {}) {\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(k => {\n        this._partialCached[k] = this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = \"\";\n    this._transformNodeResult = (node, result, nodeResult) =>\n      this._extensions.reduce(\n        (r, e) => e.transformNodeResult(node, result, r),\n        nodeResult\n      );\n  }\n\n  render(context) {\n    this._out = \"\";\n    this._stack = [];\n    this._contextStack = [];\n    this._partialStack = [];\n    this._lambdaStack = [];\n\n    this._pushContext(context);\n\n    //push root nodes\n    const rootNode = this._parsed ? this._src : this._parse(this._src);\n    this._stack = rootNode.children.slice(0).reverse();\n\n    let node_count = 0;\n\n    let newline = true;\n    while (this._stack.length > 0) {\n      const top = this._stack.length - 1;\n      const node = this._stack[top];\n\n      if (node.type !== nodeTypes.TEXT) {\n        node_count++;\n        if (node_count > MAX_NODE_COUNT) {\n          this._throw(\n            `Possible infinity loop detected: last node type is '${node.type}'`,\n            node.location\n          );\n        }\n      }\n\n      let handled = false;\n      if (this._extensions) {\n        this._extensions.forEach(ext => {\n          if (ext.handleNode(node, this._renderContext)) {\n            handled = true;\n          }\n        });\n      }\n\n      if (handled) {\n        this._stack.splice(top, 1);\n      } else {\n        const partial = this._partialStack.length\n          ? this._partialStack[this._partialStack.length - 1]\n          : null;\n\n        //insert indent\n        if (node.type in nodeTypes) {\n          if (newline && partial !== null && partial.indent.length > 0) {\n            this._out += partial.indent;\n          }\n        }\n\n        let value;\n        switch (node.type) {\n          case nodeTypes.VARIABLE:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              if (!!value) {\n                const result = node.unescaped ? value : escapeHTML(value);\n                this._out += this._transformNodeResult(node, this._out, result);\n              }\n              this._popNode();\n            }\n            break;\n\n          case nodeTypes.SECTION:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              let isList = Array.isArray(value);\n\n              if (isList && value.length === 0) {\n                //Empty lists should behave like falsey values.\n                value = false;\n                isList = false;\n              }\n\n              let testResult = !!value;\n              if (node.inverted) {\n                testResult = !testResult;\n              }\n\n              if (testResult) {\n                if (isList) {\n                  this._popNode();\n                  this._pushRepeaterNode(value.length, node.children, value);\n                } else {\n                  this._popNode();\n                  this._pushContext(value);\n                  this._pushNodes(node.children);\n                }\n              } else {\n                this._popNode();\n              }\n            }\n            break;\n\n          case nodeTypes.TEXT:\n            this._out += this._transformNodeResult(node, this._out, node.text);\n            this._popNode();\n            break;\n\n          case nodeTypes.COMMENT:\n            this._popNode();\n            break;\n\n          case nodeTypes.PARTIAL:\n            this._popNode();\n            this._expandPartial(node);\n            break;\n\n          case nodeTypes.DELIMITER_CHANGE:\n            this._popNode();\n            this._delimiters = node.delimiters.slice(0);\n            break;\n\n          case REPEATER_NODE_TYPE:\n            if (node.count < node.repeat) {\n              const repeatIndex = node.count;\n              if (repeatIndex === 0) {\n                node.contextIndex = this._pushContext(node.contexts[0]);\n              } else {\n                this._replaceContextAt(\n                  node.contextIndex,\n                  node.contexts[repeatIndex]\n                );\n              }\n              this._pushNodes(node.children);\n              node.count++;\n            } else {\n              this._popNode();\n            }\n            break;\n\n          default:\n            this._popNode();\n            break;\n        }\n      }\n      this._checkStacks();\n      newline =\n        this._out.length === 0 || this._out[this._out.length - 1] === \"\\n\";\n    }\n\n    return this._extensions.reduce(\n      (result, ext) => ext.transformResult(result),\n      this._out\n    );\n  }\n\n  _parse(src, opts = {}) {\n    opts.extensions = this._extensions;\n    const parser = new Parser(opts);\n    return parser.parse(src);\n  }\n\n  _pushNodes(list) {\n    for (let i = list.length - 1; i >= 0; i--) {\n      this._stack.push(list[i]);\n    }\n  }\n\n  _pushNode(node) {\n    this._stack.push(node);\n  }\n\n  _popNode() {\n    this._stack.pop();\n  }\n\n  _pushRepeaterNode(repeat, nodes, contexts) {\n    this._stack.push({\n      type: REPEATER_NODE_TYPE,\n      count: 0,\n      repeat,\n      children: nodes.slice(0),\n      contexts\n    });\n  }\n\n  _pushContext(context) {\n    return (\n      this._contextStack.push({\n        context,\n        sp: this._stack.length\n      }) - 1\n    );\n  }\n\n  _replaceContextAt(index, context) {\n    if (index < 0 || index > this._contextStack.length - 1) {\n      throw new RangeError(\"Huz context index out of range.\");\n    }\n    this._contextStack[index].context = context;\n  }\n\n  _pushPartial({ name, indent, location }) {\n    this._partialStack.push({\n      name,\n      indent: indent || \"\",\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _pushLambda({ name, location }) {\n    this._lambdaStack.push({\n      name,\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _checkStacks() {\n    if (\n      this._stack.length < this._contextStack[this._contextStack.length - 1].sp\n    ) {\n      this._contextStack.pop();\n    }\n\n    if (\n      this._partialStack.length > 0 &&\n      this._stack.length ===\n        this._partialStack[this._partialStack.length - 1].sp\n    ) {\n      this._partialStack.pop();\n    }\n\n    if (\n      this._lambdaStack.length > 0 &&\n      this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp\n    ) {\n      this._lambdaStack.pop();\n    }\n  }\n\n  _evaluate(name) {\n    if (name === \".\") {\n      return this._contextStack[this._contextStack.length - 1].context;\n    }\n\n    const path = name.split(\".\");\n    for (let i = this._contextStack.length - 1; i >= 0; i--) {\n      const context = this._contextStack[i].context;\n      if (context === null || typeof context !== \"object\") {\n        continue;\n      }\n\n      let current = context;\n      let resolved = true;\n      for (let pi = 0; pi < path.length; pi++) {\n        const key = path[pi];\n        if (\n          typeof current === \"object\" &&\n          current !== null &&\n          current.hasOwnProperty(key)\n        ) {\n          current = current[key];\n        } else {\n          resolved = false;\n          break;\n        }\n      }\n\n      if (resolved) {\n        return current;\n      }\n    }\n    return \"\";\n  }\n\n  _getParsedPartial(name) {\n    if (this._partialCached.hasOwnProperty(name)) {\n      return this._partialCached[name];\n    } else {\n      if (!this._partials.hasOwnProperty(name)) {\n        return null;\n      }\n      const ast = this._parse(this._partials[name], { filename: name });\n      const nodes = (this._partialCached[name] = ast.children);\n      return nodes;\n    }\n  }\n\n  _expandPartial(node) {\n    const { name } = node;\n    const nodes = this._getParsedPartial(name);\n\n    if (nodes === null) {\n      //The empty string should be used when the named partial is not found.\n      return;\n    }\n\n    this._pushPartial(node);\n\n    if (this._partialStack.length > MAX_PARTIAL_STACK) {\n      this._throw(\n        \"Possible partial short circuit: \" +\n          this._partialStack\n            .map(f => `${f.name}@${f.location.filename}:${f.location.line + 1}`)\n            .concat([name])\n            .join(\" -> \"),\n        node.location\n      );\n    }\n\n    this._pushNodes(nodes);\n  }\n\n  _expandLambda(node, lambda) {\n    const { name } = node;\n\n    this._pushLambda(node);\n\n    if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n      this._throw(\n        \"Possible lambda short circuit: \" +\n          this._lambdaStack\n            .map(f => `${f.name}@${f.location.filename}:${f.location.line + 1}`)\n            .concat([name])\n            .join(\" -> \"),\n        node.location\n      );\n    }\n\n    let ast;\n    let skipped = false;\n    if (node.type === nodeTypes.VARIABLE) {\n      const code = lambda();\n      if (code) {\n        //A lambda's return value should parse with the default delimiters.\n        ast = this._parse(\"\" + code, { filename: \"[lambda]\" });\n        if (!node.unescaped) {\n          //Lambda results should be appropriately escaped.\n          walk(ast, node => {\n            if (node.type === nodeTypes.TEXT) {\n              node.text = escapeHTML(node.text);\n            }\n          });\n        }\n      } else {\n        skipped = true;\n      }\n    } else if (node.type === nodeTypes.SECTION) {\n      const code = lambda(node.raw);\n      if (code) {\n        //Lambdas used for inverted sections should be considered truthy.\n        //Lambdas used for sections should parse with the current delimiters.\n        ast = this._parse(\"\" + code, {\n          filename: \"[#lambda]\",\n          delimiters: this._delimiters.slice(0)\n        });\n      } else {\n        skipped = true;\n      }\n    }\n\n    if (!skipped) {\n      this._pushNodes(ast.children);\n    }\n  }\n\n  _throw(message, location) {\n    const e = new Error(message);\n    e.location = location;\n    throw e;\n  }\n}\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == \"[object Function]\";\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderer.js","import { Parser } from './parser';\nimport { Renderer } from './renderer';\nimport * as TokenType from './token';\nimport * as NodeType from './node';\nimport * as Helpers from './helpers';\nimport { register } from './extension';\n\nexport { Tokenizer } from './tokenizer';\nexport { Parser, Renderer, TokenType, NodeType };\n\nexport { Extension } from './extension';\nimport { Inheritance } from './extensions/inheritance';\n\nregister(Inheritance);\n\nexport function parse(src, opts) {\n  const parser = new Parser(opts);\n  return parser.parse(src);\n}\n\nexport function compile(src, opts) {\n  return new Renderer(src, opts);\n}\n\nexport function render(src, context, opts) {\n  const r = compile(src, opts);\n  return r.render(context);\n}\n\nexport { register, Helpers };\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/escape-html/index.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}