{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///huz.js","webpack:///webpack/bootstrap 575cb45158c1a5d0f929","webpack:///./src/extension.js","webpack:///./src/token.js","webpack:///./src/helpers.js","webpack:///./src/node.js","webpack:///./src/parser.js","webpack:///./src/tokenizer.js","webpack:///./src/extensions/inheritance.js","webpack:///./src/renderer.js","webpack:///./src/index.js","webpack:///./~/escape-html/index.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","instantiateAll","opts","registry","map","ctor","register","constructor","push","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Extension","token","parserContext","node","renderContext","result","nodeResult","EOF","TEXT","PARTIAL","INVERTED_SECTION_OPEN","SECTION_OPEN","SECTION_CLOSE","UNESCAPED_VARIABLE","COMMENT","VARIABLE","DELIMITER_CHANGE","walk","modifier","stack","children","slice","reverse","pop","undefined","concat","visit","visitor","_parent","child","modified","trimStandaloneToken","tokens","count","open","inline","standalone","indentTokens","type","TokenType","isStringWhitespace","text","tailWSNodeCount","indent","forEach","t","str","test","_token","obj","newObj","ROOT","SECTION","_interopRequireWildcard","_node","NodeType","_tokenizer","_extension","ParserContext","parser","_parser","_appendNode","_pushParent","_popParent","f","_stack","item","message","_throw","_filename","parentNode","Parser","arguments","_delimiters","delimiters","_extensions","extensions","filename","_parserContext","_lastToken","_src","src","rootNode","_parseNodes","_addNodeToken","location","JSON","parse","stringify","beginLocation","endLocation","_clone","endIndex","endLine","initialStackSize","z","Tokenizer","getNextToken","error","handled","ext","handleToken","_makeLocation","unescaped","_handleSectionOpen","_handleSectionClose","_handleComment","join","e","Error","inverted","section","raw","index","content","extractNewDelimiters","tagContent","matches","match","R_DELIMITER_CHANGE","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","err","Array","isArray","_helpers","STATE_NONE","_index","_char","_tokens","_line","_column","_state","_error","_location","line","column","shift","matched","_markTokenStartLocation","_read","_handleEOF","_handleText","_handleTextBreak","_handleTag","_markTokenEndLocation","_isDelimiter","_handleStandaloneTag","_makeToken","left","right","_skip","_skipAllWhitespaces","_setError","_handleEmptyTag","tagTypeChar","_handleVariableCurly","tagContentStart","_handleSimpleTag","substr","_handleDelimiterChange","_handleVariable","newDelimiters","_newDelimiters","trim","begin","_distance","console","log","_isWhitespace","endColumn","offset","delimiter","pos","transformToken","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","isInheritanceTagType","PARENT","BLOCK","_get","_x","_x2","_x3","_again","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_token2","Inheritance","_Extension","_blocks","_parentStack","pushParent","_pushBlock","tagNode","popParent","appendNode","firstLine","firstBlock","find","blockNode","top","rendererContext","_checkTop","_handleParent","_handleBlock","findParentNode","pushNodes","blocks","blockName","keys","_setDefaultBlocks","pushNode","defaultBlock","_getDefaultBlock","frame","topFrame","assign","isFunction","x","toString","nodeTypes","_escapeHtml","_escapeHtml2","default","RenderContext","renderer","_renderer","_evaluate","nodes","_pushNodes","_pushNode","ctx","_pushContext","_out","_parse","_getParsedPartial","Renderer","_this","_parsed","parsed","_partials","partials","_renderContext","_partialCached","k","_contextStack","_partialStack","_lambdaStack","_transformNodeResult","reduce","r","transformNodeResult","context","_this2","node_count","newline","handleNode","splice","partial","_popNode","_expandLambda","isList","testResult","_pushRepeaterNode","_expandPartial","repeat","repeatIndex","contextIndex","contexts","_replaceContextAt","_checkStacks","transformResult","list","sp","RangeError","_ref","_ref2","path","split","current","resolved","pi","ast","_pushPartial","lambda","_pushLambda","skipped","code","compile","render","Helpers","_extensionsInheritance","escapeHtml","string","matchHtmlRegExp","exec","escape","html","lastIndex","charCodeAt","substring"],"mappings":"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","file":"huz.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.instantiateAll = instantiateAll;\nexports.register = register;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar registry = [];\n\nvar Extension = (function () {\n  function Extension() {\n    _classCallCheck(this, Extension);\n  }\n\n  _createClass(Extension, [{\n    key: \"transformToken\",\n\n    //called by tokenizer\n    value: function transformToken(token) {\n      return token;\n    }\n\n    //called by parser\n  }, {\n    key: \"handleToken\",\n    value: function handleToken(token, parserContext) {}\n  }, {\n    key: \"visit\",\n    value: function visit(root) {\n      return root;\n    }\n\n    //called by renderer\n  }, {\n    key: \"handleNode\",\n    value: function handleNode(node, renderContext) {}\n  }, {\n    key: \"transformNodeResult\",\n    value: function transformNodeResult(node, result, nodeResult) {\n      return nodeResult;\n    }\n  }, {\n    key: \"transformResult\",\n    value: function transformResult(result) {\n      return result;\n    }\n  }]);\n\n  return Extension;\n})();\n\nexports.Extension = Extension;\n\nfunction instantiateAll(opts) {\n  return registry.map(function (ctor) {\n    return new ctor(opts);\n  });\n}\n\nfunction register(constructor) {\n  return registry.push(constructor);\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar EOF = 'EOF';\nexports.EOF = EOF;\nvar TEXT = 'TEXT';\nexports.TEXT = TEXT;\nvar PARTIAL = 'PARTIAL';\nexports.PARTIAL = PARTIAL;\nvar INVERTED_SECTION_OPEN = 'INVERTED_SECTION_OPEN';\nexports.INVERTED_SECTION_OPEN = INVERTED_SECTION_OPEN;\nvar SECTION_OPEN = 'SECTION_OPEN';\nexports.SECTION_OPEN = SECTION_OPEN;\nvar SECTION_CLOSE = 'SECTION_CLOSE';\nexports.SECTION_CLOSE = SECTION_CLOSE;\nvar UNESCAPED_VARIABLE = 'UNESCAPED_VARIABLE';\nexports.UNESCAPED_VARIABLE = UNESCAPED_VARIABLE;\nvar COMMENT = 'COMMENT';\nexports.COMMENT = COMMENT;\nvar VARIABLE = 'VARIABLE';\nexports.VARIABLE = VARIABLE;\nvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\nexports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.walk = walk;\nexports.visit = visit;\nexports.trimStandaloneToken = trimStandaloneToken;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nfunction walk(root, modifier) {\n  var stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    var node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nfunction visit(root, visitor) {\n  var stack = [root];\n  while (stack.length) {\n    var _parent = stack.pop();\n    for (var i = 0; i < _parent.children.length; i++) {\n      var child = _parent.children[i];\n      var modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        _parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nfunction trimStandaloneToken(tokens) {\n  var count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  var open = null;\n  var inline = 0;\n  var standalone = true;\n  var indentTokens = [];\n  for (var i = 0; standalone && i < count; i++) {\n    var token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline++;\n        }\n        break;\n      default:\n        //section-like tags\n        if (open === null) {\n          open = [token];\n          inline++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n\n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    var tailWSNodeCount = 0;\n    for (var i = count - 1; i >= 0; i--) {\n      var token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        var indent = '';\n        indentTokens.forEach(function (t) {\n          indent += t.text;\n        });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return (/^\\s*$/.test(str)\n  );\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar ROOT = 'ROOT';\nexports.ROOT = ROOT;\nvar VARIABLE = 'VARIABLE';\nexports.VARIABLE = VARIABLE;\nvar SECTION = 'SECTION';\nexports.SECTION = SECTION;\nvar TEXT = 'TEXT';\nexports.TEXT = TEXT;\nvar COMMENT = 'COMMENT';\nexports.COMMENT = COMMENT;\nvar PARTIAL = 'PARTIAL';\nexports.PARTIAL = PARTIAL;\nvar DELIMITER_CHANGE = 'DELIMITER_CHANGE';\nexports.DELIMITER_CHANGE = DELIMITER_CHANGE;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _tokenizer = __webpack_require__(5);\n\nvar _helpers = __webpack_require__(2);\n\nvar _extension = __webpack_require__(0);\n\nvar ParserContext = (function () {\n  function ParserContext(parser) {\n    _classCallCheck(this, ParserContext);\n\n    this._parser = parser;\n  }\n\n  _createClass(ParserContext, [{\n    key: \"appendNode\",\n    value: function appendNode(node) {\n      this._parser._appendNode(node);\n    }\n  }, {\n    key: \"pushParent\",\n    value: function pushParent(node) {\n      this._parser._pushParent(node);\n    }\n  }, {\n    key: \"popParent\",\n    value: function popParent() {\n      return this._parser._popParent();\n    }\n  }, {\n    key: \"findParentNode\",\n    value: function findParentNode(f) {\n      for (var i = this._parser._stack.length - 1; i >= 0; i--) {\n        var item = this._parser._stack[i];\n        if (f(item)) {\n          return item;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(message) {\n      return this._parser._throw(message);\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._parser._filename;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._parser._stack.length;\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return this._parser._stack.length > 0 ? this._parser._stack[this._parser._stack.length - 1] : null;\n    }\n\n    /// deprecated\n  }, {\n    key: \"tailNode\",\n    get: function get() {\n      return this.parentNode;\n    }\n  }]);\n\n  return ParserContext;\n})();\n\nvar Parser = (function () {\n  function Parser() {\n    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, Parser);\n\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n    this._filename = opts.filename || \"\";\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(src) {\n      var rootNode = {\n        type: NodeType.ROOT,\n        children: []\n      };\n      this._src = src;\n      this._stack = [rootNode];\n      this._lastToken = null;\n      this._parseNodes(src);\n\n      if (this._extensions.length > 0) {\n        for (var i = 0; i < this._extensions.length; i++) {\n          this._extensions[i].visit(rootNode);\n        }\n      }\n\n      return rootNode;\n    }\n  }, {\n    key: \"_addNodeToken\",\n    value: function _addNodeToken(node) {\n      var token = this._lastToken;\n      if (node.tokens) {\n        node.tokens.push(token);\n      } else {\n        node.tokens = [token];\n      }\n    }\n  }, {\n    key: \"_appendNode\",\n    value: function _appendNode(node) {\n      this._addNodeToken(node);\n      node.location.filename = this._filename;\n      this._stack[this._stack.length - 1].children.push(node);\n      return node;\n    }\n  }, {\n    key: \"_getTop\",\n    value: function _getTop() {\n      return this._stack[this._stack.length - 1];\n    }\n  }, {\n    key: \"_clone\",\n    value: function _clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  }, {\n    key: \"_makeLocation\",\n    value: function _makeLocation(beginLocation, endLocation) {\n      var location = this._clone(beginLocation);\n      if (endLocation) {\n        location.endIndex = endLocation.endIndex;\n        location.endLine = endLocation.endLine;\n      }\n      return location;\n    }\n  }, {\n    key: \"_parseNodes\",\n    value: function _parseNodes(src) {\n      var initialStackSize = this._stack.length;\n      var token = undefined;\n      var z = new _tokenizer.Tokenizer(src, {\n        delimiters: this._delimiters.slice(0),\n        extensions: this._extensions,\n        filename: this._filename\n      });\n\n      do {\n        token = z.getNextToken();\n\n        if (z.error !== null) {\n          throw z.error;\n        }\n\n        this._lastToken = token;\n\n        var handled = false;\n        if (this._extensions) {\n          for (var i = 0; i < this._extensions.length; i++) {\n            var ext = this._extensions[i];\n            if (ext.handleToken(token, this._parserContext) === true) {\n              handled = true;\n              break;\n            }\n          }\n        }\n\n        if (!handled) {\n          switch (token.type) {\n            case TokenType.TEXT:\n              this._appendNode({\n                type: NodeType.TEXT,\n                text: token.text,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.VARIABLE:\n            case TokenType.UNESCAPED_VARIABLE:\n              this._appendNode({\n                type: NodeType.VARIABLE,\n                name: token.name,\n                unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.SECTION_OPEN:\n              this._handleSectionOpen(token);\n              break;\n\n            case TokenType.INVERTED_SECTION_OPEN:\n              this._handleSectionOpen(token, true);\n              break;\n\n            case TokenType.SECTION_CLOSE:\n              this._handleSectionClose(token);\n              break;\n\n            case TokenType.PARTIAL:\n              this._appendNode({\n                type: NodeType.PARTIAL,\n                name: token.name,\n                indent: token.indent,\n                location: this._makeLocation(token.location)\n              });\n              break;\n\n            case TokenType.COMMENT:\n              this._handleComment(token);\n              break;\n\n            case TokenType.DELIMITER_CHANGE:\n              this._appendNode({\n                type: NodeType.DELIMITER_CHANGE,\n                delimiters: token.delimiters,\n                location: this._makeLocation(token.location)\n              });\n              break;\n          }\n        }\n      } while (token.type !== TokenType.EOF);\n\n      if (this._stack.length > initialStackSize) {\n        this._throw(\"Unexpected EOF: sections not closed: \" + this._stack.slice(initialStackSize).map(function (n) {\n          return \"'\" + n.name + \"'\";\n        }).join(\", \"));\n      } else if (this._stack.length < initialStackSize) {\n        this._throw(\"Internal error.\");\n      }\n    }\n  }, {\n    key: \"_throw\",\n    value: function _throw(message) {\n      var e = new Error(message);\n      e.filename = this._lastToken.location.filename;\n      e.location = this._lastToken.location;\n      throw e;\n    }\n  }, {\n    key: \"_pushParent\",\n    value: function _pushParent(node) {\n      this._addNodeToken(node);\n      node.children = [];\n      this._stack.push(node);\n    }\n  }, {\n    key: \"_popParent\",\n    value: function _popParent() {\n      return this._stack.pop();\n    }\n  }, {\n    key: \"_handleSectionOpen\",\n    value: function _handleSectionOpen(token) {\n      var inverted = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n      var name = token.name;\n      var location = token.location;\n\n      this._pushParent({\n        type: NodeType.SECTION,\n        name: name,\n        inverted: inverted,\n        location: location\n      });\n    }\n  }, {\n    key: \"_handleSectionClose\",\n    value: function _handleSectionClose(token) {\n      var name = token.name;\n      var location = token.location;\n\n      var section = this._popParent();\n      if (section.type !== NodeType.SECTION) {\n        this._throw(\"Unexpected SECTION_CLOSE: '\" + name + \"'\");\n      }\n\n      if (section.name !== name) {\n        this._throw(\"Unexpected SECTION_CLOSE: '\" + name + \"', current section: '\" + section.name + \"'\");\n      }\n\n      section.raw = this._src.slice(section.location.endIndex, location.index);\n      section.location = this._makeLocation(section.location, token.location);\n\n      this._appendNode(section);\n    }\n  }, {\n    key: \"_handleComment\",\n    value: function _handleComment(token) {\n      var content = token.content;\n      var location = token.location;\n\n      this._appendNode({\n        type: NodeType.COMMENT,\n        content: content,\n        location: this._makeLocation(location)\n      });\n    }\n  }]);\n\n  return Parser;\n})();\n\nexports.Parser = Parser;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; })();\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _extension = __webpack_require__(0);\n\nvar _helpers = __webpack_require__(2);\n\nvar STATE_NONE = \"STATE_NONE\";\nvar STATE_EOF = \"STATE_EOF\";\nvar STATE_TEXT = \"STATE_TEXT\";\nvar STATE_TEXT_BREAK = \"STATE_TEXT_BREAK\";\nvar STATE_TAG = \"STATE_TAG\";\n\nvar DELIMITER_LEFT = 0;\nvar DELIMITER_RIGHT = 1;\n\nvar Tokenizer = (function () {\n  function Tokenizer(src) {\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Tokenizer);\n\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 0;\n    this._column = 0;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n  }\n\n  _createClass(Tokenizer, [{\n    key: \"getNextToken\",\n    value: function getNextToken() {\n      if (this._tokens.length > 0) {\n        return this._tokens.shift();\n      }\n\n      var done = false;\n      var matched = false;\n      do {\n        //console.log(this._state, this._tokens);\n        if (this._error !== null) {\n          return null;\n        }\n\n        if (this._state !== STATE_NONE) {\n          matched = true;\n          this._markTokenStartLocation();\n        }\n\n        switch (this._state) {\n          case STATE_NONE:\n            this._read();\n            break;\n\n          case STATE_EOF:\n            this._handleEOF();\n            done = true;\n            break;\n\n          case STATE_TEXT:\n            this._handleText();\n            break;\n\n          case STATE_TEXT_BREAK:\n            this._handleTextBreak();\n            done = true;\n            break;\n\n          case STATE_TAG:\n            this._handleTag();\n            break;\n        }\n\n        if (matched && !this._error) {\n          this._markTokenEndLocation();\n          matched = false;\n        }\n\n        if (this._state === STATE_NONE) {\n          if (this._char === null) {\n            this._state = STATE_EOF;\n          } else if (this._char === \"\\n\") {\n            this._state = STATE_TEXT_BREAK;\n          } else if (this._isDelimiter(DELIMITER_LEFT)) {\n            this._state = STATE_TAG;\n          } else {\n            this._state = STATE_TEXT;\n          }\n        }\n      } while (!done);\n\n      return this._error === null ? this._tokens.shift() : null;\n    }\n\n    // Handlers\n\n  }, {\n    key: \"_handleEOF\",\n    value: function _handleEOF() {\n      this._handleStandaloneTag();\n      this._makeToken({\n        type: TokenType.EOF\n      });\n    }\n  }, {\n    key: \"_handleTag\",\n    value: function _handleTag() {\n      var _delimiters = _slicedToArray(this._delimiters, 2);\n\n      var left = _delimiters[0];\n      var right = _delimiters[1];\n\n      this._skip(left.length);\n      this._skipAllWhitespaces();\n\n      if (this._char === null) {\n        this._setError(\"Unclosed tag.\");\n      } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n        this._handleEmptyTag();\n      } else {\n        var tagTypeChar = this._char;\n        if (tagTypeChar === \"{\") {\n          this._handleVariableCurly();\n        } else {\n          var tagContentStart = this._index - 1;\n          //read content\n          while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n            this._read();\n          }\n\n          if (this._char === null) {\n            this._setError(\"Unclosed tag.\");\n          } else {\n            var content = this._src.slice(tagContentStart, this._index - 1);\n            switch (tagTypeChar) {\n              case \">\":\n                this._handleSimpleTag(TokenType.PARTIAL, content);\n                break;\n              case \"^\":\n                this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);\n                break;\n              case \"#\":\n                this._handleSimpleTag(TokenType.SECTION_OPEN, content);\n                break;\n              case \"/\":\n                this._handleSimpleTag(TokenType.SECTION_CLOSE, content);\n                break;\n\n              case \"!\":\n                this._handleComment(content.substr(1));\n                break;\n\n              case \"=\":\n                this._handleDelimiterChange(content);\n                break;\n              case \"&\":\n                this._handleVariable(content.substr(1), true);\n                break;\n              default:\n                this._handleVariable(content);\n                break;\n            }\n          }\n        }\n      }\n      if (this._error === null) {\n        //eat right\n        for (var i = 0; i < right.length; i++) {\n          this._read();\n        }\n      }\n\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleDelimiterChange\",\n    value: function _handleDelimiterChange(content) {\n      var newDelimiters = extractNewDelimiters(content);\n      if (newDelimiters === null) {\n        this._setError(\"Invalid change delimiter syntax.\");\n      } else {\n        var _newDelimiters = _slicedToArray(newDelimiters, 2);\n\n        var left = _newDelimiters[0];\n        var right = _newDelimiters[1];\n\n        this._delimiters = newDelimiters;\n        this._makeToken({\n          type: TokenType.DELIMITER_CHANGE,\n          delimiters: [left, right]\n        });\n      }\n    }\n  }, {\n    key: \"_handleSimpleTag\",\n    value: function _handleSimpleTag(type, content) {\n      this._makeToken({ type: type, name: content.substr(1).trim() });\n    }\n  }, {\n    key: \"_handleComment\",\n    value: function _handleComment(content) {\n      this._makeToken({\n        type: TokenType.COMMENT,\n        content: content\n      });\n    }\n  }, {\n    key: \"_handleVariableCurly\",\n    value: function _handleVariableCurly() {\n      this._read(); //eat '{'\n      var begin = this._index - 1;\n      var d = this._distance(\"}\");\n      if (d === -1) {\n        this._setError(\"Unclosed variable tag: missingright curly.\");\n      } else {\n        var content = this._src.slice(begin, begin + d);\n        this._skip(d + 1); //skip '}'\n        this._skipAllWhitespaces();\n        if (!this._isDelimiter(DELIMITER_RIGHT)) {\n          this._setError(\"Unclosed variable: missing right delimiter.\");\n        } else {\n          this._makeToken({\n            type: TokenType.UNESCAPED_VARIABLE,\n            name: content.trim()\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_handleEmptyTag\",\n    value: function _handleEmptyTag() {\n      this._makeToken({\n        type: TokenType.VARIABLE,\n        name: \"\"\n      });\n    }\n  }, {\n    key: \"_handleVariable\",\n    value: function _handleVariable(content, unescaped) {\n      this._makeToken({\n        type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n        name: content.trim()\n      });\n    }\n  }, {\n    key: \"_handleText\",\n    value: function _handleText() {\n      var done = false;\n      var index = this._index - 1;\n      var length = 0;\n      do {\n        var c = this._char;\n\n        if (c === null || c === \"\\n\" || this._isDelimiter(DELIMITER_LEFT)) {\n          done = true;\n        } else {\n          length++;\n        }\n\n        if (!done) {\n          this._read();\n        }\n      } while (!done);\n\n      this._makeToken({\n        type: TokenType.TEXT,\n        text: this._src.slice(index, index + length)\n      });\n\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleTextBreak\",\n    value: function _handleTextBreak() {\n      this._makeToken({\n        type: TokenType.TEXT,\n        text: \"\\n\"\n      });\n      this._read();\n      this._handleStandaloneTag();\n      this._state = STATE_NONE;\n    }\n  }, {\n    key: \"_handleStandaloneTag\",\n    value: function _handleStandaloneTag() {\n      this._tokens = (0, _helpers.trimStandaloneToken)(this._tokens);\n    }\n\n    // Helpers\n  }, {\n    key: \"_dump\",\n    value: function _dump() {\n      var t = arguments.length <= 0 || arguments[0] === undefined ? \"\" : arguments[0];\n\n      console.log(t + \">\" + this._src.slice(this._index - 1));\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      if (this._index < this._src.length) {\n        if (this._char === \"\\n\") {\n          this._line++;\n          this._column = 0;\n        } else {\n          this._column++;\n        }\n\n        this._char = this._src[this._index];\n        this._index++;\n      } else {\n        this._char = null;\n      }\n    }\n  }, {\n    key: \"_peek\",\n    value: function _peek() {\n      if (this._index < this._src.length - 1) {\n        return this._src[this._index];\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"_skip\",\n    value: function _skip(n) {\n      for (var i = 0; i < n; i++) {\n        this._read();\n      }\n    }\n  }, {\n    key: \"_distance\",\n    value: function _distance(c) {\n      for (var i = this._index; i < this._src.length; i++) {\n        if (this._src[i] === c) {\n          return i - this._index + 1;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: \"_skipAllWhitespaces\",\n    value: function _skipAllWhitespaces() {\n      while (this._isWhitespace()) {\n        this._read();\n      }\n    }\n  }, {\n    key: \"_markTokenStartLocation\",\n    value: function _markTokenStartLocation() {\n      this._location.index = this._index - 1;\n      this._location.line = this._line;\n      this._location.column = this._column;\n    }\n  }, {\n    key: \"_markTokenEndLocation\",\n    value: function _markTokenEndLocation() {\n      var token = this._tokens[this._tokens.length - 1];\n      token.location.endIndex = this._index - 1;\n      token.location.endLine = this._line;\n      token.location.endColumn = this._column;\n    }\n  }, {\n    key: \"_isWhitespace\",\n    value: function _isWhitespace() {\n      return (/\\s/.test(this._char)\n      );\n    }\n  }, {\n    key: \"_isDelimiter\",\n    value: function _isDelimiter(d) {\n      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      var delimiter = this._delimiters[d];\n      var pos = this._index - 1 + offset;\n      return this._src.slice(pos, pos + delimiter.length) === delimiter;\n    }\n  }, {\n    key: \"_makeToken\",\n    value: function _makeToken(token) {\n      token.filename = this._filename;\n      var _location = this._location;\n      var index = _location.index;\n      var line = _location.line;\n      var column = _location.column;\n\n      token.location = {\n        filename: this._filename,\n        index: index,\n        line: line,\n        column: column\n      };\n      if (this._extensions.length) {\n        try {\n          this._extensions.forEach(function (ext) {\n            token = ext.transformToken(token);\n          });\n        } catch (e) {\n          this._setError(e.message);\n          return;\n        }\n      }\n      this._tokens.push(token);\n    }\n  }, {\n    key: \"_setError\",\n    value: function _setError(message) {\n      var error = new Error(message);\n      error.filename = this._filename;\n      error.index = this._index - 1;\n      error.line = this._line;\n      error.column = this._column;\n      this._error = error;\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      return this._error;\n    }\n  }]);\n\n  return Tokenizer;\n})();\n\nexports.Tokenizer = Tokenizer;\n\nvar R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  var matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// https://github.com/mustache/spec/pull/75\n\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _extension = __webpack_require__(0);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _token2 = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token2);\n\nvar PARENT = \"Inheritance.PARENT\";\nvar BLOCK = \"Inheritance.BLOCK\";\nvar LEAVE_SCOPE = \"Inheritance.LEAVE_SCOPE\";\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nvar Inheritance = (function (_Extension) {\n  _inherits(Inheritance, _Extension);\n\n  function Inheritance() {\n    _classCallCheck(this, Inheritance);\n\n    _get(Object.getPrototypeOf(Inheritance.prototype), \"constructor\", this).call(this);\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  _createClass(Inheritance, [{\n    key: \"transformToken\",\n    value: function transformToken(token) {\n      var _token = token;\n      var type = _token.type;\n      var name = _token.name;\n      var location = _token.location;\n\n      switch (type) {\n        case TokenType.VARIABLE:\n          if (name) {\n            if (name[0] === \"<\") {\n              if (name.length === 1) {\n                throw new Error(\"Parent partial name expected\");\n              }\n              token = {\n                type: PARENT,\n                name: name.slice(1),\n                location: location\n              };\n            } else if (name[0] === \"$\") {\n              if (name.length === 1) {\n                throw new Error(\"Block name expected\");\n              }\n              token = {\n                type: BLOCK,\n                name: name.slice(1),\n                location: location\n              };\n            }\n          }\n          break;\n      }\n      return token;\n    }\n  }, {\n    key: \"handleToken\",\n    value: function handleToken(token, parserContext) {\n      var handled = false;\n      var name = token.name;\n      var location = token.location;\n      var type = token.type;\n\n      switch (type) {\n        case PARENT:\n          parserContext.pushParent({\n            type: PARENT,\n            name: name,\n            location: location\n          });\n          handled = true;\n          break;\n\n        case BLOCK:\n          this._pushBlock({\n            type: BLOCK,\n            name: name,\n            location: location\n          }, parserContext);\n          break;\n\n        case TokenType.SECTION_CLOSE:\n          var tagNode = parserContext.parentNode;\n          if (tagNode.name !== name) {\n            parserContext[\"throw\"](\"Unexpected tag close '\" + name + \"', current tag: '\" + tagNode.name + \"'\");\n          }\n          if (isInheritanceTagType(tagNode.type)) {\n            parserContext.popParent();\n            tagNode.location.endIndex = location.endIndex;\n            tagNode.location.endLine = location.endLine;\n            parserContext.appendNode(tagNode);\n\n            //TODO move this to visit, handle whitespaces after Parent close tag.\n            var firstLine = tagNode.location.line;\n            var firstBlock = tagNode.children.find(function (c) {\n              return c.type === BLOCK;\n            });\n            if (firstBlock && firstBlock.location.line === firstLine) {\n              for (var i = 0; i < firstBlock.children.length; i++) {\n                var blockNode = firstBlock.children[i];\n                if (blockNode.type === NodeType.TEXT && /^\\s*$/.test(blockNode.text)) {\n                  blockNode.text = \"\";\n                } else {\n                  break;\n                }\n              }\n            }\n\n            handled = true;\n          }\n          break;\n\n        case TokenType.EOF:\n          if (this.top > 0) {\n            parserContext[\"throw\"](\"Unexpected EOF: tags not closed: \" + this.stack.map(function (f) {\n              return f.name;\n            }).join(\", \"));\n          }\n          break;\n      }\n      return handled;\n    }\n  }, {\n    key: \"handleNode\",\n    value: function handleNode(node, rendererContext) {\n      var top = rendererContext.top;\n      this._checkTop(top);\n\n      switch (node.type) {\n        case PARENT:\n          this._handleParent(node, rendererContext);\n          return true;\n\n        case BLOCK:\n          this._handleBlock(node, rendererContext);\n          return true;\n\n        case LEAVE_SCOPE:\n          this._blocks = null;\n          return true;\n      }\n    }\n  }, {\n    key: \"_pushBlock\",\n    value: function _pushBlock(node, parserContext) {\n      var parent = parserContext.findParentNode(function (parent) {\n        return parent.type === BLOCK && parent.name === node.name;\n      });\n      if (parent) {\n        parserContext[\"throw\"](\"Recursive block: '\" + node.name + \"'\");\n      }\n      parserContext.pushParent(node);\n    }\n  }, {\n    key: \"_handleParent\",\n    value: function _handleParent(node, rendererContext) {\n      var name = node.name;\n      var location = node.location;\n\n      var top = rendererContext.top;\n\n      this._pushParent(name, top);\n\n      if (this._blocks === null) {\n        rendererContext.pushNodes([{\n          type: LEAVE_SCOPE\n        }]);\n        this._blocks = {};\n      }\n\n      //find all blocks defined in parent\n      var blocks = {};\n      node.children.forEach(function (child) {\n        if (child.type === BLOCK) {\n          var blockName = child.name;\n          blocks[blockName] = child;\n        }\n      });\n      if (Object.keys(blocks).length) {\n        this._setDefaultBlocks(blocks);\n      }\n\n      rendererContext.pushNode({\n        type: TokenType.PARTIAL,\n        name: name,\n        location: location,\n        indent: node.indent\n      });\n    }\n  }, {\n    key: \"_handleBlock\",\n    value: function _handleBlock(node, rendererContext) {\n      var name = node.name;\n\n      var defaultBlock = this._getDefaultBlock(name);\n      if (defaultBlock) {\n        rendererContext.pushNodes(defaultBlock.children);\n      } else {\n        rendererContext.pushNodes(node.children);\n      }\n    }\n  }, {\n    key: \"_pushParent\",\n    value: function _pushParent(name, top) {\n      return this._parentStack.push({\n        name: name,\n        blocks: {},\n        top: top\n      });\n    }\n  }, {\n    key: \"_checkTop\",\n    value: function _checkTop(top) {\n      var pop = 0;\n      for (var i = this._parentStack.length - 1; i >= 0; i--) {\n        var frame = this._parentStack[i];\n        if (frame.top > top) {\n          pop++;\n        } else {\n          break;\n        }\n      }\n      if (pop > 0) {\n        this._parentStack = this._parentStack.slice(0, this._parentStack.length - pop);\n      }\n    }\n  }, {\n    key: \"_popParent\",\n    value: function _popParent() {\n      return this._parentStack.pop();\n    }\n  }, {\n    key: \"_getDefaultBlock\",\n    value: function _getDefaultBlock(name) {\n      for (var i = 0; i < this._parentStack.length; i++) {\n        var frame = this._parentStack[i];\n        if (name in frame.blocks) {\n          return frame.blocks[name];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_setDefaultBlocks\",\n    value: function _setDefaultBlocks(blocks) {\n      var topFrame = this._parentStack[this._parentStack.length - 1];\n      topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n    }\n  }]);\n\n  return Inheritance;\n})(_extension.Extension);\n\nexports.Inheritance = Inheritance;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _node = __webpack_require__(3);\n\nvar nodeTypes = _interopRequireWildcard(_node);\n\nvar _escapeHtml = __webpack_require__(9);\n\nvar _escapeHtml2 = _interopRequireDefault(_escapeHtml);\n\nvar _parser = __webpack_require__(4);\n\nvar _helpers = __webpack_require__(2);\n\nvar _extension = __webpack_require__(0);\n\nvar REPEATER_NODE_TYPE = \"_REPEATER\";\nvar MAX_PARTIAL_STACK = 10;\nvar MAX_LAMBDA_STACK = 255;\nvar MAX_NODE_COUNT = 3000;\n\nvar RenderContext = (function () {\n  function RenderContext(renderer) {\n    _classCallCheck(this, RenderContext);\n\n    this._renderer = renderer;\n  }\n\n  _createClass(RenderContext, [{\n    key: \"evaluate\",\n    value: function evaluate(name) {\n      return this._renderer._evaluate(name);\n    }\n  }, {\n    key: \"pushNodes\",\n    value: function pushNodes(nodes) {\n      this._renderer._pushNodes(nodes);\n    }\n  }, {\n    key: \"pushNode\",\n    value: function pushNode(node) {\n      this._renderer._pushNode(node);\n    }\n  }, {\n    key: \"pushContext\",\n    value: function pushContext(ctx) {\n      this._renderer._pushContext(ctx);\n    }\n  }, {\n    key: \"appendText\",\n    value: function appendText(text) {\n      this._renderer._out += text;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(src, opts) {\n      return this._renderer._parse(src, opts);\n    }\n  }, {\n    key: \"getParsedPartial\",\n    value: function getParsedPartial(name) {\n      return this._renderer._getParsedPartial(name);\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(message, location) {\n      return this._renderer._throw(message, location);\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this._renderer._stack.length;\n    }\n  }, {\n    key: \"result\",\n    get: function get() {\n      return this._renderer._out;\n    }\n  }]);\n\n  return RenderContext;\n})();\n\nvar Renderer = (function () {\n  function Renderer(src) {\n    var _this = this;\n\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Renderer);\n\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    this._filename = opts.filename;\n\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || (0, _extension.instantiateAll)(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(function (k) {\n        _this._partialCached[k] = _this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = \"\";\n    this._transformNodeResult = function (node, result, nodeResult) {\n      return _this._extensions.reduce(function (r, e) {\n        return e.transformNodeResult(node, result, r);\n      }, nodeResult);\n    };\n  }\n\n  _createClass(Renderer, [{\n    key: \"render\",\n    value: function render(context) {\n      var _this2 = this;\n\n      this._out = \"\";\n      this._stack = [];\n      this._contextStack = [];\n      this._partialStack = [];\n      this._lambdaStack = [];\n\n      this._pushContext(context);\n\n      //push root nodes\n      var rootNode = this._parsed ? this._src : this._parse(this._src, { filename: this._filename });\n      this._stack = rootNode.children.slice(0).reverse();\n\n      var node_count = 0;\n\n      var newline = true;\n\n      var _loop = function () {\n        var top = _this2._stack.length - 1;\n        var node = _this2._stack[top];\n\n        if (node.type !== nodeTypes.TEXT) {\n          node_count++;\n          if (node_count > MAX_NODE_COUNT) {\n            _this2._throw(\"Possible infinity loop detected: last node type is '\" + node.type + \"'\", node.location);\n          }\n        }\n\n        var handled = false;\n        if (_this2._extensions) {\n          _this2._extensions.forEach(function (ext) {\n            if (ext.handleNode(node, _this2._renderContext)) {\n              handled = true;\n            }\n          });\n        }\n\n        if (handled) {\n          _this2._stack.splice(top, 1);\n        } else {\n          var partial = _this2._partialStack.length ? _this2._partialStack[_this2._partialStack.length - 1] : null;\n\n          //insert indent\n          if (node.type in nodeTypes) {\n            if (newline && partial !== null && partial.indent.length > 0) {\n              _this2._out += partial.indent;\n            }\n          }\n\n          var value = undefined;\n          switch (node.type) {\n            case nodeTypes.VARIABLE:\n              value = _this2._evaluate(node.name);\n              if (isFunction(value)) {\n                _this2._popNode();\n                _this2._expandLambda(node, value);\n              } else {\n                if (!!value) {\n                  var result = node.unescaped ? value : (0, _escapeHtml2[\"default\"])(value);\n                  _this2._out += _this2._transformNodeResult(node, _this2._out, result);\n                }\n                _this2._popNode();\n              }\n              break;\n\n            case nodeTypes.SECTION:\n              value = _this2._evaluate(node.name);\n              if (isFunction(value)) {\n                _this2._popNode();\n                _this2._expandLambda(node, value);\n              } else {\n                var isList = Array.isArray(value);\n\n                if (isList && value.length === 0) {\n                  //Empty lists should behave like falsey values.\n                  value = false;\n                  isList = false;\n                }\n\n                var testResult = !!value;\n                if (node.inverted) {\n                  testResult = !testResult;\n                }\n\n                if (testResult) {\n                  if (isList) {\n                    _this2._popNode();\n                    _this2._pushRepeaterNode(value.length, node.children, value);\n                  } else {\n                    _this2._popNode();\n                    _this2._pushContext(value);\n                    _this2._pushNodes(node.children);\n                  }\n                } else {\n                  _this2._popNode();\n                }\n              }\n              break;\n\n            case nodeTypes.TEXT:\n              _this2._out += _this2._transformNodeResult(node, _this2._out, node.text);\n              _this2._popNode();\n              break;\n\n            case nodeTypes.COMMENT:\n              _this2._popNode();\n              break;\n\n            case nodeTypes.PARTIAL:\n              _this2._popNode();\n              _this2._expandPartial(node);\n              break;\n\n            case nodeTypes.DELIMITER_CHANGE:\n              _this2._popNode();\n              _this2._delimiters = node.delimiters.slice(0);\n              break;\n\n            case REPEATER_NODE_TYPE:\n              if (node.count < node.repeat) {\n                var repeatIndex = node.count;\n                if (repeatIndex === 0) {\n                  node.contextIndex = _this2._pushContext(node.contexts[0]);\n                } else {\n                  _this2._replaceContextAt(node.contextIndex, node.contexts[repeatIndex]);\n                }\n                _this2._pushNodes(node.children);\n                node.count++;\n              } else {\n                _this2._popNode();\n              }\n              break;\n\n            default:\n              _this2._popNode();\n              break;\n          }\n        }\n        _this2._checkStacks();\n        newline = _this2._out.length === 0 || _this2._out[_this2._out.length - 1] === \"\\n\";\n      };\n\n      while (this._stack.length > 0) {\n        _loop();\n      }\n\n      return this._extensions.reduce(function (result, ext) {\n        return ext.transformResult(result);\n      }, this._out);\n    }\n  }, {\n    key: \"_parse\",\n    value: function _parse(src) {\n      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      opts.extensions = this._extensions;\n      var parser = new _parser.Parser(opts);\n      return parser.parse(src);\n    }\n  }, {\n    key: \"_pushNodes\",\n    value: function _pushNodes(list) {\n      for (var i = list.length - 1; i >= 0; i--) {\n        this._stack.push(list[i]);\n      }\n    }\n  }, {\n    key: \"_pushNode\",\n    value: function _pushNode(node) {\n      this._stack.push(node);\n    }\n  }, {\n    key: \"_popNode\",\n    value: function _popNode() {\n      this._stack.pop();\n    }\n  }, {\n    key: \"_pushRepeaterNode\",\n    value: function _pushRepeaterNode(repeat, nodes, contexts) {\n      this._stack.push({\n        type: REPEATER_NODE_TYPE,\n        count: 0,\n        repeat: repeat,\n        children: nodes.slice(0),\n        contexts: contexts\n      });\n    }\n  }, {\n    key: \"_pushContext\",\n    value: function _pushContext(context) {\n      return this._contextStack.push({\n        context: context,\n        sp: this._stack.length\n      }) - 1;\n    }\n  }, {\n    key: \"_replaceContextAt\",\n    value: function _replaceContextAt(index, context) {\n      if (index < 0 || index > this._contextStack.length - 1) {\n        throw new RangeError(\"Huz context index out of range.\");\n      }\n      this._contextStack[index].context = context;\n    }\n  }, {\n    key: \"_pushPartial\",\n    value: function _pushPartial(_ref) {\n      var name = _ref.name;\n      var indent = _ref.indent;\n      var location = _ref.location;\n\n      this._partialStack.push({\n        name: name,\n        indent: indent || \"\",\n        location: location,\n        sp: this._stack.length\n      });\n    }\n  }, {\n    key: \"_pushLambda\",\n    value: function _pushLambda(_ref2) {\n      var name = _ref2.name;\n      var location = _ref2.location;\n\n      this._lambdaStack.push({\n        name: name,\n        location: location,\n        sp: this._stack.length\n      });\n    }\n  }, {\n    key: \"_checkStacks\",\n    value: function _checkStacks() {\n      if (this._stack.length < this._contextStack[this._contextStack.length - 1].sp) {\n        this._contextStack.pop();\n      }\n\n      if (this._partialStack.length > 0 && this._stack.length === this._partialStack[this._partialStack.length - 1].sp) {\n        this._partialStack.pop();\n      }\n\n      if (this._lambdaStack.length > 0 && this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp) {\n        this._lambdaStack.pop();\n      }\n    }\n  }, {\n    key: \"_evaluate\",\n    value: function _evaluate(name) {\n      if (name === \".\") {\n        return this._contextStack[this._contextStack.length - 1].context;\n      }\n\n      var path = name.split(\".\");\n      for (var i = this._contextStack.length - 1; i >= 0; i--) {\n        var context = this._contextStack[i].context;\n        if (context === null || typeof context !== \"object\") {\n          continue;\n        }\n\n        var current = context;\n        var resolved = true;\n        for (var pi = 0; pi < path.length; pi++) {\n          var key = path[pi];\n          if (typeof current === \"object\" && current !== null && current.hasOwnProperty(key)) {\n            current = current[key];\n          } else {\n            resolved = false;\n            break;\n          }\n        }\n\n        if (resolved) {\n          return current;\n        }\n      }\n      return \"\";\n    }\n  }, {\n    key: \"_getParsedPartial\",\n    value: function _getParsedPartial(name) {\n      if (this._partialCached.hasOwnProperty(name)) {\n        return this._partialCached[name];\n      } else {\n        if (!this._partials.hasOwnProperty(name)) {\n          return null;\n        }\n        var ast = this._parse(this._partials[name], { filename: name });\n        var nodes = this._partialCached[name] = ast.children;\n        return nodes;\n      }\n    }\n  }, {\n    key: \"_expandPartial\",\n    value: function _expandPartial(node) {\n      var name = node.name;\n\n      var nodes = this._getParsedPartial(name);\n\n      if (nodes === null) {\n        //The empty string should be used when the named partial is not found.\n        return;\n      }\n\n      this._pushPartial(node);\n\n      if (this._partialStack.length > MAX_PARTIAL_STACK) {\n        this._throw(\"Possible partial short circuit: \" + this._partialStack.map(function (f) {\n          return f.name + \"@\" + f.location.filename + \":\" + (f.location.line + 1);\n        }).concat([name]).join(\" -> \"), node.location);\n      }\n\n      this._pushNodes(nodes);\n    }\n  }, {\n    key: \"_expandLambda\",\n    value: function _expandLambda(node, lambda) {\n      var name = node.name;\n\n      this._pushLambda(node);\n\n      if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n        this._throw(\"Possible lambda short circuit: \" + this._lambdaStack.map(function (f) {\n          return f.name + \"@\" + f.location.filename + \":\" + (f.location.line + 1);\n        }).concat([name]).join(\" -> \"), node.location);\n      }\n\n      var ast = undefined;\n      var skipped = false;\n      if (node.type === nodeTypes.VARIABLE) {\n        var code = lambda();\n        if (code) {\n          //A lambda's return value should parse with the default delimiters.\n          ast = this._parse(\"\" + code, { filename: \"[lambda]\" });\n          if (!node.unescaped) {\n            //Lambda results should be appropriately escaped.\n            (0, _helpers.walk)(ast, function (node) {\n              if (node.type === nodeTypes.TEXT) {\n                node.text = (0, _escapeHtml2[\"default\"])(node.text);\n              }\n            });\n          }\n        } else {\n          skipped = true;\n        }\n      } else if (node.type === nodeTypes.SECTION) {\n        var code = lambda(node.raw);\n        if (code) {\n          //Lambdas used for inverted sections should be considered truthy.\n          //Lambdas used for sections should parse with the current delimiters.\n          ast = this._parse(\"\" + code, {\n            filename: \"[#lambda]\",\n            delimiters: this._delimiters.slice(0)\n          });\n        } else {\n          skipped = true;\n        }\n      }\n\n      if (!skipped) {\n        this._pushNodes(ast.children);\n      }\n    }\n  }, {\n    key: \"_throw\",\n    value: function _throw(message, location) {\n      var e = new Error(message);\n      e.filename = location.filename;\n      e.location = location;\n      throw e;\n    }\n  }]);\n\n  return Renderer;\n})();\n\nexports.Renderer = Renderer;\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == \"[object Function]\";\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = parse;\nexports.compile = compile;\nexports.render = render;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _parser = __webpack_require__(4);\n\nvar _renderer = __webpack_require__(7);\n\nvar _token = __webpack_require__(1);\n\nvar TokenType = _interopRequireWildcard(_token);\n\nvar _node = __webpack_require__(3);\n\nvar NodeType = _interopRequireWildcard(_node);\n\nvar _helpers = __webpack_require__(2);\n\nvar Helpers = _interopRequireWildcard(_helpers);\n\nvar _extension = __webpack_require__(0);\n\nvar _extensionsInheritance = __webpack_require__(6);\n\nvar _tokenizer = __webpack_require__(5);\n\nObject.defineProperty(exports, \"Tokenizer\", {\n  enumerable: true,\n  get: function get() {\n    return _tokenizer.Tokenizer;\n  }\n});\nexports.Parser = _parser.Parser;\nexports.Renderer = _renderer.Renderer;\nexports.TokenType = TokenType;\nexports.NodeType = NodeType;\nObject.defineProperty(exports, \"Extension\", {\n  enumerable: true,\n  get: function get() {\n    return _extension.Extension;\n  }\n});\n\n(0, _extension.register)(_extensionsInheritance.Inheritance);\n\nfunction parse(src, opts) {\n  var parser = new _parser.Parser(opts);\n  return parser.parse(src);\n}\n\nfunction compile(src, opts) {\n  return new _renderer.Renderer(src, opts);\n}\n\nfunction render(src, context, opts) {\n  var r = compile(src, opts);\n  return r.render(context);\n}\n\nexports.register = _extension.register;\nexports.Helpers = Helpers;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// huz.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 575cb45158c1a5d0f929","const registry = [];\n\nexport class Extension {\n  //called by tokenizer\n  transformToken(token) { return token; }\n\n  //called by parser\n  handleToken(token, parserContext) { }\n  visit(root) { return root; }\n  \n  //called by renderer\n  handleNode(node, renderContext) { }\n  transformNodeResult(node, result, nodeResult) { return nodeResult; }\n  transformResult(result) { return result; }\n}\n\nexport function instantiateAll(opts) {\n  return registry.map(ctor => {\n    return new ctor(opts);\n  });\n}\n\nexport function register(constructor) {\n  return registry.push(constructor);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/extension.js","export const EOF                    = 'EOF';\nexport const TEXT                   = 'TEXT';\nexport const PARTIAL                = 'PARTIAL';\nexport const INVERTED_SECTION_OPEN  = 'INVERTED_SECTION_OPEN';\nexport const SECTION_OPEN           = 'SECTION_OPEN';\nexport const SECTION_CLOSE          = 'SECTION_CLOSE';\nexport const UNESCAPED_VARIABLE     = 'UNESCAPED_VARIABLE';\nexport const COMMENT                = 'COMMENT';\nexport const VARIABLE               = 'VARIABLE';\nexport const DELIMITER_CHANGE \t\t\t= 'DELIMITER_CHANGE';\n\n\n// WEBPACK FOOTER //\n// ./src/token.js","import * as TokenType from './token';\n\nexport function walk(root, modifier) {\n  let stack = root.children.slice(0).reverse();\n  while (stack.length) {\n    const node = stack.pop();\n    modifier(node);\n    if (node.children !== undefined) {\n      stack = stack.concat(node.children.slice(0).reverse());\n    }\n  }\n}\n\nexport function visit(root, visitor) {\n  let stack = [root];\n  while (stack.length) {\n    const parent = stack.pop();\n    for (let i = 0; i < parent.children.length; i++) {\n      const child = parent.children[i];\n      const modified = visitor.visit(child) || child;\n      if (modified !== child) {\n        parent.children[i] = modified;\n      }\n      if (child.children && child.children.length) {\n        stack.push(child);\n      }\n    }\n  }\n}\n\nexport function trimStandaloneToken(tokens) {\n  const count = tokens.length;\n\n  if (count === 0) {\n    return tokens;\n  }\n\n  let open = null;\n  let inline = 0;\n  let standalone = true;\n  let indentTokens = [];\n  for (let i = 0; standalone && i < count; i++) {\n    const token = tokens[i];\n    switch (token.type) {\n      case TokenType.VARIABLE:\n      case TokenType.UNESCAPED_VARIABLE:\n        standalone = false;\n        break;\n      case TokenType.TEXT:\n        if (isStringWhitespace(token.text)) {\n          if (inline === 0) {\n            indentTokens.push(token);\n          }\n        } else {\n          standalone = false;\n        }\n        break;\n      case TokenType.DELIMITER_CHANGE:\n      case TokenType.COMMENT:\n        if (open !== null) {\n          open.push(token);\n        } else {\n          inline ++;\n        }\n        break;\n      case TokenType.SECTION_CLOSE:\n        if (open) {\n          if (open[0].name === token.name) {\n            open = null;\n          } else {\n            standalone = false;\n          }\n        } else {\n          inline ++;\n        }\n        break;\n      default: //section-like tags\n        if (open === null) {\n          open = [token];\n          inline ++;\n        } else {\n          standalone = false;\n        }\n        break;\n    }\n\n    if (inline > 1) {\n      standalone = false;\n    }\n  }\n\n  if (open && open.length > 1) {\n    standalone = false;\n  }\n  \n  if (standalone) {\n    //all whitespace\n    if (indentTokens.length === count) {\n      return tokens;\n    }\n\n    let tailWSNodeCount = 0;\n    for (let i = count - 1; i >= 0; i--) {\n      const token = tokens[i];\n      if (token.type == TokenType.TEXT && isStringWhitespace(token.text)) {\n        tailWSNodeCount ++;\n      } else {\n        break;\n      }\n    }\n\n    if (indentTokens.length > 0 || tailWSNodeCount > 0) {\n      //trim\n      tokens = tokens.slice(indentTokens.length, count - tailWSNodeCount);\n      if (indentTokens.length) {\n        let indent = '';\n        indentTokens.forEach(t => { indent += t.text });\n        tokens[0].indent = indent;\n      }\n    }\n  }\n  return tokens;\n}\n\nfunction isStringWhitespace(str) {\n  return /^\\s*$/.test(str);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/helpers.js","export const ROOT             = 'ROOT';\nexport const VARIABLE         = 'VARIABLE';\nexport const SECTION          = 'SECTION';\nexport const TEXT             = 'TEXT';\nexport const COMMENT          = 'COMMENT';\nexport const PARTIAL          = 'PARTIAL';\nexport const DELIMITER_CHANGE = 'DELIMITER_CHANGE';\n\n\n// WEBPACK FOOTER //\n// ./src/node.js","import * as TokenType from \"./token\";\nimport * as NodeType from \"./node\";\nimport { Tokenizer } from \"./tokenizer\";\nimport { visit } from \"./helpers\";\nimport { instantiateAll } from \"./extension\";\n\nclass ParserContext {\n  constructor(parser) {\n    this._parser = parser;\n  }\n\n  appendNode(node) {\n    this._parser._appendNode(node);\n  }\n\n  pushParent(node) {\n    this._parser._pushParent(node);\n  }\n\n  popParent() {\n    return this._parser._popParent();\n  }\n\n  get filename() {\n    return this._parser._filename;\n  }\n\n  get top() {\n    return this._parser._stack.length;\n  }\n\n  get parentNode() {\n    return this._parser._stack.length > 0\n      ? this._parser._stack[this._parser._stack.length - 1]\n      : null;\n  }\n\n  /// deprecated\n  get tailNode() {\n    return this.parentNode;\n  }\n\n  findParentNode(f) {\n    for (let i = this._parser._stack.length - 1; i >= 0; i--) {\n      const item = this._parser._stack[i];\n      if (f(item)) {\n        return item;\n      }\n    }\n    return null;\n  }\n\n  throw(message) {\n    return this._parser._throw(message);\n  }\n}\n\nexport class Parser {\n  constructor(opts = {}) {\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    this._filename = opts.filename || \"\";\n\n    if (this._extensions.length > 0) {\n      this._parserContext = new ParserContext(this);\n    }\n\n    this._stack = null;\n    this._lastToken = null;\n    this._src = null;\n  }\n\n  parse(src) {\n    const rootNode = {\n      type: NodeType.ROOT,\n      children: []\n    };\n    this._src = src;\n    this._stack = [rootNode];\n    this._lastToken = null;\n    this._parseNodes(src);\n\n    if (this._extensions.length > 0) {\n      for (let i = 0; i < this._extensions.length; i++) {\n        this._extensions[i].visit(rootNode);\n      }\n    }\n\n    return rootNode;\n  }\n\n  _addNodeToken(node) {\n    const token = this._lastToken;\n    if (node.tokens) {\n      node.tokens.push(token);\n    } else {\n      node.tokens = [token];\n    }\n  }\n\n  _appendNode(node) {\n    this._addNodeToken(node);\n    node.location.filename = this._filename;\n    this._stack[this._stack.length - 1].children.push(node);\n    return node;\n  }\n\n  _getTop() {\n    return this._stack[this._stack.length - 1];\n  }\n\n  _clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  _makeLocation(beginLocation, endLocation) {\n    const location = this._clone(beginLocation);\n    if (endLocation) {\n      location.endIndex = endLocation.endIndex;\n      location.endLine = endLocation.endLine;\n    }\n    return location;\n  }\n\n  _parseNodes(src) {\n    let initialStackSize = this._stack.length;\n    let token;\n    const z = new Tokenizer(src, {\n      delimiters: this._delimiters.slice(0),\n      extensions: this._extensions,\n      filename: this._filename\n    });\n\n    do {\n      token = z.getNextToken();\n\n      if (z.error !== null) {\n        throw z.error;\n      }\n\n      this._lastToken = token;\n\n      let handled = false;\n      if (this._extensions) {\n        for (let i = 0; i < this._extensions.length; i++) {\n          const ext = this._extensions[i];\n          if (ext.handleToken(token, this._parserContext) === true) {\n            handled = true;\n            break;\n          }\n        }\n      }\n\n      if (!handled) {\n        switch (token.type) {\n          case TokenType.TEXT:\n            this._appendNode({\n              type: NodeType.TEXT,\n              text: token.text,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.VARIABLE:\n          case TokenType.UNESCAPED_VARIABLE:\n            this._appendNode({\n              type: NodeType.VARIABLE,\n              name: token.name,\n              unescaped: token.type === TokenType.UNESCAPED_VARIABLE,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.SECTION_OPEN:\n            this._handleSectionOpen(token);\n            break;\n\n          case TokenType.INVERTED_SECTION_OPEN:\n            this._handleSectionOpen(token, true);\n            break;\n\n          case TokenType.SECTION_CLOSE:\n            this._handleSectionClose(token);\n            break;\n\n          case TokenType.PARTIAL:\n            this._appendNode({\n              type: NodeType.PARTIAL,\n              name: token.name,\n              indent: token.indent,\n              location: this._makeLocation(token.location)\n            });\n            break;\n\n          case TokenType.COMMENT:\n            this._handleComment(token);\n            break;\n\n          case TokenType.DELIMITER_CHANGE:\n            this._appendNode({\n              type: NodeType.DELIMITER_CHANGE,\n              delimiters: token.delimiters,\n              location: this._makeLocation(token.location)\n            });\n            break;\n        }\n      }\n    } while (token.type !== TokenType.EOF);\n\n    if (this._stack.length > initialStackSize) {\n      this._throw(\n        \"Unexpected EOF: sections not closed: \" +\n          this._stack\n            .slice(initialStackSize)\n            .map(n => `'${n.name}'`)\n            .join(\", \")\n      );\n    } else if (this._stack.length < initialStackSize) {\n      this._throw(\"Internal error.\");\n    }\n  }\n\n  _throw(message) {\n    const e = new Error(message);\n    e.filename = this._lastToken.location.filename;\n    e.location = this._lastToken.location;\n    throw e;\n  }\n\n  _pushParent(node) {\n    this._addNodeToken(node);\n    node.children = [];\n    this._stack.push(node);\n  }\n\n  _popParent() {\n    return this._stack.pop();\n  }\n\n  _handleSectionOpen(token, inverted = false) {\n    const { name, location } = token;\n    this._pushParent({\n      type: NodeType.SECTION,\n      name,\n      inverted,\n      location\n    });\n  }\n\n  _handleSectionClose(token) {\n    const { name, location } = token;\n    const section = this._popParent();\n    if (section.type !== NodeType.SECTION) {\n      this._throw(`Unexpected SECTION_CLOSE: '${name}'`);\n    }\n\n    if (section.name !== name) {\n      this._throw(\n        `Unexpected SECTION_CLOSE: '${name}', current section: '${\n          section.name\n        }'`\n      );\n    }\n\n    section.raw = this._src.slice(section.location.endIndex, location.index);\n    section.location = this._makeLocation(section.location, token.location);\n\n    this._appendNode(section);\n  }\n\n  _handleComment(token) {\n    const { content, location } = token;\n    this._appendNode({\n      type: NodeType.COMMENT,\n      content,\n      location: this._makeLocation(location)\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/parser.js","import * as TokenType from \"./token\";\nimport { instantiateAll } from \"./extension\";\nimport { trimStandaloneToken } from \"./helpers\";\n\nconst STATE_NONE = \"STATE_NONE\";\nconst STATE_EOF = \"STATE_EOF\";\nconst STATE_TEXT = \"STATE_TEXT\";\nconst STATE_TEXT_BREAK = \"STATE_TEXT_BREAK\";\nconst STATE_TAG = \"STATE_TAG\";\n\nconst DELIMITER_LEFT = 0;\nconst DELIMITER_RIGHT = 1;\n\nexport class Tokenizer {\n  constructor(src, opts = {}) {\n    this._extensions = opts.extensions || instantiateAll();\n    this._src = src;\n    this._index = 0;\n    this._char = null;\n    this._tokens = [];\n    this._line = 0;\n    this._column = 0;\n    this._state = STATE_NONE;\n    this._error = null;\n    this._filename = opts.filename;\n    this._location = {\n      index: 0,\n      line: 0,\n      column: 0\n    };\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  getNextToken() {\n    if (this._tokens.length > 0) {\n      return this._tokens.shift();\n    }\n\n    let done = false;\n    let matched = false;\n    do {\n      //console.log(this._state, this._tokens);\n      if (this._error !== null) {\n        return null;\n      }\n\n      if (this._state !== STATE_NONE) {\n        matched = true;\n        this._markTokenStartLocation();\n      }\n\n      switch (this._state) {\n        case STATE_NONE:\n          this._read();\n          break;\n\n        case STATE_EOF:\n          this._handleEOF();\n          done = true;\n          break;\n\n        case STATE_TEXT:\n          this._handleText();\n          break;\n\n        case STATE_TEXT_BREAK:\n          this._handleTextBreak();\n          done = true;\n          break;\n\n        case STATE_TAG:\n          this._handleTag();\n          break;\n      }\n\n      if (matched && !this._error) {\n        this._markTokenEndLocation();\n        matched = false;\n      }\n\n      if (this._state === STATE_NONE) {\n        if (this._char === null) {\n          this._state = STATE_EOF;\n        } else if (this._char === \"\\n\") {\n          this._state = STATE_TEXT_BREAK;\n        } else if (this._isDelimiter(DELIMITER_LEFT)) {\n          this._state = STATE_TAG;\n        } else {\n          this._state = STATE_TEXT;\n        }\n      }\n    } while (!done);\n\n    return this._error === null ? this._tokens.shift() : null;\n  }\n\n  // Handlers\n\n  _handleEOF() {\n    this._handleStandaloneTag();\n    this._makeToken({\n      type: TokenType.EOF\n    });\n  }\n\n  _handleTag() {\n    const [left, right] = this._delimiters;\n    this._skip(left.length);\n    this._skipAllWhitespaces();\n\n    if (this._char === null) {\n      this._setError(\"Unclosed tag.\");\n    } else if (this._isDelimiter(DELIMITER_RIGHT)) {\n      this._handleEmptyTag();\n    } else {\n      const tagTypeChar = this._char;\n      if (tagTypeChar === \"{\") {\n        this._handleVariableCurly();\n      } else {\n        let tagContentStart = this._index - 1;\n        //read content\n        while (!this._isDelimiter(DELIMITER_RIGHT) && this._char !== null) {\n          this._read();\n        }\n\n        if (this._char === null) {\n          this._setError(\"Unclosed tag.\");\n        } else {\n          const content = this._src.slice(tagContentStart, this._index - 1);\n          switch (tagTypeChar) {\n            case \">\":\n              this._handleSimpleTag(TokenType.PARTIAL, content);\n              break;\n            case \"^\":\n              this._handleSimpleTag(TokenType.INVERTED_SECTION_OPEN, content);\n              break;\n            case \"#\":\n              this._handleSimpleTag(TokenType.SECTION_OPEN, content);\n              break;\n            case \"/\":\n              this._handleSimpleTag(TokenType.SECTION_CLOSE, content);\n              break;\n\n            case \"!\":\n              this._handleComment(content.substr(1));\n              break;\n\n            case \"=\":\n              this._handleDelimiterChange(content);\n              break;\n            case \"&\":\n              this._handleVariable(content.substr(1), true);\n              break;\n            default:\n              this._handleVariable(content);\n              break;\n          }\n        }\n      }\n    }\n    if (this._error === null) {\n      //eat right\n      for (let i = 0; i < right.length; i++) {\n        this._read();\n      }\n    }\n\n    this._state = STATE_NONE;\n  }\n\n  _handleDelimiterChange(content) {\n    const newDelimiters = extractNewDelimiters(content);\n    if (newDelimiters === null) {\n      this._setError(\"Invalid change delimiter syntax.\");\n    } else {\n      const [left, right] = newDelimiters;\n      this._delimiters = newDelimiters;\n      this._makeToken({\n        type: TokenType.DELIMITER_CHANGE,\n        delimiters: [left, right]\n      });\n    }\n  }\n\n  _handleSimpleTag(type, content) {\n    this._makeToken({ type, name: content.substr(1).trim() });\n  }\n\n  _handleComment(content) {\n    this._makeToken({\n      type: TokenType.COMMENT,\n      content\n    });\n  }\n\n  _handleVariableCurly() {\n    this._read(); //eat '{'\n    const begin = this._index - 1;\n    const d = this._distance(\"}\");\n    if (d === -1) {\n      this._setError(\"Unclosed variable tag: missingright curly.\");\n    } else {\n      const content = this._src.slice(begin, begin + d);\n      this._skip(d + 1); //skip '}'\n      this._skipAllWhitespaces();\n      if (!this._isDelimiter(DELIMITER_RIGHT)) {\n        this._setError(\"Unclosed variable: missing right delimiter.\");\n      } else {\n        this._makeToken({\n          type: TokenType.UNESCAPED_VARIABLE,\n          name: content.trim()\n        });\n      }\n    }\n  }\n\n  _handleEmptyTag() {\n    this._makeToken({\n      type: TokenType.VARIABLE,\n      name: \"\"\n    });\n  }\n\n  _handleVariable(content, unescaped) {\n    this._makeToken({\n      type: unescaped ? TokenType.UNESCAPED_VARIABLE : TokenType.VARIABLE,\n      name: content.trim()\n    });\n  }\n\n  _handleText() {\n    let done = false;\n    let index = this._index - 1;\n    let length = 0;\n    do {\n      const c = this._char;\n\n      if (c === null || c === \"\\n\" || this._isDelimiter(DELIMITER_LEFT)) {\n        done = true;\n      } else {\n        length++;\n      }\n\n      if (!done) {\n        this._read();\n      }\n    } while (!done);\n\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: this._src.slice(index, index + length)\n    });\n\n    this._state = STATE_NONE;\n  }\n\n  _handleTextBreak() {\n    this._makeToken({\n      type: TokenType.TEXT,\n      text: \"\\n\"\n    });\n    this._read();\n    this._handleStandaloneTag();\n    this._state = STATE_NONE;\n  }\n\n  _handleStandaloneTag() {\n    this._tokens = trimStandaloneToken(this._tokens);\n  }\n\n  // Helpers\n  _dump(t = \"\") {\n    console.log(t + \">\" + this._src.slice(this._index - 1));\n  }\n\n  _read() {\n    if (this._index < this._src.length) {\n      if (this._char === \"\\n\") {\n        this._line++;\n        this._column = 0;\n      } else {\n        this._column++;\n      }\n\n      this._char = this._src[this._index];\n      this._index++;\n    } else {\n      this._char = null;\n    }\n  }\n\n  _peek() {\n    if (this._index < this._src.length - 1) {\n      return this._src[this._index];\n    } else {\n      return null;\n    }\n  }\n\n  _skip(n) {\n    for (let i = 0; i < n; i++) {\n      this._read();\n    }\n  }\n\n  _distance(c) {\n    for (let i = this._index; i < this._src.length; i++) {\n      if (this._src[i] === c) {\n        return i - this._index + 1;\n      }\n    }\n    return -1;\n  }\n\n  _skipAllWhitespaces() {\n    while (this._isWhitespace()) {\n      this._read();\n    }\n  }\n\n  _markTokenStartLocation() {\n    this._location.index = this._index - 1;\n    this._location.line = this._line;\n    this._location.column = this._column;\n  }\n\n  _markTokenEndLocation() {\n    const token = this._tokens[this._tokens.length - 1];\n    token.location.endIndex = this._index - 1;\n    token.location.endLine = this._line;\n    token.location.endColumn = this._column;\n  }\n\n  _isWhitespace() {\n    return /\\s/.test(this._char);\n  }\n\n  _isDelimiter(d, offset = 0) {\n    const delimiter = this._delimiters[d];\n    const pos = this._index - 1 + offset;\n    return this._src.slice(pos, pos + delimiter.length) === delimiter;\n  }\n\n  _makeToken(token) {\n    token.filename = this._filename;\n    const { index, line, column } = this._location;\n    token.location = {\n      filename: this._filename,\n      index,\n      line,\n      column\n    };\n    if (this._extensions.length) {\n      try {\n        this._extensions.forEach(ext => {\n          token = ext.transformToken(token);\n        });\n      } catch (e) {\n        this._setError(e.message);\n        return;\n      }\n    }\n    this._tokens.push(token);\n  }\n\n  _setError(message) {\n    const error = new Error(message);\n    error.filename = this._filename;\n    error.index = this._index - 1;\n    error.line = this._line;\n    error.column = this._column;\n    this._error = error;\n  }\n}\n\nconst R_DELIMITER_CHANGE = /=[\\s\\n]*([^\\s\\n]*?)[\\s\\n]+([^\\s\\n]*?)[\\s\\n]*=[\\s\\n]*$/;\nfunction extractNewDelimiters(tagContent) {\n  const matches = tagContent.match(R_DELIMITER_CHANGE);\n  if (matches) {\n    return matches.slice(1);\n  } else {\n    return null;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tokenizer.js","// https://github.com/mustache/spec/pull/75\n\nimport { Extension, register } from \"../extension\";\nimport * as NodeType from \"../node\";\nimport * as TokenType from \"../token\";\n\nconst PARENT = \"Inheritance.PARENT\";\nconst BLOCK = \"Inheritance.BLOCK\";\nconst LEAVE_SCOPE = \"Inheritance.LEAVE_SCOPE\";\n\nfunction isInheritanceTagType(type) {\n  return type === PARENT || type === BLOCK;\n}\n\nexport class Inheritance extends Extension {\n  constructor() {\n    super();\n\n    this._blocks = null;\n    this._parentStack = [];\n  }\n\n  transformToken(token) {\n    const { type, name, location } = token;\n    switch (type) {\n      case TokenType.VARIABLE:\n        if (name) {\n          if (name[0] === \"<\") {\n            if (name.length === 1) {\n              throw new Error(\"Parent partial name expected\");\n            }\n            token = {\n              type: PARENT,\n              name: name.slice(1),\n              location\n            };\n          } else if (name[0] === \"$\") {\n            if (name.length === 1) {\n              throw new Error(\"Block name expected\");\n            }\n            token = {\n              type: BLOCK,\n              name: name.slice(1),\n              location\n            };\n          }\n        }\n        break;\n    }\n    return token;\n  }\n\n  handleToken(token, parserContext) {\n    let handled = false;\n    const { name, location, type } = token;\n    switch (type) {\n      case PARENT:\n        parserContext.pushParent({\n          type: PARENT,\n          name,\n          location\n        });\n        handled = true;\n        break;\n\n      case BLOCK:\n        this._pushBlock(\n          {\n            type: BLOCK,\n            name,\n            location\n          },\n          parserContext\n        );\n        break;\n\n      case TokenType.SECTION_CLOSE:\n        const tagNode = parserContext.parentNode;\n        if (tagNode.name !== name) {\n          parserContext.throw(\n            `Unexpected tag close '${name}', current tag: '${tagNode.name}'`\n          );\n        }\n        if (isInheritanceTagType(tagNode.type)) {\n          parserContext.popParent();\n          tagNode.location.endIndex = location.endIndex;\n          tagNode.location.endLine = location.endLine;\n          parserContext.appendNode(tagNode);\n\n          //TODO move this to visit, handle whitespaces after Parent close tag.\n          const firstLine = tagNode.location.line;\n          const firstBlock = tagNode.children.find(c => c.type === BLOCK);\n          if (firstBlock && firstBlock.location.line === firstLine) {\n            for (let i = 0; i < firstBlock.children.length; i++) {\n              const blockNode = firstBlock.children[i];\n              if (\n                blockNode.type === NodeType.TEXT &&\n                /^\\s*$/.test(blockNode.text)\n              ) {\n                blockNode.text = \"\";\n              } else {\n                break;\n              }\n            }\n          }\n\n          handled = true;\n        }\n        break;\n\n      case TokenType.EOF:\n        if (this.top > 0) {\n          parserContext.throw(\n            \"Unexpected EOF: tags not closed: \" +\n              this.stack.map(f => f.name).join(\", \")\n          );\n        }\n        break;\n    }\n    return handled;\n  }\n\n  handleNode(node, rendererContext) {\n    const top = rendererContext.top;\n    this._checkTop(top);\n\n    switch (node.type) {\n      case PARENT:\n        this._handleParent(node, rendererContext);\n        return true;\n\n      case BLOCK:\n        this._handleBlock(node, rendererContext);\n        return true;\n\n      case LEAVE_SCOPE:\n        this._blocks = null;\n        return true;\n    }\n  }\n\n  _pushBlock(node, parserContext) {\n    const parent = parserContext.findParentNode(\n      parent => parent.type === BLOCK && parent.name === node.name\n    );\n    if (parent) {\n      parserContext.throw(`Recursive block: '${node.name}'`);\n    }\n    parserContext.pushParent(node);\n  }\n\n  _handleParent(node, rendererContext) {\n    const { name, location } = node;\n    const top = rendererContext.top;\n\n    this._pushParent(name, top);\n\n    if (this._blocks === null) {\n      rendererContext.pushNodes([\n        {\n          type: LEAVE_SCOPE\n        }\n      ]);\n      this._blocks = {};\n    }\n\n    //find all blocks defined in parent\n    const blocks = {};\n    node.children.forEach(child => {\n      if (child.type === BLOCK) {\n        const blockName = child.name;\n        blocks[blockName] = child;\n      }\n    });\n    if (Object.keys(blocks).length) {\n      this._setDefaultBlocks(blocks);\n    }\n\n    rendererContext.pushNode({\n      type: TokenType.PARTIAL,\n      name,\n      location,\n      indent: node.indent\n    });\n  }\n\n  _handleBlock(node, rendererContext) {\n    const { name } = node;\n    const defaultBlock = this._getDefaultBlock(name);\n    if (defaultBlock) {\n      rendererContext.pushNodes(defaultBlock.children);\n    } else {\n      rendererContext.pushNodes(node.children);\n    }\n  }\n\n  _pushParent(name, top) {\n    return this._parentStack.push({\n      name,\n      blocks: {},\n      top\n    });\n  }\n\n  _checkTop(top) {\n    let pop = 0;\n    for (let i = this._parentStack.length - 1; i >= 0; i--) {\n      const frame = this._parentStack[i];\n      if (frame.top > top) {\n        pop++;\n      } else {\n        break;\n      }\n    }\n    if (pop > 0) {\n      this._parentStack = this._parentStack.slice(\n        0,\n        this._parentStack.length - pop\n      );\n    }\n  }\n\n  _popParent() {\n    return this._parentStack.pop();\n  }\n\n  _getDefaultBlock(name) {\n    for (let i = 0; i < this._parentStack.length; i++) {\n      const frame = this._parentStack[i];\n      if (name in frame.blocks) {\n        return frame.blocks[name];\n      }\n    }\n    return null;\n  }\n\n  _setDefaultBlocks(blocks) {\n    const topFrame = this._parentStack[this._parentStack.length - 1];\n    topFrame.blocks = Object.assign(topFrame.blocks, blocks);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/extensions/inheritance.js","import * as nodeTypes from \"./node\";\nimport escapeHTML from \"escape-html\";\nimport { Parser } from \"./parser\";\nimport { walk, visit } from \"./helpers\";\nimport { instantiateAll } from \"./extension\";\n\nconst REPEATER_NODE_TYPE = \"_REPEATER\";\nconst MAX_PARTIAL_STACK = 10;\nconst MAX_LAMBDA_STACK = 255;\nconst MAX_NODE_COUNT = 3000;\n\nclass RenderContext {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n\n  get top() {\n    return this._renderer._stack.length;\n  }\n\n  get result() {\n    return this._renderer._out;\n  }\n\n  evaluate(name) {\n    return this._renderer._evaluate(name);\n  }\n\n  pushNodes(nodes) {\n    this._renderer._pushNodes(nodes);\n  }\n\n  pushNode(node) {\n    this._renderer._pushNode(node);\n  }\n\n  pushContext(ctx) {\n    this._renderer._pushContext(ctx);\n  }\n\n  appendText(text) {\n    this._renderer._out += text;\n  }\n\n  parse(src, opts) {\n    return this._renderer._parse(src, opts);\n  }\n\n  getParsedPartial(name) {\n    return this._renderer._getParsedPartial(name);\n  }\n\n  throw(message, location) {\n    return this._renderer._throw(message, location);\n  }\n}\n\nexport class Renderer {\n  constructor(src, opts = {}) {\n    //if this is true, src and values in partials are parsed tree, not string\n    this._parsed = opts.parsed || false;\n    this._filename = opts.filename;\n\n    this._partials = opts.partials || {};\n    this._delimiters = opts.delimiters ? opts.delimiters : [\"{{\", \"}}\"];\n    this._extensions = opts.extensions || instantiateAll(opts);\n    if (this._extensions.length > 0) {\n      this._renderContext = new RenderContext(this);\n    }\n\n    this._partialCached = {};\n    if (this._parsed) {\n      Object.keys(this._partials).forEach(k => {\n        this._partialCached[k] = this._partials[k].children;\n      });\n    }\n\n    this._stack = null;\n    this._contextStack = null;\n    this._partialStack = null;\n    this._lambdaStack = null;\n    this._src = src;\n    this._out = \"\";\n    this._transformNodeResult = (node, result, nodeResult) =>\n      this._extensions.reduce(\n        (r, e) => e.transformNodeResult(node, result, r),\n        nodeResult\n      );\n  }\n\n  render(context) {\n    this._out = \"\";\n    this._stack = [];\n    this._contextStack = [];\n    this._partialStack = [];\n    this._lambdaStack = [];\n\n    this._pushContext(context);\n\n    //push root nodes\n    const rootNode = this._parsed\n      ? this._src\n      : this._parse(this._src, { filename: this._filename });\n    this._stack = rootNode.children.slice(0).reverse();\n\n    let node_count = 0;\n\n    let newline = true;\n    while (this._stack.length > 0) {\n      const top = this._stack.length - 1;\n      const node = this._stack[top];\n\n      if (node.type !== nodeTypes.TEXT) {\n        node_count++;\n        if (node_count > MAX_NODE_COUNT) {\n          this._throw(\n            `Possible infinity loop detected: last node type is '${node.type}'`,\n            node.location\n          );\n        }\n      }\n\n      let handled = false;\n      if (this._extensions) {\n        this._extensions.forEach(ext => {\n          if (ext.handleNode(node, this._renderContext)) {\n            handled = true;\n          }\n        });\n      }\n\n      if (handled) {\n        this._stack.splice(top, 1);\n      } else {\n        const partial = this._partialStack.length\n          ? this._partialStack[this._partialStack.length - 1]\n          : null;\n\n        //insert indent\n        if (node.type in nodeTypes) {\n          if (newline && partial !== null && partial.indent.length > 0) {\n            this._out += partial.indent;\n          }\n        }\n\n        let value;\n        switch (node.type) {\n          case nodeTypes.VARIABLE:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              if (!!value) {\n                const result = node.unescaped ? value : escapeHTML(value);\n                this._out += this._transformNodeResult(node, this._out, result);\n              }\n              this._popNode();\n            }\n            break;\n\n          case nodeTypes.SECTION:\n            value = this._evaluate(node.name);\n            if (isFunction(value)) {\n              this._popNode();\n              this._expandLambda(node, value);\n            } else {\n              let isList = Array.isArray(value);\n\n              if (isList && value.length === 0) {\n                //Empty lists should behave like falsey values.\n                value = false;\n                isList = false;\n              }\n\n              let testResult = !!value;\n              if (node.inverted) {\n                testResult = !testResult;\n              }\n\n              if (testResult) {\n                if (isList) {\n                  this._popNode();\n                  this._pushRepeaterNode(value.length, node.children, value);\n                } else {\n                  this._popNode();\n                  this._pushContext(value);\n                  this._pushNodes(node.children);\n                }\n              } else {\n                this._popNode();\n              }\n            }\n            break;\n\n          case nodeTypes.TEXT:\n            this._out += this._transformNodeResult(node, this._out, node.text);\n            this._popNode();\n            break;\n\n          case nodeTypes.COMMENT:\n            this._popNode();\n            break;\n\n          case nodeTypes.PARTIAL:\n            this._popNode();\n            this._expandPartial(node);\n            break;\n\n          case nodeTypes.DELIMITER_CHANGE:\n            this._popNode();\n            this._delimiters = node.delimiters.slice(0);\n            break;\n\n          case REPEATER_NODE_TYPE:\n            if (node.count < node.repeat) {\n              const repeatIndex = node.count;\n              if (repeatIndex === 0) {\n                node.contextIndex = this._pushContext(node.contexts[0]);\n              } else {\n                this._replaceContextAt(\n                  node.contextIndex,\n                  node.contexts[repeatIndex]\n                );\n              }\n              this._pushNodes(node.children);\n              node.count++;\n            } else {\n              this._popNode();\n            }\n            break;\n\n          default:\n            this._popNode();\n            break;\n        }\n      }\n      this._checkStacks();\n      newline =\n        this._out.length === 0 || this._out[this._out.length - 1] === \"\\n\";\n    }\n\n    return this._extensions.reduce(\n      (result, ext) => ext.transformResult(result),\n      this._out\n    );\n  }\n\n  _parse(src, opts = {}) {\n    opts.extensions = this._extensions;\n    const parser = new Parser(opts);\n    return parser.parse(src);\n  }\n\n  _pushNodes(list) {\n    for (let i = list.length - 1; i >= 0; i--) {\n      this._stack.push(list[i]);\n    }\n  }\n\n  _pushNode(node) {\n    this._stack.push(node);\n  }\n\n  _popNode() {\n    this._stack.pop();\n  }\n\n  _pushRepeaterNode(repeat, nodes, contexts) {\n    this._stack.push({\n      type: REPEATER_NODE_TYPE,\n      count: 0,\n      repeat,\n      children: nodes.slice(0),\n      contexts\n    });\n  }\n\n  _pushContext(context) {\n    return (\n      this._contextStack.push({\n        context,\n        sp: this._stack.length\n      }) - 1\n    );\n  }\n\n  _replaceContextAt(index, context) {\n    if (index < 0 || index > this._contextStack.length - 1) {\n      throw new RangeError(\"Huz context index out of range.\");\n    }\n    this._contextStack[index].context = context;\n  }\n\n  _pushPartial({ name, indent, location }) {\n    this._partialStack.push({\n      name,\n      indent: indent || \"\",\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _pushLambda({ name, location }) {\n    this._lambdaStack.push({\n      name,\n      location,\n      sp: this._stack.length\n    });\n  }\n\n  _checkStacks() {\n    if (\n      this._stack.length < this._contextStack[this._contextStack.length - 1].sp\n    ) {\n      this._contextStack.pop();\n    }\n\n    if (\n      this._partialStack.length > 0 &&\n      this._stack.length ===\n        this._partialStack[this._partialStack.length - 1].sp\n    ) {\n      this._partialStack.pop();\n    }\n\n    if (\n      this._lambdaStack.length > 0 &&\n      this._stack.length === this._lambdaStack[this._lambdaStack.length - 1].sp\n    ) {\n      this._lambdaStack.pop();\n    }\n  }\n\n  _evaluate(name) {\n    if (name === \".\") {\n      return this._contextStack[this._contextStack.length - 1].context;\n    }\n\n    const path = name.split(\".\");\n    for (let i = this._contextStack.length - 1; i >= 0; i--) {\n      const context = this._contextStack[i].context;\n      if (context === null || typeof context !== \"object\") {\n        continue;\n      }\n\n      let current = context;\n      let resolved = true;\n      for (let pi = 0; pi < path.length; pi++) {\n        const key = path[pi];\n        if (\n          typeof current === \"object\" &&\n          current !== null &&\n          current.hasOwnProperty(key)\n        ) {\n          current = current[key];\n        } else {\n          resolved = false;\n          break;\n        }\n      }\n\n      if (resolved) {\n        return current;\n      }\n    }\n    return \"\";\n  }\n\n  _getParsedPartial(name) {\n    if (this._partialCached.hasOwnProperty(name)) {\n      return this._partialCached[name];\n    } else {\n      if (!this._partials.hasOwnProperty(name)) {\n        return null;\n      }\n      const ast = this._parse(this._partials[name], { filename: name });\n      const nodes = (this._partialCached[name] = ast.children);\n      return nodes;\n    }\n  }\n\n  _expandPartial(node) {\n    const { name } = node;\n    const nodes = this._getParsedPartial(name);\n\n    if (nodes === null) {\n      //The empty string should be used when the named partial is not found.\n      return;\n    }\n\n    this._pushPartial(node);\n\n    if (this._partialStack.length > MAX_PARTIAL_STACK) {\n      this._throw(\n        \"Possible partial short circuit: \" +\n          this._partialStack\n            .map(f => `${f.name}@${f.location.filename}:${f.location.line + 1}`)\n            .concat([name])\n            .join(\" -> \"),\n        node.location\n      );\n    }\n\n    this._pushNodes(nodes);\n  }\n\n  _expandLambda(node, lambda) {\n    const { name } = node;\n\n    this._pushLambda(node);\n\n    if (this._lambdaStack.length > MAX_LAMBDA_STACK) {\n      this._throw(\n        \"Possible lambda short circuit: \" +\n          this._lambdaStack\n            .map(f => `${f.name}@${f.location.filename}:${f.location.line + 1}`)\n            .concat([name])\n            .join(\" -> \"),\n        node.location\n      );\n    }\n\n    let ast;\n    let skipped = false;\n    if (node.type === nodeTypes.VARIABLE) {\n      const code = lambda();\n      if (code) {\n        //A lambda's return value should parse with the default delimiters.\n        ast = this._parse(\"\" + code, { filename: \"[lambda]\" });\n        if (!node.unescaped) {\n          //Lambda results should be appropriately escaped.\n          walk(ast, node => {\n            if (node.type === nodeTypes.TEXT) {\n              node.text = escapeHTML(node.text);\n            }\n          });\n        }\n      } else {\n        skipped = true;\n      }\n    } else if (node.type === nodeTypes.SECTION) {\n      const code = lambda(node.raw);\n      if (code) {\n        //Lambdas used for inverted sections should be considered truthy.\n        //Lambdas used for sections should parse with the current delimiters.\n        ast = this._parse(\"\" + code, {\n          filename: \"[#lambda]\",\n          delimiters: this._delimiters.slice(0)\n        });\n      } else {\n        skipped = true;\n      }\n    }\n\n    if (!skipped) {\n      this._pushNodes(ast.children);\n    }\n  }\n\n  _throw(message, location) {\n    const e = new Error(message);\n    e.filename = location.filename;\n    e.location = location;\n    throw e;\n  }\n}\n\nfunction isFunction(x) {\n  return Object.prototype.toString.call(x) == \"[object Function]\";\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderer.js","import { Parser } from \"./parser\";\nimport { Renderer } from \"./renderer\";\nimport * as TokenType from \"./token\";\nimport * as NodeType from \"./node\";\nimport * as Helpers from \"./helpers\";\nimport { register } from \"./extension\";\n\nexport { Tokenizer } from \"./tokenizer\";\nexport { Parser, Renderer, TokenType, NodeType };\n\nexport { Extension } from \"./extension\";\nimport { Inheritance } from \"./extensions/inheritance\";\n\nregister(Inheritance);\n\nexport function parse(src, opts) {\n  const parser = new Parser(opts);\n  return parser.parse(src);\n}\n\nexport function compile(src, opts) {\n  return new Renderer(src, opts);\n}\n\nexport function render(src, context, opts) {\n  const r = compile(src, opts);\n  return r.render(context);\n}\n\nexport { register, Helpers };\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/escape-html/index.js\n// module id = 9\n// module chunks = 0"],"sourceRoot":""}